<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torn Ranked War Dashboard by Xerra [2775419] with thanks to NestFreemark [2863072] and Pickaxe1977 [2935003]</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        .header {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            margin-bottom: 20px;
        }

        .api-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .api-input-group input {
            flex: 1;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .api-input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 12px 30px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #5568d3;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .info-text {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        .info-text ul {
            list-style-type: disc;
        }

        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
            font-size: 13px;
        }

        .warning-box strong {
            color: #856404;
        }

        .loading {
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #c33;
        }

        .faction-info {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        .faction-info h2 {
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .info-item {
            padding: 15px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .info-item label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            text-transform: uppercase;
            font-weight: 600;
        }

        .info-item value {
            display: block;
            font-size: 20px;
            color: #333;
            font-weight: 600;
        }

        .members-section {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .members-section h2 {
            color: #333;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 2px solid #667eea;
        }

        .refresh-info {
            font-size: 12px;
            color: #666;
            margin-bottom: 15px;
            font-style: italic;
        }

        .filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filters input,
        .filters select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .filters input {
            flex: 1;
            min-width: 200px;
        }

        .members-table {
            width: 100%;
            border-collapse: collapse;
            overflow-x: auto;
            display: block;
            font-size: 13px;
        }

        .members-table-wrapper {
            overflow-x: auto;
            width: 100%;
        }

        .members-table thead {
            background: #667eea;
            color: white;
        }

        .members-table th {
            padding: 10px 8px;
            text-align: left;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
            font-size: 12px;
            position: relative;
            border-right: 1px solid rgba(255,255,255,0.3);
        }

        .members-table th:last-child {
            border-right: none;
        }

        .members-table th:hover {
            background: #5568d3;
        }

        /* Column resize handle for war planning table */
        .members-table th .wp-resize-handle {
            position: absolute;
            right: -3px;
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: col-resize;
            z-index: 20;
            background: transparent;
        }

        .members-table th .wp-resize-handle:hover,
        .members-table th .wp-resize-handle.resizing {
            background: rgba(255, 193, 7, 0.7);
        }

        .members-table th.sortable::after {
            content: ' ⇅';
            opacity: 0.5;
        }

        .members-table th.sorted-asc::after {
            content: ' ↑';
            opacity: 1;
        }

        .members-table th.sorted-desc::after {
            content: ' ↓';
            opacity: 1;
        }

        /* Draggable column styles */
        .members-table th[draggable="true"] {
            cursor: grab;
        }

        .members-table th[draggable="true"]:active {
            cursor: grabbing;
        }

        .members-table th.dragging {
            opacity: 0.5;
            background: #4455bb;
        }

        .members-table th.drag-over-left {
            border-left: 3px solid #ffc107;
        }

        .members-table th.drag-over-right {
            border-right: 3px solid #ffc107;
        }

        .members-table td {
            padding: 8px;
            border-bottom: 1px solid #ddd;
            border-right: 1px solid #eee;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .members-table td:last-child {
            border-right: none;
        }

        .members-table tbody tr:hover {
            background: #f8f9fa;
        }

        .status-online {
            color: #28a745;
            font-weight: 600;
        }

        .status-offline {
            color: #dc3545;
            font-weight: 600;
        }

        .status-idle {
            color: #ffc107;
            font-weight: 600;
        }

        .status-indicator {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 2px;
            margin-right: 8px;
        }

        .status-indicator.online {
            background-color: #28a745;
        }

        .status-indicator.offline {
            background-color: #dc3545;
        }

        .status-indicator.idle {
            background-color: #ffc107;
        }

        .level-badge {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 600;
        }

        .position-badge {
            background: #764ba2;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
        }

        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-card h3 {
            font-size: 14px;
            margin-bottom: 10px;
            opacity: 0.9;
        }

        .stat-card .value {
            font-size: 28px;
            font-weight: 700;
        }

        @media (max-width: 768px) {
            .members-table {
                font-size: 12px;
            }

            .members-table th,
            .members-table td {
                padding: 8px;
            }
        }

        /* Tab Styles */
        .tabs-container {
            margin-bottom: 20px;
        }

        .tab-buttons {
            display: flex;
            gap: 0;
            border-bottom: 2px solid #667eea;
        }

        .tab-button {
            padding: 12px 24px;
            background: #f8f9fa;
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            margin-right: 4px;
        }

        .tab-button:hover {
            background: #e9ecef;
            color: #333;
        }

        .tab-button.active {
            background: #667eea;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* War Portal specific styles */
        .war-portal-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .member-card {
            background: #f8f9fa;
            border-radius: 8px;
            padding: 15px;
            border-left: 4px solid #667eea;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .member-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .member-card.online {
            border-left-color: #28a745;
        }

        .member-card.idle {
            border-left-color: #ffc107;
        }

        .member-card.offline {
            border-left-color: #dc3545;
        }

        .member-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .member-card-name {
            font-weight: 600;
            font-size: 16px;
            color: #333;
        }

        .member-card-name a {
            color: #667eea;
            text-decoration: none;
        }

        .member-card-name a:hover {
            text-decoration: underline;
        }

        .member-card-details {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            font-size: 13px;
            color: #666;
        }

        .member-card-detail {
            display: flex;
            justify-content: space-between;
        }

        .member-card-detail span:first-child {
            color: #999;
        }

        .member-card-detail span:last-child {
            font-weight: 500;
            color: #333;
        }

        .war-portal-filters {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .war-portal-filters input,
        .war-portal-filters select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .war-portal-filters input {
            flex: 1;
            min-width: 200px;
        }

        /* War Portal Two-Faction Layout */
        .war-portal-container {
            display: flex;
            gap: 20px;
        }

        .faction-column {
            flex: 1;
            min-width: 0;
        }

        .faction-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            border-radius: 8px 8px 0 0;
            margin-bottom: 0;
        }

        .faction-header.enemy {
            background: linear-gradient(135deg, #dc3545 0%, #a71d2a 100%);
        }

        .faction-header h3 {
            margin: 0 0 5px 0;
            font-size: 18px;
        }

        .faction-header-info {
            font-size: 12px;
            opacity: 0.9;
        }

        .faction-input-panel {
            background: #f8f9fa;
            padding: 10px 15px;
            border: 1px solid #ddd;
            border-top: none;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .faction-input-panel input {
            flex: 1;
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 13px;
        }

        .faction-input-panel .btn {
            padding: 8px 15px;
            font-size: 13px;
        }

        .faction-members-list {
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 600px;
            overflow-y: auto;
        }

        .portal-member-row {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }

        .portal-member-row:last-child {
            border-bottom: none;
        }

        .portal-member-row:hover {
            background: #f8f9fa;
        }

        .portal-member-name {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 10px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            border-right: 1px solid #ddd;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .portal-member-name a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .portal-member-name a:hover {
            text-decoration: underline;
        }

        .portal-member-stats {
            text-align: center;
            font-size: 12px;
            padding: 0 10px;
            border-right: 1px solid #ddd;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .portal-member-stats .est-value {
            font-weight: 600;
            color: #667eea;
        }

        .portal-member-stats .est-range {
            font-size: 10px;
            color: #999;
        }

        .portal-member-stats .real-value {
            font-weight: 600;
            color: #28a745;
        }

        .portal-member-stats .real-range {
            font-size: 10px;
            color: #28a745;
        }

        .stats-legend {
            display: flex;
            gap: 15px;
            font-size: 11px;
            margin-top: 5px;
            justify-content: center;
        }

        .stats-legend .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .stats-legend .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            display: inline-block;
        }

        .portal-member-life {
            text-align: center;
            font-size: 12px;
            padding: 0 10px;
            border-right: 1px solid #ddd;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .portal-member-life.full {
            color: #28a745;
        }

        .portal-member-life.injured {
            color: #dc3545;
        }

        .portal-member-level {
            text-align: center;
            padding: 0 10px;
            border-right: 1px solid #ddd;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .portal-member-status {
            font-size: 11px;
            padding: 0 10px;
            box-sizing: border-box;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 0;
            border-right: 1px solid #ddd;
        }

        .portal-member-timer {
            font-size: 11px;
            padding: 0 10px;
            box-sizing: border-box;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 0;
            font-family: monospace;
            font-weight: 600;
        }

        .portal-member-timer.has-timer {
            color: #dc3545;
        }

        .portal-no-data {
            padding: 30px;
            text-align: center;
            color: #999;
            font-style: italic;
        }

        .portal-header-row {
            display: flex;
            align-items: center;
            padding: 8px 0;
            background: #f0f0f0;
            border-bottom: 2px solid #ddd;
            font-weight: 600;
            font-size: 12px;
            color: #666;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .portal-header-row > div {
            cursor: grab;
            user-select: none;
            padding: 0 10px;
            border-right: 1px solid #ccc;
            box-sizing: border-box;
            position: relative;
        }

        .portal-header-row > div:active {
            cursor: grabbing;
        }

        .portal-header-row > div:last-child {
            border-right: none;
        }

        .portal-header-row > div:hover {
            color: #667eea;
        }

        .portal-header-row > div.dragging {
            opacity: 0.5;
            background: #d0d0d0;
        }

        .portal-header-row > div.drag-over-left {
            border-left: 3px solid #667eea;
        }

        .portal-header-row > div.drag-over-right {
            border-right: 3px solid #667eea;
        }

        .portal-header-row > div.sorted-asc::after {
            content: ' ▲';
            font-size: 10px;
        }

        .portal-header-row > div.sorted-desc::after {
            content: ' ▼';
            font-size: 10px;
        }

        /* Column resize handle */
        .col-resize-handle {
            position: absolute;
            right: -3px;
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: col-resize;
            z-index: 20;
            background: transparent;
        }

        .col-resize-handle:hover,
        .col-resize-handle.resizing {
            background: #667eea;
            opacity: 0.5;
        }

        /* Disable text selection while resizing */
        .resizing-columns {
            user-select: none;
            cursor: col-resize !important;
        }

        .resizing-columns * {
            cursor: col-resize !important;
        }

        .portal-member-status.status-ok {
            color: #28a745;
        }

        .portal-member-status.status-hospital {
            color: #dc3545;
        }

        .portal-member-status.status-traveling {
            color: #ffc107;
        }

        .portal-member-status.status-jail {
            color: #6c757d;
        }

        .hospital-timer {
            font-family: monospace;
            font-weight: 600;
        }

        /* Hourly Activity Grid Styles */
        .activity-grid {
            display: flex;
            gap: 1px;
            margin-top: 4px;
        }

        .hour-box {
            width: 24px;
            height: 16px;
            border-radius: 2px;
            font-size: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            position: relative;
        }

        .hour-box.online {
            background-color: #28a745;
        }

        .hour-box.partial {
            background-color: #ffc107;
        }

        .hour-box.offline {
            background-color: #dc3545;
        }

        .hour-box.unknown {
            background-color: #6c757d;
        }

        .hour-box:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 100;
            margin-bottom: 4px;
        }

        .member-name-cell {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .member-name-row {
            display: flex;
            align-items: center;
        }

        /* Estimated Stats Column */
        .est-stats {
            font-size: 11px;
            color: #666;
        }

        .est-stats-value {
            font-weight: 600;
            color: #667eea;
        }

        .real-stats-value {
            font-weight: 600;
            color: #28a745;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <h1 style="font-size: 1.4em; margin: 0;">Torn Ranked War Dashboard by <a href="https://www.torn.com/profiles.php?XID=2775419" target="_blank" style="color: #667eea; text-decoration: none;">Xerra [2775419]</a> with thanks to <a href="https://www.torn.com/profiles.php?XID=2863072" target="_blank" style="color: #667eea; text-decoration: none;">NestFreemark [2863072]</a> and <a href="https://www.torn.com/profiles.php?XID=2935003" target="_blank" style="color: #667eea; text-decoration: none;">Pickaxe1977 [2935003]</a></h1>
                <span style="font-size: 12px; color: #666; white-space: nowrap; margin-left: 15px;">V0.16 - 10/01/2026</span>
            </div>
            <div class="api-input-group">
                <input
                    type="text"
                    id="apiKey"
                    placeholder="Enter your Torn API Key"
                    value=""
                    onkeypress="handleEnterKey(event)">
                <input
                    type="text"
                    id="tornStatsApiKey"
                    placeholder="TornStats API Key (optional)"
                    value=""
                    onkeypress="handleEnterKey(event)">
                <input
                    type="text"
                    id="factionId"
                    placeholder="Faction ID (optional - leave empty for your faction)"
                    value=""
                    onkeypress="handleEnterKey(event)">
                <button class="btn" id="loadBtn" onclick="loadFactionData()">Load Faction Data</button>
                <button class="btn" id="findEnemyBtn" onclick="findEnemy()" style="background: #dc3545;">Find Enemy</button>
            </div>
            <div class="info-text">
                Your API key is stored locally in your browser and never sent anywhere except to Torn's official API.
                You can get your API key from: <a href="https://www.torn.com/preferences.php#tab=api" target="_blank">Torn Settings → API Key</a>
                <br><br>
                <div class="warning-box">
                    <strong>ℹ️ API Key Info:</strong><br>
                    A basic API key is sufficient to view all dashboard information. Create one at <a href="https://www.torn.com/preferences.php#tab=api" target="_blank" style="color: #856404; text-decoration: underline;">Torn Preferences → API Key</a>.
                    <br><br>
                    <strong>TornStats Integration:</strong> Add your <a href="https://www.tornstats.com/settings" target="_blank" style="color: #856404; text-decoration: underline;">TornStats API key</a> to see real spied battle stats when available. Stats shown in <span style="color: #28a745; font-weight: bold;">green</span> are real spied stats from TornStats.
                    <br><br>
                    <strong>Note:</strong> Some stats may show as N/A if they haven't been set yet or if the player's privacy settings restrict access. Open the browser console (F12) to see detailed API response information.
                </div>
            </div>
        </div>

        <div id="content"></div>
    </div>

    <script>
        let factionData = null;
        let membersData = [];
        let enemyFactionData = null;
        let enemyMembersData = [];

        // Save enemy faction data to localStorage
        function saveEnemyFactionData() {
            if (enemyFactionData && enemyMembersData.length > 0) {
                try {
                    localStorage.setItem('tornEnemyFactionData', JSON.stringify(enemyFactionData));
                    localStorage.setItem('tornEnemyMembersData', JSON.stringify(enemyMembersData));
                    console.log('Enemy faction data saved to localStorage');
                } catch (e) {
                    console.warn('Failed to save enemy faction data:', e);
                }
            }
        }

        // Load enemy faction data from localStorage
        function loadEnemyFactionDataFromCache() {
            try {
                const savedFactionData = localStorage.getItem('tornEnemyFactionData');
                const savedMembersData = localStorage.getItem('tornEnemyMembersData');
                if (savedFactionData && savedMembersData) {
                    enemyFactionData = JSON.parse(savedFactionData);
                    enemyMembersData = JSON.parse(savedMembersData);
                    console.log(`Restored enemy faction data: ${enemyFactionData.name} with ${enemyMembersData.length} members`);
                    return true;
                }
            } catch (e) {
                console.warn('Failed to load enemy faction data from cache:', e);
            }
            return false;
        }
        let userFactionData = null;
        let userMembersData = [];
        let sortColumn = null;
        let sortDirection = 'asc';
        let refreshInterval = null;
        let lastRefreshTime = null;
        let autoRefreshSeconds = 15; // Default refresh interval in seconds

        // Portal sorting state
        let ownPortalSortColumn = 'name';
        let ownPortalSortDirection = 'asc';
        let enemyPortalSortColumn = 'name';
        let enemyPortalSortDirection = 'asc';

        // Hospital timers - stores end timestamps for countdown
        let hospitalTimers = {};
        let hospitalTimerInterval = null;

        // TornStats spy data cache - stores fetched spy data by player ID
        // This is loaded from localStorage on startup and saved when updated
        let tornStatsCache = {};

        // Load TornStats cache from localStorage
        function loadTornStatsCache() {
            try {
                const saved = localStorage.getItem('tornStatsCache');
                if (saved) {
                    tornStatsCache = JSON.parse(saved);
                    console.log(`Loaded ${Object.keys(tornStatsCache).length} cached TornStats entries`);
                }
            } catch (e) {
                console.warn('Failed to load TornStats cache:', e);
                tornStatsCache = {};
            }
        }

        // Save TornStats cache to localStorage
        function saveTornStatsCache() {
            try {
                localStorage.setItem('tornStatsCache', JSON.stringify(tornStatsCache));
            } catch (e) {
                console.warn('Failed to save TornStats cache:', e);
            }
        }

        // Portal column widths (stored separately for own and enemy factions)
        // Default widths in pixels for: name, level, str, def, spd, dex, life, status, timer
        const defaultColumnWidths = {
            name: 150,
            level: 50,
            str: 65,
            def: 65,
            spd: 65,
            dex: 65,
            life: 70,
            status: 100,
            timer: 90
        };
        let ownColumnWidths = { ...defaultColumnWidths };
        let enemyColumnWidths = { ...defaultColumnWidths };

        // Portal column order (draggable columns)
        const defaultPortalColumns = ['name', 'level', 'str', 'def', 'spd', 'dex', 'life', 'status', 'timer'];
        let ownPortalColumnOrder = [...defaultPortalColumns];
        let enemyPortalColumnOrder = [...defaultPortalColumns];

        // Portal column definitions
        const portalColumnDefs = {
            name: { label: 'Name', sortKey: 'name' },
            level: { label: 'Level', sortKey: 'level' },
            str: { label: 'STR', sortKey: 'str' },
            def: { label: 'DEF', sortKey: 'def' },
            spd: { label: 'SPD', sortKey: 'spd' },
            dex: { label: 'DEX', sortKey: 'dex' },
            life: { label: 'Life', sortKey: 'life' },
            status: { label: 'Status', sortKey: 'status' },
            timer: { label: 'Timer', sortKey: 'timer' }
        };

        // Portal drag state
        let portalDraggedColumn = null;
        let portalDraggedIndex = null;
        let portalDragIsEnemy = false;

        // Load portal column order from localStorage
        function loadPortalColumnOrder() {
            const savedOwn = localStorage.getItem('tornPortalOwnColumnOrder');
            const savedEnemy = localStorage.getItem('tornPortalEnemyColumnOrder');
            if (savedOwn) {
                try {
                    const parsed = JSON.parse(savedOwn);
                    // Check if saved columns match current expected columns
                    const hasAllColumns = defaultPortalColumns.every(col => parsed.includes(col));
                    if (Array.isArray(parsed) && hasAllColumns && parsed.length === defaultPortalColumns.length) {
                        ownPortalColumnOrder = parsed;
                    } else {
                        // Reset to defaults if columns changed (e.g., est_stats -> str/def/spd/dex)
                        ownPortalColumnOrder = [...defaultPortalColumns];
                    }
                } catch (e) {
                    ownPortalColumnOrder = [...defaultPortalColumns];
                }
            }
            if (savedEnemy) {
                try {
                    const parsed = JSON.parse(savedEnemy);
                    const hasAllColumns = defaultPortalColumns.every(col => parsed.includes(col));
                    if (Array.isArray(parsed) && hasAllColumns && parsed.length === defaultPortalColumns.length) {
                        enemyPortalColumnOrder = parsed;
                    } else {
                        // Reset to defaults if columns changed
                        enemyPortalColumnOrder = [...defaultPortalColumns];
                    }
                } catch (e) {
                    enemyPortalColumnOrder = [...defaultPortalColumns];
                }
            }
        }

        // Save portal column order to localStorage
        function savePortalColumnOrder() {
            localStorage.setItem('tornPortalOwnColumnOrder', JSON.stringify(ownPortalColumnOrder));
            localStorage.setItem('tornPortalEnemyColumnOrder', JSON.stringify(enemyPortalColumnOrder));
        }

        // Handle portal drag start
        function handlePortalDragStart(e, isEnemy) {
            portalDraggedColumn = e.target.closest('div[data-column]');
            if (!portalDraggedColumn) return;

            portalDragIsEnemy = isEnemy;
            const parent = portalDraggedColumn.parentNode;
            const siblings = Array.from(parent.querySelectorAll('div[data-column]'));
            portalDraggedIndex = siblings.indexOf(portalDraggedColumn);

            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', portalDraggedIndex);

            setTimeout(() => {
                portalDraggedColumn.classList.add('dragging');
            }, 0);
        }

        // Handle portal drag over
        function handlePortalDragOver(e, isEnemy) {
            e.preventDefault();
            if (portalDragIsEnemy !== isEnemy) return; // Don't allow cross-faction dragging

            e.dataTransfer.dropEffect = 'move';

            const targetCol = e.target.closest('div[data-column]');
            if (!targetCol || targetCol === portalDraggedColumn) return;

            // Clear all indicators in this header row
            const parent = targetCol.parentNode;
            parent.querySelectorAll('div[data-column]').forEach(col => {
                col.classList.remove('drag-over-left', 'drag-over-right');
            });

            const rect = targetCol.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;

            if (e.clientX < midpoint) {
                targetCol.classList.add('drag-over-left');
            } else {
                targetCol.classList.add('drag-over-right');
            }
        }

        // Handle portal drag leave
        function handlePortalDragLeave(e) {
            const targetCol = e.target.closest('div[data-column]');
            if (targetCol) {
                targetCol.classList.remove('drag-over-left', 'drag-over-right');
            }
        }

        // Handle portal drop
        function handlePortalDrop(e, isEnemy) {
            e.preventDefault();
            if (portalDragIsEnemy !== isEnemy) {
                cleanupPortalDrag();
                return;
            }

            const targetCol = e.target.closest('div[data-column]');
            if (!targetCol || !portalDraggedColumn || targetCol === portalDraggedColumn) {
                cleanupPortalDrag();
                return;
            }

            const parent = targetCol.parentNode;
            const siblings = Array.from(parent.querySelectorAll('div[data-column]'));
            const targetIndex = siblings.indexOf(targetCol);

            // Determine insert position
            const rect = targetCol.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;
            let insertIndex = e.clientX < midpoint ? targetIndex : targetIndex + 1;

            if (portalDraggedIndex < insertIndex) {
                insertIndex--;
            }

            // Reorder the column array
            const columnOrder = isEnemy ? enemyPortalColumnOrder : ownPortalColumnOrder;
            const [removed] = columnOrder.splice(portalDraggedIndex, 1);
            columnOrder.splice(insertIndex, 0, removed);

            // Save and re-render
            savePortalColumnOrder();
            renderWarPortal();

            cleanupPortalDrag();
        }

        // Handle portal drag end
        function handlePortalDragEnd(e) {
            cleanupPortalDrag();
        }

        // Clean up portal drag state
        function cleanupPortalDrag() {
            if (portalDraggedColumn) {
                portalDraggedColumn.classList.remove('dragging');
            }
            document.querySelectorAll('.portal-header-row div[data-column]').forEach(col => {
                col.classList.remove('drag-over-left', 'drag-over-right');
            });
            portalDraggedColumn = null;
            portalDraggedIndex = null;
        }

        // Column resize state
        let isResizing = false;
        let resizingColumn = null;
        let resizingIsEnemy = false;
        let resizeStartX = 0;
        let resizeStartWidth = 0;

        // Load column widths from localStorage
        function loadColumnWidths() {
            const savedOwn = localStorage.getItem('tornPortalOwnColumnWidths');
            const savedEnemy = localStorage.getItem('tornPortalEnemyColumnWidths');
            if (savedOwn) {
                try {
                    ownColumnWidths = { ...defaultColumnWidths, ...JSON.parse(savedOwn) };
                } catch (e) {
                    ownColumnWidths = { ...defaultColumnWidths };
                }
            }
            if (savedEnemy) {
                try {
                    enemyColumnWidths = { ...defaultColumnWidths, ...JSON.parse(savedEnemy) };
                } catch (e) {
                    enemyColumnWidths = { ...defaultColumnWidths };
                }
            }
        }

        // Save column widths to localStorage
        function saveColumnWidths() {
            localStorage.setItem('tornPortalOwnColumnWidths', JSON.stringify(ownColumnWidths));
            localStorage.setItem('tornPortalEnemyColumnWidths', JSON.stringify(enemyColumnWidths));
        }

        // Initialize column resize handlers
        function initColumnResize() {
            document.addEventListener('mousemove', handleColumnResize);
            document.addEventListener('mouseup', stopColumnResize);
        }

        // Start resizing a column
        function startColumnResize(e, column, isEnemy) {
            e.preventDefault();
            e.stopPropagation();
            isResizing = true;
            resizingColumn = column;
            resizingIsEnemy = isEnemy;
            resizeStartX = e.clientX;
            resizeStartWidth = isEnemy ? enemyColumnWidths[column] : ownColumnWidths[column];
            document.body.classList.add('resizing-columns');
            e.target.classList.add('resizing');
        }

        // Handle column resize mouse move
        function handleColumnResize(e) {
            if (!isResizing) return;

            const diff = e.clientX - resizeStartX;
            const newWidth = Math.max(40, resizeStartWidth + diff); // Minimum 40px width

            if (resizingIsEnemy) {
                enemyColumnWidths[resizingColumn] = newWidth;
            } else {
                ownColumnWidths[resizingColumn] = newWidth;
            }

            // Update column widths in real-time
            applyColumnWidths(resizingIsEnemy);
        }

        // Stop column resize
        function stopColumnResize() {
            if (isResizing) {
                isResizing = false;
                document.body.classList.remove('resizing-columns');
                document.querySelectorAll('.col-resize-handle.resizing').forEach(el => el.classList.remove('resizing'));
                saveColumnWidths();
                resizingColumn = null;
            }
        }

        // Apply column widths to all rows in a faction list
        function applyColumnWidths(isEnemy) {
            const widths = isEnemy ? enemyColumnWidths : ownColumnWidths;
            const columnOrder = isEnemy ? enemyPortalColumnOrder : ownPortalColumnOrder;
            const listId = isEnemy ? 'enemyMembersList' : 'ownMembersList';
            const list = document.getElementById(listId);
            if (!list) return;

            // Apply to header row using data-column attribute
            const headerRow = list.querySelector('.portal-header-row');
            if (headerRow) {
                const cols = headerRow.querySelectorAll(':scope > div[data-column]');
                cols.forEach(col => {
                    const colName = col.dataset.column;
                    if (colName && widths[colName] !== undefined) {
                        col.style.width = widths[colName] + 'px';
                        col.style.minWidth = widths[colName] + 'px';
                        col.style.flexShrink = '0';
                    }
                });
            }

            // Apply to member rows using data-column attribute
            const memberRows = list.querySelectorAll('.portal-member-row');
            memberRows.forEach(row => {
                const cols = row.querySelectorAll(':scope > div[data-column]');
                cols.forEach(col => {
                    const colName = col.dataset.column;
                    if (colName && widths[colName] !== undefined) {
                        col.style.width = widths[colName] + 'px';
                        col.style.minWidth = widths[colName] + 'px';
                        col.style.flexShrink = '0';
                    }
                });
            });
        }

        // War Planning column order (draggable columns)
        const defaultWarPlanningColumns = [
            'name', 'est_stats', 'level', 'age', 'life', 'elo', 'best_damage',
            'critical_hits', 'rw_hits', 'xanax', 'vicodin', 'overdosed', 'refills', 'location'
        ];
        let warPlanningColumnOrder = [...defaultWarPlanningColumns];

        // War Planning drag state
        let draggedColumn = null;
        let draggedColumnIndex = null;

        // Load war planning column order from localStorage
        function loadWarPlanningColumnOrder() {
            const saved = localStorage.getItem('tornWarPlanningColumnOrder');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // Validate that all columns exist
                    const hasAllColumns = defaultWarPlanningColumns.every(col => parsed.includes(col));
                    if (Array.isArray(parsed) && hasAllColumns && parsed.length === defaultWarPlanningColumns.length) {
                        warPlanningColumnOrder = parsed;
                    } else {
                        // Reset to defaults if columns changed
                        warPlanningColumnOrder = [...defaultWarPlanningColumns];
                    }
                } catch (e) {
                    warPlanningColumnOrder = [...defaultWarPlanningColumns];
                }
            }
        }

        // Save war planning column order to localStorage
        function saveWarPlanningColumnOrder() {
            localStorage.setItem('tornWarPlanningColumnOrder', JSON.stringify(warPlanningColumnOrder));
        }

        // Handle drag start for war planning columns
        function handleWarPlanningDragStart(e) {
            draggedColumn = e.target.closest('th');
            if (!draggedColumn) return;

            draggedColumnIndex = Array.from(draggedColumn.parentNode.children).indexOf(draggedColumn);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedColumnIndex);

            // Add dragging class after a short delay to allow drag image to be captured
            setTimeout(() => {
                draggedColumn.classList.add('dragging');
            }, 0);
        }

        // Handle drag over for war planning columns
        function handleWarPlanningDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const th = e.target.closest('th');
            if (!th || th === draggedColumn) return;

            // Add visual indicator
            const allThs = th.parentNode.querySelectorAll('th');
            allThs.forEach(t => t.classList.remove('drag-over-left', 'drag-over-right'));

            const rect = th.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;

            if (e.clientX < midpoint) {
                th.classList.add('drag-over-left');
            } else {
                th.classList.add('drag-over-right');
            }
        }

        // Handle drag leave for war planning columns
        function handleWarPlanningDragLeave(e) {
            const th = e.target.closest('th');
            if (th) {
                th.classList.remove('drag-over-left', 'drag-over-right');
            }
        }

        // Handle drop for war planning columns
        function handleWarPlanningDrop(e) {
            e.preventDefault();

            const targetTh = e.target.closest('th');
            if (!targetTh || !draggedColumn || targetTh === draggedColumn) {
                cleanupDrag();
                return;
            }

            const targetIndex = Array.from(targetTh.parentNode.children).indexOf(targetTh);

            // Determine if we should insert before or after
            const rect = targetTh.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;
            let insertIndex = e.clientX < midpoint ? targetIndex : targetIndex + 1;

            // Adjust for the removed element
            if (draggedColumnIndex < insertIndex) {
                insertIndex--;
            }

            // Reorder the column array
            const [removed] = warPlanningColumnOrder.splice(draggedColumnIndex, 1);
            warPlanningColumnOrder.splice(insertIndex, 0, removed);

            // Save and re-render
            saveWarPlanningColumnOrder();
            filterMembers(); // This will re-render the table with new column order

            cleanupDrag();
        }

        // Handle drag end for war planning columns
        function handleWarPlanningDragEnd(e) {
            cleanupDrag();
        }

        // Clean up drag state
        function cleanupDrag() {
            if (draggedColumn) {
                draggedColumn.classList.remove('dragging');
            }
            document.querySelectorAll('.members-table th').forEach(th => {
                th.classList.remove('drag-over-left', 'drag-over-right');
            });
            draggedColumn = null;
            draggedColumnIndex = null;
        }

        // War Planning column widths (resizable)
        const defaultWPColumnWidths = {
            name: 180,
            est_stats: 100,
            level: 60,
            age: 80,
            life: 80,
            elo: 60,
            best_damage: 90,
            critical_hits: 70,
            rw_hits: 80,
            xanax: 70,
            vicodin: 70,
            overdosed: 50,
            refills: 70,
            location: 120
        };
        let wpColumnWidths = { ...defaultWPColumnWidths };

        // War Planning resize state
        let isWPResizing = false;
        let wpResizingColumn = null;
        let wpResizeStartX = 0;
        let wpResizeStartWidth = 0;

        // Load war planning column widths from localStorage
        function loadWPColumnWidths() {
            const saved = localStorage.getItem('tornWarPlanningColumnWidths');
            if (saved) {
                try {
                    wpColumnWidths = { ...defaultWPColumnWidths, ...JSON.parse(saved) };
                } catch (e) {
                    wpColumnWidths = { ...defaultWPColumnWidths };
                }
            }
        }

        // Save war planning column widths to localStorage
        function saveWPColumnWidths() {
            localStorage.setItem('tornWarPlanningColumnWidths', JSON.stringify(wpColumnWidths));
        }

        // Start resizing a war planning column
        function startWPColumnResize(e, column) {
            e.preventDefault();
            e.stopPropagation();
            isWPResizing = true;
            wpResizingColumn = column;
            wpResizeStartX = e.clientX;
            wpResizeStartWidth = wpColumnWidths[column] || defaultWPColumnWidths[column];
            document.body.classList.add('resizing-columns');
            e.target.classList.add('resizing');
        }

        // Handle war planning column resize mouse move
        function handleWPColumnResize(e) {
            if (!isWPResizing) return;

            const diff = e.clientX - wpResizeStartX;
            const newWidth = Math.max(40, wpResizeStartWidth + diff);

            wpColumnWidths[wpResizingColumn] = newWidth;
            applyWPColumnWidths();
        }

        // Stop war planning column resize
        function stopWPColumnResize() {
            if (isWPResizing) {
                isWPResizing = false;
                document.body.classList.remove('resizing-columns');
                document.querySelectorAll('.wp-resize-handle.resizing').forEach(el => el.classList.remove('resizing'));
                saveWPColumnWidths();
                wpResizingColumn = null;
            }
        }

        // Apply column widths to war planning table
        function applyWPColumnWidths() {
            const table = document.querySelector('.members-table');
            if (!table) return;

            // Apply to header cells
            const headerCells = table.querySelectorAll('thead th');
            headerCells.forEach(th => {
                const col = th.dataset.column;
                if (col && wpColumnWidths[col]) {
                    th.style.width = wpColumnWidths[col] + 'px';
                    th.style.minWidth = wpColumnWidths[col] + 'px';
                }
            });

            // Apply to body cells
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                cells.forEach((td, index) => {
                    const col = warPlanningColumnOrder[index];
                    if (col && wpColumnWidths[col]) {
                        td.style.width = wpColumnWidths[col] + 'px';
                        td.style.minWidth = wpColumnWidths[col] + 'px';
                    }
                });
            });
        }

        // Initialize war planning column resize handlers
        function initWPColumnResize() {
            document.addEventListener('mousemove', handleWPColumnResize);
            document.addEventListener('mouseup', stopWPColumnResize);
        }

        // Activity history: stores status for each member per hour
        // Format: { memberId: { hour: { online: count, total: count } } }
        let activityHistory = {};

        // Load activity history from localStorage
        function loadActivityHistory() {
            const saved = localStorage.getItem('tornActivityHistory');
            if (saved) {
                try {
                    activityHistory = JSON.parse(saved);
                    // Clean old data (older than 24 hours)
                    cleanOldActivityData();
                } catch (e) {
                    activityHistory = {};
                }
            }
        }

        // Save activity history to localStorage
        function saveActivityHistory() {
            localStorage.setItem('tornActivityHistory', JSON.stringify(activityHistory));
        }

        // Clean data older than 24 hours
        function cleanOldActivityData() {
            const now = new Date();
            const today = now.toISOString().split('T')[0];
            const yesterday = new Date(now - 24 * 60 * 60 * 1000).toISOString().split('T')[0];

            for (const memberId in activityHistory) {
                for (const hourKey in activityHistory[memberId]) {
                    if (!hourKey.startsWith(today) && !hourKey.startsWith(yesterday)) {
                        delete activityHistory[memberId][hourKey];
                    }
                }
            }
        }

        // Infer historical activity from last_action.timestamp
        // This marks the hour of their last known activity as online
        function inferHistoricalActivity(member) {
            if (!member.last_action || !member.last_action.timestamp) return;

            const lastActionTime = new Date(member.last_action.timestamp * 1000);
            const now = new Date();
            const hoursDiff = Math.floor((now - lastActionTime) / (60 * 60 * 1000));

            // Only infer for last 24 hours
            if (hoursDiff > 24) return;

            if (!activityHistory[member.id]) {
                activityHistory[member.id] = {};
            }

            // Mark the hour of last activity as online (if we don't already have data for it)
            const lastActionHourKey = lastActionTime.toISOString().split('T')[0] + '-' + lastActionTime.getHours().toString().padStart(2, '0');

            if (!activityHistory[member.id][lastActionHourKey]) {
                activityHistory[member.id][lastActionHourKey] = { online: 1, idle: 0, total: 1 };
            }

            // If they were active recently (within last hour), they were likely online for recent hours too
            // Mark hours between last action and now as partially known
            if (hoursDiff <= 1 && (member.last_action.status === 'Online' || member.last_action.status === 'Idle')) {
                const currentHourKey = now.toISOString().split('T')[0] + '-' + now.getHours().toString().padStart(2, '0');
                if (!activityHistory[member.id][currentHourKey]) {
                    if (member.last_action.status === 'Online') {
                        activityHistory[member.id][currentHourKey] = { online: 1, idle: 0, total: 1 };
                    } else {
                        activityHistory[member.id][currentHourKey] = { online: 0, idle: 1, total: 1 };
                    }
                }
            }
        }

        // Record current status for all members
        function recordActivityStatus() {
            const now = new Date();
            const hourKey = now.toISOString().split('T')[0] + '-' + now.getHours().toString().padStart(2, '0');

            membersData.forEach(member => {
                // First, infer any historical data from their last_action timestamp
                inferHistoricalActivity(member);

                if (!activityHistory[member.id]) {
                    activityHistory[member.id] = {};
                }
                if (!activityHistory[member.id][hourKey]) {
                    activityHistory[member.id][hourKey] = { online: 0, idle: 0, total: 0 };
                }

                activityHistory[member.id][hourKey].total++;
                if (member.last_action.status === 'Online') {
                    activityHistory[member.id][hourKey].online++;
                } else if (member.last_action.status === 'Idle') {
                    activityHistory[member.id][hourKey].idle++;
                }
            });

            saveActivityHistory();
        }

        // Get activity status for an hour (returns 'online', 'partial', 'offline', or 'unknown')
        function getHourStatus(memberId, hourKey) {
            if (!activityHistory[memberId] || !activityHistory[memberId][hourKey]) {
                return 'unknown';
            }

            const data = activityHistory[memberId][hourKey];
            if (data.total === 0) return 'unknown';

            const onlineRatio = (data.online + data.idle * 0.5) / data.total;

            if (onlineRatio >= 0.8) return 'online';
            if (onlineRatio >= 0.2) return 'partial';
            return 'offline';
        }

        // Generate 24-hour activity grid HTML
        function generateActivityGrid(memberId) {
            const now = new Date();
            const hours = [];

            // Generate last 24 hours
            for (let i = 23; i >= 0; i--) {
                const hourDate = new Date(now - i * 60 * 60 * 1000);
                const hourKey = hourDate.toISOString().split('T')[0] + '-' + hourDate.getHours().toString().padStart(2, '0');
                const hourLabel = hourDate.getHours().toString().padStart(2, '0') + ':00';
                const status = getHourStatus(memberId, hourKey);

                hours.push(`<div class="hour-box ${status}" data-tooltip="${hourLabel}" title="${hourLabel}">${hourDate.getHours()}</div>`);
            }

            return `<div class="activity-grid">${hours.join('')}</div>`;
        }

        // Estimate battle stats based on publicly available data
        // Formula based on community research: xanax is a strong indicator
        // ~500M total stats per 1000 xanax as conservative baseline
        function estimateBattleStats(member) {
            const stats = member.details.personalstats || {};
            const profile = member.details || {};

            const level = member.level || 1;
            const age = profile.age || 1;
            const xanax = stats.xantaken || 0;
            const refills = stats.energydrinkused || stats.refills || 0;
            const attacks = (stats.attackswon || 0) + (stats.attackslost || 0);

            // Base estimation using multiple factors
            let estimate = 0;

            // Primary factor: Xanax (most reliable indicator)
            // Community research suggests ~500-750M total stats per 1000 xanax
            if (xanax > 0) {
                estimate = xanax * 500000; // 500K per xanax as baseline
            }

            // Secondary factors - dampened to avoid over-inflation
            // Level adds modest multiplier (up to 1.3x at level 100)
            const levelFactor = 1 + (level / 333);
            // Age adds modest multiplier (up to 1.3x over 10 years)
            const ageFactor = 1 + Math.min(age / 12167, 0.3);

            // If no xanax data, use level/age based estimation
            if (estimate === 0) {
                const baseStat = 1000000;
                estimate = baseStat * levelFactor * ageFactor;
            } else {
                // Apply dampened modifiers (factor * 0.2 + 0.8 gives range 0.8-1.06)
                estimate = estimate * (levelFactor * 0.2 + 0.8) * (ageFactor * 0.2 + 0.8);
            }

            // Refills boost - reduced impact (up to 20% boost instead of 50%)
            if (refills > 0) {
                estimate *= 1 + Math.min(refills / 10000, 0.2);
            }

            return {
                low: Math.round(estimate * 0.6),
                mid: Math.round(estimate),
                high: Math.round(estimate * 1.5)
            };
        }

        // Fetch spy data from TornStats for a list of player IDs
        // forceUpdate: if true, fetches all players regardless of cache
        // Returns the number of players with real spy data found
        async function fetchTornStatsSpyData(playerIds, forceUpdate = false) {
            const tornStatsApiKey = document.getElementById('tornStatsApiKey').value.trim();
            if (!tornStatsApiKey) {
                console.log('TornStats: No API key provided, skipping fetch');
                return 0; // No TornStats API key provided
            }

            console.log(`TornStats: Fetching spy data for ${playerIds.length} players (forceUpdate: ${forceUpdate})...`);

            // Filter out players we already have valid cached data for (unless force update)
            // For normal refresh, skip players we've already checked (even if no data)
            // For force update, re-fetch everyone
            const idsToFetch = forceUpdate ? [...playerIds] : playerIds.filter(id => {
                const cached = tornStatsCache[id];
                // Skip if we have valid spy data with a timestamp
                if (cached && cached.total && cached.timestamp) {
                    console.log(`TornStats: Player ${id} already has cached data`);
                    return false;
                }
                // Skip if we checked recently and found no data (check again after 1 hour)
                if (cached && cached.noData && cached.checkedAt) {
                    const hoursSinceCheck = (Date.now() - cached.checkedAt) / (1000 * 60 * 60);
                    if (hoursSinceCheck < 1) {
                        console.log(`TornStats: Player ${id} checked recently (${hoursSinceCheck.toFixed(1)}h ago), skipping`);
                        return false;
                    }
                }
                return true;
            });

            console.log(`TornStats: Will fetch ${idsToFetch.length} players (${playerIds.length - idsToFetch.length} cached)`);

            if (idsToFetch.length === 0) {
                console.log('All players already in TornStats cache');
                return 0;
            }

            let foundCount = 0;

            // TornStats API has rate limits, so we batch requests with delays
            const batchSize = 10;
            const delayMs = 1000; // 1 second between batches

            for (let i = 0; i < idsToFetch.length; i += batchSize) {
                const batch = idsToFetch.slice(i, i + batchSize);

                const promises = batch.map(async (playerId) => {
                    try {
                        const response = await fetch(
                            `https://www.tornstats.com/api/v2/${tornStatsApiKey}/spy/user/${playerId}`
                        );
                        const data = await response.json();

                        console.log(`TornStats API response for ${playerId}:`, data);

                        if (data.status === true && data.spy && data.spy.total) {
                            const newTimestamp = data.spy.timestamp || null;
                            const existingData = tornStatsCache[playerId];

                            // Only update if new data is more recent or we don't have data
                            if (!existingData || !existingData.timestamp || !newTimestamp ||
                                newTimestamp >= existingData.timestamp) {
                                tornStatsCache[playerId] = {
                                    total: data.spy.total,
                                    strength: data.spy.strength || null,
                                    speed: data.spy.speed || null,
                                    defense: data.spy.defense || null,
                                    dexterity: data.spy.dexterity || null,
                                    timestamp: newTimestamp,
                                    isEstimate: data.spy.target_score !== undefined
                                };
                                foundCount++;
                                console.log(`TornStats: Got spy data for ${playerId}: ${formatStatNumber(data.spy.total)}`);
                            }
                        } else {
                            // No spy data available, mark as checked with timestamp
                            console.log(`TornStats: No spy data for ${playerId}`);
                            tornStatsCache[playerId] = { noData: true, checkedAt: Date.now() };
                        }
                    } catch (error) {
                        console.warn(`TornStats: Error fetching spy for ${playerId}:`, error.message);
                        tornStatsCache[playerId] = { error: true, checkedAt: Date.now() };
                    }
                });

                await Promise.all(promises);

                // Delay before next batch (except for last batch)
                if (i + batchSize < idsToFetch.length) {
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                }
            }

            // Save cache to localStorage
            saveTornStatsCache();

            console.log(`TornStats spy data fetch complete. Found ${foundCount} players with spy data.`);
            return foundCount;
        }

        // Get battle stats for a player (prefers TornStats real data, falls back to estimate)
        function getBattleStats(member) {
            const playerId = member.id || member.player_id;
            const spyData = tornStatsCache[playerId];

            if (spyData && spyData.total && !spyData.noData && !spyData.error) {
                // We have real spy data from TornStats
                const spyDate = spyData.timestamp ? new Date(spyData.timestamp * 1000) : null;
                const daysAgo = spyDate ? Math.floor((Date.now() - spyDate) / (1000 * 60 * 60 * 24)) : null;

                return {
                    total: spyData.total,
                    strength: spyData.strength,
                    speed: spyData.speed,
                    defense: spyData.defense,
                    dexterity: spyData.dexterity,
                    isReal: true,
                    isEstimate: spyData.isEstimate || false,
                    spyDate: spyDate,
                    daysAgo: daysAgo
                };
            }

            // Fall back to estimated stats
            const estimated = estimateBattleStats(member);
            return {
                total: estimated.mid,
                low: estimated.low,
                high: estimated.high,
                isReal: false,
                isEstimate: true
            };
        }

        // Format large numbers
        function formatStatNumber(num) {
            if (num >= 1e12) return (num / 1e12).toFixed(1) + 'T';
            if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
            if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
            return num.toString();
        }

        // Handle Enter key press on input fields
        function handleEnterKey(event) {
            if (event.key === 'Enter') {
                loadFactionData();
            }
        }

        // Find and load enemy faction from current ranked war
        async function findEnemy() {
            const apiKey = document.getElementById('apiKey').value.trim();

            if (!apiKey) {
                showError('Please enter your API key first');
                return;
            }

            showLoading();

            try {
                // First, get the user's faction ID
                const userResponse = await fetch(`https://api.torn.com/user?selections=basic&key=${apiKey}`);
                const userData = await userResponse.json();

                if (userData.error) {
                    throw new Error(userData.error.error);
                }

                const myFactionId = userData.faction.faction_id;

                if (!myFactionId) {
                    throw new Error('You are not in a faction');
                }

                // Get faction's ranked war info
                const factionResponse = await fetch(`https://api.torn.com/faction/${myFactionId}?selections=rankedwars&key=${apiKey}`);
                const factionData = await factionResponse.json();

                if (factionData.error) {
                    throw new Error(factionData.error.error);
                }

                console.log('Ranked wars data:', factionData);

                // Find active ranked war
                const rankedWars = factionData.rankedwars || {};
                let enemyFactionId = null;

                for (const warId in rankedWars) {
                    const war = rankedWars[warId];
                    // Check if war is active (has factions but no winner yet or is ongoing)
                    if (war.factions) {
                        for (const factionId in war.factions) {
                            if (factionId != myFactionId) {
                                enemyFactionId = factionId;
                                break;
                            }
                        }
                    }
                    if (enemyFactionId) break;
                }

                if (!enemyFactionId) {
                    throw new Error('You are not currently matched for a Ranked War against another faction!');
                }

                // Load the enemy faction
                document.getElementById('factionId').value = enemyFactionId;
                localStorage.setItem('tornFactionId', enemyFactionId);
                loadFactionData();

            } catch (error) {
                console.error('Error finding enemy:', error);
                showError(`Error finding enemy faction: ${error.message}`);
            }
        }

        // Find enemy for War Portal (loads into enemy column instead of main view)
        async function findEnemyForPortal() {
            const apiKey = document.getElementById('apiKey').value.trim();

            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            try {
                // First, get the user's faction ID
                const userResponse = await fetch(`https://api.torn.com/user?selections=basic&key=${apiKey}`);
                const userData = await userResponse.json();

                if (userData.error) {
                    throw new Error(userData.error.error);
                }

                const myFactionId = userData.faction.faction_id;

                if (!myFactionId) {
                    throw new Error('You are not in a faction');
                }

                // Get faction's ranked war info
                const factionResponse = await fetch(`https://api.torn.com/faction/${myFactionId}?selections=rankedwars&key=${apiKey}`);
                const factionRWData = await factionResponse.json();

                if (factionRWData.error) {
                    throw new Error(factionRWData.error.error);
                }

                // Find active ranked war
                const rankedWars = factionRWData.rankedwars || {};
                let enemyFactionId = null;

                for (const warId in rankedWars) {
                    const war = rankedWars[warId];
                    if (war.factions) {
                        for (const fId in war.factions) {
                            if (fId != myFactionId) {
                                enemyFactionId = fId;
                                break;
                            }
                        }
                    }
                    if (enemyFactionId) break;
                }

                if (!enemyFactionId) {
                    throw new Error('You are not currently matched for a Ranked War against another faction!');
                }

                // Update the portal enemy input and load enemy
                const portalEnemyInput = document.getElementById('portalEnemyFactionId');
                if (portalEnemyInput) {
                    portalEnemyInput.value = enemyFactionId;
                }
                loadEnemyFaction(enemyFactionId);

            } catch (error) {
                console.error('Error finding enemy:', error);
                alert(`Error finding enemy faction: ${error.message}`);
            }
        }

        // Load enemy faction data for War Portal
        async function loadEnemyFaction(enemyId) {
            const apiKey = document.getElementById('apiKey').value.trim();
            const enemyFactionId = enemyId || document.getElementById('portalEnemyFactionId').value.trim();

            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            if (!enemyFactionId) {
                alert('Please enter an enemy faction ID');
                return;
            }

            // Save enemy faction ID
            localStorage.setItem('tornEnemyFactionId', enemyFactionId);

            // Show loading in enemy column
            const enemyList = document.getElementById('enemyMembersList');
            if (enemyList) {
                enemyList.innerHTML = '<div class="portal-no-data">Loading enemy faction...</div>';
            }

            try {
                // Load enemy faction basic info
                const factionUrl = `https://api.torn.com/faction/${enemyFactionId}?selections=basic&key=${apiKey}`;
                const response = await fetch(factionUrl);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.error);
                }

                enemyFactionData = data;

                // Extract member IDs from the faction data
                const memberIds = data.members ? Object.keys(data.members) : [];

                // Fetch details for all enemy members
                const memberDetailsPromises = memberIds.map(id =>
                    fetch(`https://api.torn.com/user/${id}?selections=profile,personalstats&key=${apiKey}`)
                        .then(r => r.json())
                        .then(d => ({ id, ...d }))
                        .catch(e => ({ id, error: e.message }))
                );

                const memberDetails = await Promise.all(memberDetailsPromises);

                // Merge member details with basic faction member data
                enemyMembersData = memberIds.map(id => {
                    const member = data.members[id];
                    const details = memberDetails.find(d => d.id === id) || {};
                    return {
                        id,
                        ...member,
                        details: details || {}
                    };
                });

                // Fetch TornStats spy data for enemy members (if API key provided)
                await fetchTornStatsSpyData(memberIds);

                // Save enemy faction data to localStorage for restore on reload
                saveEnemyFactionData();

                // Update the War Portal display
                renderWarPortal();

            } catch (error) {
                console.error('Error loading enemy faction:', error);
                const enemyList = document.getElementById('enemyMembersList');
                if (enemyList) {
                    enemyList.innerHTML = `<div class="portal-no-data">Error: ${error.message}</div>`;
                }
            }
        }

        // Load user's own faction data for War Portal
        async function loadUserFaction() {
            const apiKey = document.getElementById('apiKey').value.trim();

            if (!apiKey) {
                return;
            }

            try {
                // First, get the user's faction ID
                const userResponse = await fetch(`https://api.torn.com/user?selections=basic&key=${apiKey}`);
                const userData = await userResponse.json();

                if (userData.error) {
                    throw new Error(userData.error.error);
                }

                const myFactionId = userData.faction.faction_id;

                if (!myFactionId) {
                    console.log('User is not in a faction');
                    return;
                }

                // Save user's faction ID
                localStorage.setItem('tornUserFactionId', myFactionId.toString());

                // Load user's faction data
                const factionUrl = `https://api.torn.com/faction/${myFactionId}?selections=basic&key=${apiKey}`;
                const response = await fetch(factionUrl);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.error);
                }

                userFactionData = data;

                // Extract member IDs from the faction data
                const memberIds = data.members ? Object.keys(data.members) : [];

                // Fetch details for all members
                const memberDetailsPromises = memberIds.map(id =>
                    fetch(`https://api.torn.com/user/${id}?selections=profile,personalstats&key=${apiKey}`)
                        .then(r => r.json())
                        .then(d => ({ id, ...d }))
                        .catch(e => ({ id, error: e.message }))
                );

                const memberDetails = await Promise.all(memberDetailsPromises);

                // Merge member details with basic faction member data
                userMembersData = memberIds.map(id => {
                    const member = data.members[id];
                    const details = memberDetails.find(d => d.id === id) || {};
                    return {
                        id,
                        ...member,
                        details: details || {}
                    };
                });

                // Fetch TornStats spy data for own faction members (if API key provided)
                await fetchTornStatsSpyData(memberIds);

                // Update the War Portal display
                renderWarPortal();

            } catch (error) {
                console.error('Error loading user faction:', error);
            }
        }

        // Force update TornStats data for own faction
        async function forceUpdateOwnTornStats() {
            // Use userMembersData if available, otherwise fall back to membersData
            const ownMembers = userMembersData.length > 0 ? userMembersData : membersData;

            if (!ownMembers || ownMembers.length === 0) {
                alert('Please load your faction data first');
                return;
            }

            const tornStatsApiKey = document.getElementById('tornStatsApiKey').value.trim();
            if (!tornStatsApiKey) {
                alert('Please enter your TornStats API key first');
                return;
            }

            const memberIds = ownMembers.map(m => m.id);
            const btn = document.getElementById('ownForceUpdateBtn');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Updating...';
            }

            try {
                const foundCount = await fetchTornStatsSpyData(memberIds, true);
                alert(`TornStats update complete. Found spy data for ${foundCount} of ${memberIds.length} members.`);
                renderWarPortal();
            } catch (e) {
                alert('Error updating TornStats: ' + e.message);
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Force Update';
                }
            }
        }

        // Force update TornStats data for enemy faction
        async function forceUpdateEnemyTornStats() {
            if (!enemyMembersData || enemyMembersData.length === 0) {
                alert('Please load enemy faction data first');
                return;
            }

            const tornStatsApiKey = document.getElementById('tornStatsApiKey').value.trim();
            if (!tornStatsApiKey) {
                alert('Please enter your TornStats API key first');
                return;
            }

            const memberIds = enemyMembersData.map(m => m.id);
            const btn = document.getElementById('enemyForceUpdateBtn');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Updating...';
            }

            try {
                const foundCount = await fetchTornStatsSpyData(memberIds, true);
                alert(`TornStats update complete. Found spy data for ${foundCount} of ${memberIds.length} members.`);
                renderWarPortal();
            } catch (e) {
                alert('Error updating TornStats: ' + e.message);
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Force Update';
                }
            }
        }

        // Load saved API key and faction ID from localStorage
        window.addEventListener('DOMContentLoaded', () => {
            loadActivityHistory();
            loadColumnWidths();
            loadPortalColumnOrder();
            loadWarPlanningColumnOrder();
            loadWPColumnWidths();
            initColumnResize();
            initWPColumnResize();
            loadTornStatsCache();
            loadEnemyFactionDataFromCache();

            // Load saved auto-refresh interval
            const savedAutoRefresh = localStorage.getItem('tornAutoRefreshSeconds');
            if (savedAutoRefresh) {
                autoRefreshSeconds = parseInt(savedAutoRefresh);
            }

            const savedKey = localStorage.getItem('tornApiKey');
            if (savedKey) {
                document.getElementById('apiKey').value = savedKey;
            }

            const savedFactionId = localStorage.getItem('tornFactionId');
            if (savedFactionId) {
                document.getElementById('factionId').value = savedFactionId;
            }

            const savedTornStatsKey = localStorage.getItem('tornStatsApiKey');
            if (savedTornStatsKey) {
                document.getElementById('tornStatsApiKey').value = savedTornStatsKey;
            }

            // Auto-load faction data if API key is saved
            if (savedKey) {
                loadFactionData();
            }
        });

        async function loadFactionData() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const tornStatsApiKey = document.getElementById('tornStatsApiKey').value.trim();
            const factionId = document.getElementById('factionId').value.trim() || '';

            if (!apiKey) {
                showError('Please enter your API key');
                return;
            }

            // Save API key to localStorage
            localStorage.setItem('tornApiKey', apiKey);

            // Save TornStats API key to localStorage (if provided)
            if (tornStatsApiKey) {
                localStorage.setItem('tornStatsApiKey', tornStatsApiKey);
            }

            // Save faction ID to localStorage (if provided)
            if (factionId) {
                localStorage.setItem('tornFactionId', factionId);
            }

            showLoading();

            try {
                // Load faction basic info and members
                // Note: Using API without /v2 for better compatibility
                const factionUrl = factionId
                    ? `https://api.torn.com/faction/${factionId}?selections=basic&key=${apiKey}`
                    : `https://api.torn.com/faction?selections=basic&key=${apiKey}`;

                const response = await fetch(factionUrl);
                const data = await response.json();

                console.log('Faction data response:', data);

                if (data.error) {
                    throw new Error(data.error.error);
                }

                factionData = data;

                // If faction ID was blank, store the loaded faction's ID for future use
                if (!factionId && data.ID) {
                    localStorage.setItem('tornFactionId', data.ID.toString());
                    document.getElementById('factionId').value = data.ID;
                }

                // Extract member IDs from the faction data which includes members in basic
                const memberIds = data.members ? Object.keys(data.members) : [];
                console.log('Fetching details for', memberIds.length, 'members');

                const memberDetailsPromises = memberIds.map(id =>
                    fetch(`https://api.torn.com/user/${id}?selections=profile,personalstats&key=${apiKey}`)
                        .then(r => r.json())
                        .then(d => {
                            console.log(`Member ${id} data:`, d);
                            if (d.error) {
                                console.warn(`API returned error for member ${id}:`, d.error);
                            }
                            return { ...d, member_id: id };
                        })
                        .catch(e => {
                            console.error(`Error fetching member ${id}:`, e);
                            return { member_id: id, error: e.message };
                        })
                );

                const memberDetails = await Promise.all(memberDetailsPromises);

                membersData = Object.entries(data.members || {}).map(([id, member]) => {
                    const details = memberDetails.find(d => d.member_id == id || d.player_id == id);

                    // Check if the details have an error
                    if (details && details.error) {
                        console.warn(`Member ${id} details have error:`, details.error);
                    }

                    return {
                        id,
                        ...member,
                        details: details || {}
                    };
                });

                // Check if any member details failed to load
                const failedMembers = memberDetails.filter(d => d.error);
                if (failedMembers.length > 0) {
                    console.warn(`Failed to load details for ${failedMembers.length} members. This may be due to API key permissions.`);
                }

                lastRefreshTime = new Date();
                recordActivityStatus(); // Record activity for tracking
                renderDashboard();
                restoreActiveTab(); // Restore saved tab after rendering
                startAutoRefresh();

                // Also load user's own faction for War Portal if not already loaded
                if (userMembersData.length === 0) {
                    loadUserFaction();
                }
            } catch (error) {
                console.error('Error details:', error);
                showError(`Error loading faction data: ${error.message}<br><br>Check browser console (F12) for more details.`);
            }
        }

        function startAutoRefresh() {
            // Clear any existing interval
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }

            // Refresh based on user-selected interval - refreshes status for both factions
            refreshInterval = setInterval(async () => {
                const apiKey = document.getElementById('apiKey').value.trim();

                if (!apiKey) return;

                try {
                    // Collect all member IDs to refresh (both own and enemy factions)
                    const ownMemberIds = (userMembersData.length > 0 ? userMembersData : membersData).map(m => m.id);
                    const enemyMemberIds = enemyMembersData.map(m => m.id);
                    const allMemberIds = [...ownMemberIds, ...enemyMemberIds];

                    if (allMemberIds.length === 0) return;

                    // Fetch basic status info for all members
                    const statusPromises = allMemberIds.map(id =>
                        fetch(`https://api.torn.com/user/${id}?selections=profile&key=${apiKey}`)
                            .then(r => r.json())
                            .then(d => ({ id, ...d }))
                            .catch(e => ({ id, error: e.message }))
                    );

                    const statusUpdates = await Promise.all(statusPromises);

                    // Helper function to update member data with status
                    const updateMemberStatus = (member) => {
                        const update = statusUpdates.find(u => u.id === member.id);
                        if (update && !update.error) {
                            return {
                                ...member,
                                status: update.status || member.status,
                                last_action: update.last_action || member.last_action,
                                details: {
                                    ...member.details,
                                    status: update.status || member.details?.status,
                                    last_action: update.last_action || member.details?.last_action,
                                    life: update.life || member.details?.life
                                }
                            };
                        }
                        return member;
                    };

                    // Update own faction members
                    if (userMembersData.length > 0) {
                        userMembersData = userMembersData.map(updateMemberStatus);
                    } else if (membersData.length > 0) {
                        membersData = membersData.map(updateMemberStatus);
                    }

                    // Update enemy faction members
                    if (enemyMembersData.length > 0) {
                        enemyMembersData = enemyMembersData.map(updateMemberStatus);
                    }

                    lastRefreshTime = new Date();

                    // Update the refresh time display
                    const refreshTimeElement = document.getElementById('lastRefreshTime');
                    if (refreshTimeElement) {
                        refreshTimeElement.textContent = formatTime(lastRefreshTime);
                    }

                    // Re-render the War Portal to show updated status
                    renderWarPortal();
                } catch (error) {
                    console.error('Auto-refresh error:', error);
                }
            }, autoRefreshSeconds * 1000);
        }

        function changeAutoRefreshInterval(seconds) {
            autoRefreshSeconds = parseInt(seconds);
            localStorage.setItem('tornAutoRefreshSeconds', autoRefreshSeconds);

            // Update the display text
            const displaySpan = document.getElementById('autoRefreshDisplay');
            if (displaySpan) {
                displaySpan.textContent = autoRefreshSeconds;
            }

            // Restart the auto-refresh with the new interval
            startAutoRefresh();
        }

        function stopAutoRefresh() {
            if (refreshInterval) {
                clearInterval(refreshInterval);
                refreshInterval = null;
            }
        }

        function showLoading() {
            document.getElementById('content').innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <p>Loading faction data...</p>
                </div>
            `;
        }

        function showError(message) {
            document.getElementById('content').innerHTML = `
                <div class="error">
                    <strong>Error:</strong> ${message}
                </div>
            `;
        }

        function renderDashboard() {
            const content = document.getElementById('content');

            const onlineCount = membersData.filter(m => m.last_action.status === 'Online').length;
            const idleCount = membersData.filter(m => m.last_action.status === 'Idle').length;
            const offlineCount = membersData.filter(m => m.last_action.status === 'Offline').length;
            const totalLevel = membersData.reduce((sum, m) => sum + (m.level || 0), 0);
            const avgLevel = Math.round(totalLevel / membersData.length);

            content.innerHTML = `
                <div class="faction-info">
                    <h2>${factionData.name || 'Faction Information'}</h2>
                    <div class="info-grid">
                        <div class="info-item">
                            <label>Faction ID</label>
                            <value>${factionData.ID || 'N/A'}</value>
                        </div>
                        <div class="info-item">
                            <label>Members</label>
                            <value>${membersData.length}</value>
                        </div>
                        <div class="info-item">
                            <label>Respect</label>
                            <value>${(factionData.respect || 0).toLocaleString()}</value>
                        </div>
                        <div class="info-item">
                            <label>Age</label>
                            <value>${factionData.age || 'N/A'} days</value>
                        </div>
                        <div class="info-item">
                            <label>Capacity</label>
                            <value>${factionData.capacity || 'N/A'}</value>
                        </div>
                        <div class="info-item">
                            <label>Leader</label>
                            <value>${factionData.leader ? `<a href="https://www.torn.com/profiles.php?XID=${factionData.leader}" target="_blank" style="color: #667eea; text-decoration: none;">${getLeaderName()}</a>` : 'N/A'}</value>
                        </div>
                    </div>
                </div>

                <div class="members-section">
                    <h2>Members Overview: ${factionData.name || 'Unknown Faction'}</h2>
                    <div class="refresh-info">
                        Auto-refreshing every <span id="autoRefreshDisplay">${autoRefreshSeconds}</span> seconds.
                        <select id="autoRefreshSelect" onchange="changeAutoRefreshInterval(this.value)" style="margin-left: 10px; padding: 2px 5px; border-radius: 3px; border: 1px solid #ddd;">
                            <option value="5" ${autoRefreshSeconds === 5 ? 'selected' : ''}>5s</option>
                            <option value="10" ${autoRefreshSeconds === 10 ? 'selected' : ''}>10s</option>
                            <option value="15" ${autoRefreshSeconds === 15 ? 'selected' : ''}>15s</option>
                            <option value="30" ${autoRefreshSeconds === 30 ? 'selected' : ''}>30s</option>
                        </select>
                        Last updated: <span id="lastRefreshTime">${formatTime(lastRefreshTime)}</span>
                    </div>

                    <div class="stats-summary">
                        <div class="stat-card">
                            <h3>Online</h3>
                            <div class="value">${onlineCount}</div>
                        </div>
                        <div class="stat-card">
                            <h3>Idle</h3>
                            <div class="value">${idleCount}</div>
                        </div>
                        <div class="stat-card">
                            <h3>Offline</h3>
                            <div class="value">${offlineCount}</div>
                        </div>
                        <div class="stat-card">
                            <h3>Average Level</h3>
                            <div class="value">${avgLevel}</div>
                        </div>
                    </div>

                    <div class="tabs-container">
                        <div class="tab-buttons">
                            <button class="tab-button active" onclick="switchTab('war-planning')">War Planning</button>
                            <button class="tab-button" onclick="switchTab('war-portal')">War Portal</button>
                        </div>

                        <div id="war-planning" class="tab-content active">
                            <div class="filters">
                                <input type="text" id="searchInput" placeholder="Search members..." onkeyup="filterMembers()">
                                <select id="statusFilter" onchange="filterMembers()">
                                    <option value="">All Status</option>
                                    <option value="Online">Online</option>
                                    <option value="Idle">Idle</option>
                                    <option value="Offline">Offline</option>
                                </select>
                                <select id="locationFilter" onchange="filterMembers()">
                                    <option value="">All Locations</option>
                                    ${getUniqueLocations().map(loc => `<option value="${loc.toLowerCase()}">${loc}</option>`).join('')}
                                </select>
                                <select id="positionFilter" onchange="filterMembers()">
                                    <option value="">All Positions</option>
                                    ${getUniquePositions().map(pos => `<option value="${pos}">${pos}</option>`).join('')}
                                </select>
                            </div>
                            <div id="membersTableContainer"></div>
                        </div>

                        <div id="war-portal" class="tab-content">
                            <div id="warPortalContainer"></div>
                        </div>
                    </div>
                </div>
            `;

            renderMembersTable(membersData);
            renderWarPortal();
        }

        function getUniquePositions() {
            const positions = new Set(membersData.map(m => m.position));
            return Array.from(positions).sort();
        }

        function getUniqueLocations() {
            const locations = new Set();
            membersData.forEach(m => {
                const userStatus = (m.details && m.details.status) || {};
                let locationText = (userStatus.description || userStatus.state || 'Unknown').trim();

                if (locationText && locationText !== 'Unknown') {
                    // Normalize hospital statuses to just "In Hospital"
                    if (locationText.toLowerCase().includes('hospital')) {
                        locationText = 'In Hospital';
                    }
                    // Normalize jail statuses to just "In Jail"
                    else if (locationText.toLowerCase().includes('jail')) {
                        locationText = 'In Jail';
                    }
                    // Normalize traveling statuses
                    else if (locationText.toLowerCase().includes('traveling') || locationText.toLowerCase().includes('flying')) {
                        locationText = 'Traveling';
                    }

                    locations.add(locationText);
                }
            });
            return Array.from(locations).sort();
        }

        function filterMembers() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const statusFilter = document.getElementById('statusFilter').value;
            const locationFilter = document.getElementById('locationFilter').value.toLowerCase();
            const positionFilter = document.getElementById('positionFilter').value;

            let filtered = membersData.filter(member => {
                const matchesSearch = member.name.toLowerCase().includes(searchTerm);
                const matchesStatus = !statusFilter || member.last_action.status === statusFilter;

                // Check location filter using the status from details
                let matchesLocation = true;
                if (locationFilter) {
                    const userStatus = (member.details && member.details.status) || {};
                    const locationText = (userStatus.description || userStatus.state || '').toLowerCase();
                    matchesLocation = locationText.includes(locationFilter);
                }

                const matchesPosition = !positionFilter || member.position === positionFilter;
                return matchesSearch && matchesStatus && matchesLocation && matchesPosition;
            });

            renderMembersTable(filtered);
        }

        function sortMembers(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }

            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const statusFilter = document.getElementById('statusFilter').value;
            const locationFilter = document.getElementById('locationFilter').value.toLowerCase();
            const positionFilter = document.getElementById('positionFilter').value;

            let filtered = membersData.filter(member => {
                const matchesSearch = member.name.toLowerCase().includes(searchTerm);
                const matchesStatus = !statusFilter || member.last_action.status === statusFilter;

                // Check location filter using the status from details
                let matchesLocation = true;
                if (locationFilter) {
                    const userStatus = (member.details && member.details.status) || {};
                    const locationText = (userStatus.description || userStatus.state || '').toLowerCase();
                    matchesLocation = locationText.includes(locationFilter);
                }

                const matchesPosition = !positionFilter || member.position === positionFilter;
                return matchesSearch && matchesStatus && matchesLocation && matchesPosition;
            });

            filtered.sort((a, b) => {
                let aVal, bVal;

                switch(column) {
                    case 'name':
                        aVal = a.name.toLowerCase();
                        bVal = b.name.toLowerCase();
                        break;
                    case 'est_stats':
                        aVal = estimateBattleStats(a).mid;
                        bVal = estimateBattleStats(b).mid;
                        break;
                    case 'level':
                        aVal = a.level || 0;
                        bVal = b.level || 0;
                        break;
                    case 'age':
                        aVal = (a.details && a.details.age) || 0;
                        bVal = (b.details && b.details.age) || 0;
                        break;
                    case 'life':
                        aVal = (a.details && a.details.life && a.details.life.current) || 0;
                        bVal = (b.details && b.details.life && b.details.life.current) || 0;
                        break;
                    case 'elo':
                        aVal = (a.details && a.details.personalstats && (a.details.personalstats.elo || a.details.personalstats.rankedwarrating)) || 0;
                        bVal = (b.details && b.details.personalstats && (b.details.personalstats.elo || b.details.personalstats.rankedwarrating)) || 0;
                        break;
                    case 'best_damage':
                        aVal = (a.details && a.details.personalstats && (a.details.personalstats.bestdamage || a.details.personalstats.highestbeaten)) || 0;
                        bVal = (b.details && b.details.personalstats && (b.details.personalstats.bestdamage || b.details.personalstats.highestbeaten)) || 0;
                        break;
                    case 'critical_hits':
                        const aCrit = (a.details && a.details.personalstats && a.details.personalstats.attackcriticalhits) || 0;
                        const aTotal = (a.details && a.details.personalstats && a.details.personalstats.attackhits) || 1;
                        const bCrit = (b.details && b.details.personalstats && b.details.personalstats.attackcriticalhits) || 0;
                        const bTotal = (b.details && b.details.personalstats && b.details.personalstats.attackhits) || 1;
                        aVal = aCrit / aTotal;
                        bVal = bCrit / bTotal;
                        break;
                    case 'rw_hits':
                        aVal = (a.details && a.details.personalstats && a.details.personalstats.rankedwarhits) || 0;
                        bVal = (b.details && b.details.personalstats && b.details.personalstats.rankedwarhits) || 0;
                        break;
                    case 'xanax':
                        aVal = (a.details && a.details.personalstats && a.details.personalstats.xantaken) || 0;
                        bVal = (b.details && b.details.personalstats && b.details.personalstats.xantaken) || 0;
                        break;
                    case 'vicodin':
                        aVal = (a.details && a.details.personalstats && a.details.personalstats.victaken) || 0;
                        bVal = (b.details && b.details.personalstats && b.details.personalstats.victaken) || 0;
                        break;
                    case 'overdosed':
                        aVal = (a.details && a.details.personalstats && a.details.personalstats.overdosed) || 0;
                        bVal = (b.details && b.details.personalstats && b.details.personalstats.overdosed) || 0;
                        break;
                    case 'refills':
                        aVal = (a.details && a.details.personalstats && (a.details.personalstats.energydrinkused || a.details.personalstats.refills)) || 0;
                        bVal = (b.details && b.details.personalstats && (b.details.personalstats.energydrinkused || b.details.personalstats.refills)) || 0;
                        break;
                    case 'location':
                        const aStatus = (a.details && a.details.status) || {};
                        const bStatus = (b.details && b.details.status) || {};
                        aVal = (aStatus.description || aStatus.state || 'Unknown').toLowerCase();
                        bVal = (bStatus.description || bStatus.state || 'Unknown').toLowerCase();
                        break;
                    case 'status':
                        aVal = a.last_action.status;
                        bVal = b.last_action.status;
                        break;
                    case 'position':
                        aVal = a.position;
                        bVal = b.position;
                        break;
                    default:
                        return 0;
                }

                if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;
                if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;
                return 0;
            });

            renderMembersTable(filtered);
        }

        // Column definitions for War Planning table
        const warPlanningColumnDefs = {
            name: { label: 'Name / 24h Activity', sortKey: 'name' },
            est_stats: { label: 'Est. Stats', sortKey: 'est_stats' },
            level: { label: 'Level', sortKey: 'level' },
            age: { label: 'Age (days)', sortKey: 'age' },
            life: { label: 'Life', sortKey: 'life' },
            elo: { label: 'ELO', sortKey: 'elo' },
            best_damage: { label: 'Best DMG', sortKey: 'best_damage' },
            critical_hits: { label: 'Crit %', sortKey: 'critical_hits' },
            rw_hits: { label: 'RW Hits', sortKey: 'rw_hits' },
            xanax: { label: 'Xanax', sortKey: 'xanax' },
            vicodin: { label: 'Vicodin', sortKey: 'vicodin' },
            overdosed: { label: 'OD', sortKey: 'overdosed' },
            refills: { label: 'Refills', sortKey: 'refills' },
            location: { label: 'Location', sortKey: 'location' }
        };

        // Get cell content for a specific column
        function getWarPlanningCellContent(column, member, memberData) {
            switch (column) {
                case 'name':
                    return `<td>
                        <div class="member-name-cell">
                            <div class="member-name-row">
                                <span class="status-indicator ${memberData.statusIndicatorClass}"></span>
                                <a href="https://www.torn.com/profiles.php?XID=${member.id}" target="_blank">
                                    ${member.name}
                                </a>
                            </div>
                            ${generateActivityGrid(member.id)}
                        </div>
                    </td>`;
                case 'est_stats':
                    return `<td class="est-stats">
                        <span class="est-stats-value">${formatStatNumber(memberData.estStats.mid)}</span>
                        <br><span style="font-size:10px;color:#999;">${formatStatNumber(memberData.estStats.low)} - ${formatStatNumber(memberData.estStats.high)}</span>
                    </td>`;
                case 'level':
                    return `<td><span class="level-badge">${member.level || 'N/A'}</span></td>`;
                case 'age':
                    return `<td>${memberData.age}</td>`;
                case 'life':
                    return `<td>${memberData.life}</td>`;
                case 'elo':
                    return `<td>${memberData.elo}</td>`;
                case 'best_damage':
                    return `<td>${typeof memberData.bestDamage === 'number' ? memberData.bestDamage.toLocaleString() : memberData.bestDamage}</td>`;
                case 'critical_hits':
                    return `<td>${memberData.criticalPct}%</td>`;
                case 'rw_hits':
                    return `<td>${typeof memberData.rwHits === 'number' ? memberData.rwHits.toLocaleString() : memberData.rwHits}</td>`;
                case 'xanax':
                    return `<td>${typeof memberData.xanax === 'number' ? memberData.xanax.toLocaleString() : memberData.xanax}</td>`;
                case 'vicodin':
                    return `<td>${typeof memberData.vicodin === 'number' ? memberData.vicodin.toLocaleString() : memberData.vicodin}</td>`;
                case 'overdosed':
                    return `<td>${typeof memberData.overdosed === 'number' ? memberData.overdosed.toLocaleString() : memberData.overdosed}</td>`;
                case 'refills':
                    return `<td>${typeof memberData.refills === 'number' ? memberData.refills.toLocaleString() : memberData.refills}</td>`;
                case 'location':
                    return `<td class="${memberData.locationClass}">${memberData.locationText}</td>`;
                default:
                    return '<td>-</td>';
            }
        }

        function renderMembersTable(members) {
            const container = document.getElementById('membersTableContainer');

            const getSortClass = (column) => {
                if (sortColumn !== column) return 'sortable';
                return sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc';
            };

            // Generate header row based on column order with resize handles
            const headerCells = warPlanningColumnOrder.map((col, index) => {
                const def = warPlanningColumnDefs[col];
                const width = wpColumnWidths[col] || defaultWPColumnWidths[col];
                const isLast = index === warPlanningColumnOrder.length - 1;
                const resizeHandle = isLast ? '' : `<span class="wp-resize-handle" onmousedown="startWPColumnResize(event, '${col}')"></span>`;
                return `<th class="${getSortClass(def.sortKey)}"
                    onclick="sortMembers('${def.sortKey}')"
                    draggable="true"
                    data-column="${col}"
                    style="width: ${width}px; min-width: ${width}px;">${def.label}${resizeHandle}</th>`;
            }).join('');

            // Generate body rows
            const bodyRows = members.map(member => {
                const stats = member.details.personalstats || {};
                const profile = member.details || member;

                // Pre-calculate all member data
                const memberData = {
                    age: profile.age || 'N/A',
                    life: profile.life ? `${profile.life.current}/${profile.life.maximum}` : 'N/A',
                    elo: stats.elo || stats.rankedwarrating || 'N/A',
                    bestDamage: stats.bestdamage || stats.highestbeaten || 'N/A',
                    criticalPct: (stats.attackhits || 0) > 0 ? (((stats.attackcriticalhits || 0) / stats.attackhits) * 100).toFixed(2) : '0.00',
                    rwHits: stats.rankedwarhits || 'N/A',
                    xanax: stats.xantaken || 'N/A',
                    vicodin: stats.victaken || 'N/A',
                    overdosed: stats.overdosed || 'N/A',
                    refills: stats.energydrinkused || stats.refills || 'N/A',
                    estStats: estimateBattleStats(member),
                    statusIndicatorClass: member.last_action.status === 'Online' ? 'online' :
                                         member.last_action.status === 'Idle' ? 'idle' : 'offline',
                    locationText: 'Unknown',
                    locationClass: ''
                };

                // Get location/status information
                const userStatus = profile.status || {};
                if (userStatus.description) {
                    memberData.locationText = userStatus.description;
                } else if (userStatus.state) {
                    memberData.locationText = userStatus.state;
                }

                // Format travel status to be shorter
                const flyingToMatch = memberData.locationText.match(/Flying to (.+)/i);
                const returningMatch = memberData.locationText.match(/Returning to (.+)/i);
                const travelingToMatch = memberData.locationText.match(/Traveling to (.+)/i);
                const inCountryMatch = memberData.locationText.match(/In (.+)/i);

                if (flyingToMatch) {
                    memberData.locationText = 'Outbound: ' + flyingToMatch[1];
                } else if (travelingToMatch) {
                    memberData.locationText = 'Outbound: ' + travelingToMatch[1];
                } else if (returningMatch) {
                    memberData.locationText = 'Inbound: ' + returningMatch[1];
                } else if (inCountryMatch && !memberData.locationText.toLowerCase().includes('hospital') && !memberData.locationText.toLowerCase().includes('jail')) {
                    memberData.locationText = 'Abroad: ' + inCountryMatch[1];
                }

                // Add color coding for different states
                if (memberData.locationText.toLowerCase().includes('okay') || memberData.locationText.toLowerCase().includes('torn')) {
                    memberData.locationClass = 'status-online';
                } else if (memberData.locationText.toLowerCase().includes('hospital') || memberData.locationText.toLowerCase().includes('jail')) {
                    memberData.locationClass = 'status-offline';
                } else if (memberData.locationText.toLowerCase().includes('outbound') || memberData.locationText.toLowerCase().includes('inbound') || memberData.locationText.toLowerCase().includes('abroad')) {
                    memberData.locationClass = 'status-idle';
                }

                // Generate cells in column order
                const cells = warPlanningColumnOrder.map(col => getWarPlanningCellContent(col, member, memberData)).join('');

                return `<tr>${cells}</tr>`;
            }).join('');

            container.innerHTML = `
                <table class="members-table">
                    <thead>
                        <tr>${headerCells}</tr>
                    </thead>
                    <tbody>
                        ${bodyRows}
                    </tbody>
                </table>
            `;

            // Add drag event listeners to header cells
            const headerRow = container.querySelector('thead tr');
            if (headerRow) {
                headerRow.addEventListener('dragstart', handleWarPlanningDragStart);
                headerRow.addEventListener('dragover', handleWarPlanningDragOver);
                headerRow.addEventListener('dragleave', handleWarPlanningDragLeave);
                headerRow.addEventListener('drop', handleWarPlanningDrop);
                headerRow.addEventListener('dragend', handleWarPlanningDragEnd);
            }

            // Apply stored column widths to body cells
            applyWPColumnWidths();
        }

        function formatLastAction(relative) {
            return relative || 'Unknown';
        }

        function formatTime(date) {
            if (!date) return 'Never';
            return date.toLocaleTimeString();
        }

        function getLeaderName() {
            if (!factionData || !factionData.leader) return 'N/A';
            // Look up leader name from members data
            if (factionData.members && factionData.members[factionData.leader]) {
                return factionData.members[factionData.leader].name;
            }
            // Fallback: check membersData array
            const leaderMember = membersData.find(m => m.id == factionData.leader);
            if (leaderMember) {
                return leaderMember.name;
            }
            return 'N/A';
        }

        function switchTab(tabId) {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabId).classList.add('active');

            // Save active tab to localStorage
            localStorage.setItem('tornActiveTab', tabId);
        }

        // Restore active tab from localStorage
        function restoreActiveTab() {
            const savedTab = localStorage.getItem('tornActiveTab');
            if (savedTab) {
                const tabContent = document.getElementById(savedTab);
                const tabButton = document.querySelector(`.tab-button[onclick*="${savedTab}"]`);
                if (tabContent && tabButton) {
                    // Deactivate all tabs
                    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    // Activate saved tab
                    tabButton.classList.add('active');
                    tabContent.classList.add('active');
                }
            }
        }

        // Sort portal members
        function sortPortalMembers(column, isEnemy) {
            if (isEnemy) {
                if (enemyPortalSortColumn === column) {
                    enemyPortalSortDirection = enemyPortalSortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    enemyPortalSortColumn = column;
                    enemyPortalSortDirection = 'asc';
                }
            } else {
                if (ownPortalSortColumn === column) {
                    ownPortalSortDirection = ownPortalSortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    ownPortalSortColumn = column;
                    ownPortalSortDirection = 'asc';
                }
            }
            renderWarPortal();
        }

        // Get sorted members for portal
        function getSortedPortalMembers(members, sortCol, sortDir) {
            return [...members].sort((a, b) => {
                let aVal, bVal;

                switch(sortCol) {
                    case 'name':
                        aVal = a.name?.toLowerCase() || '';
                        bVal = b.name?.toLowerCase() || '';
                        break;
                    case 'level':
                        aVal = a.level || 0;
                        bVal = b.level || 0;
                        break;
                    case 'str':
                        aVal = getBattleStats(a).strength || 0;
                        bVal = getBattleStats(b).strength || 0;
                        break;
                    case 'def':
                        aVal = getBattleStats(a).defense || 0;
                        bVal = getBattleStats(b).defense || 0;
                        break;
                    case 'spd':
                        aVal = getBattleStats(a).speed || 0;
                        bVal = getBattleStats(b).speed || 0;
                        break;
                    case 'dex':
                        aVal = getBattleStats(a).dexterity || 0;
                        bVal = getBattleStats(b).dexterity || 0;
                        break;
                    case 'life':
                        const aLife = a.details?.life;
                        const bLife = b.details?.life;
                        aVal = aLife ? aLife.current / aLife.maximum : 0;
                        bVal = bLife ? bLife.current / bLife.maximum : 0;
                        break;
                    case 'status':
                        aVal = getMemberStatusText(a);
                        bVal = getMemberStatusText(b);
                        break;
                    case 'timer':
                        // Sort by hospital end time - players coming out first should be at top when ascending
                        // Players not in hospital get a very high value so they sort to bottom
                        const aInfo = getMemberStatusInfo(a);
                        const bInfo = getMemberStatusInfo(b);
                        aVal = aInfo.hospitalEndTime || Number.MAX_SAFE_INTEGER;
                        bVal = bInfo.hospitalEndTime || Number.MAX_SAFE_INTEGER;
                        break;
                    default:
                        aVal = a.name?.toLowerCase() || '';
                        bVal = b.name?.toLowerCase() || '';
                }

                if (aVal < bVal) return sortDir === 'asc' ? -1 : 1;
                if (aVal > bVal) return sortDir === 'asc' ? 1 : -1;
                return 0;
            });
        }

        // Get member status text for sorting/display
        function getMemberStatusText(member) {
            const profile = member.details || member;
            const userStatus = profile.status || {};
            let statusText = userStatus.description || userStatus.state || 'OK';
            return statusText;
        }

        // Get member status info for display
        function getMemberStatusInfo(member) {
            const profile = member.details || member;
            const userStatus = profile.status || {};
            let statusText = userStatus.description || userStatus.state || 'OK';
            let statusClass = 'status-ok';
            let hospitalEndTime = null;

            if (statusText.toLowerCase().includes('hospital')) {
                statusClass = 'status-hospital';
                statusText = 'HOSPITAL'; // Show just "HOSPITAL" - timer goes in separate column
                // Extract hospital time from status
                if (userStatus.until) {
                    hospitalEndTime = userStatus.until * 1000; // Convert to milliseconds
                    hospitalTimers[member.id] = hospitalEndTime;
                }
            } else if (statusText.toLowerCase().includes('jail')) {
                statusClass = 'status-jail';
                statusText = 'Jail';
            } else if (statusText.toLowerCase().includes('travel') ||
                       statusText.toLowerCase().includes('flying') ||
                       statusText.toLowerCase().includes('returning')) {
                statusClass = 'status-traveling';
                // Shorten travel text - match war planning tab format
                const flyingMatch = statusText.match(/Flying to (.+)/i);
                const travelingToMatch = statusText.match(/Traveling to (.+)/i);
                const returningMatch = statusText.match(/Returning to (.+)/i);
                if (flyingMatch) {
                    statusText = 'Outbound: ' + flyingMatch[1];
                } else if (travelingToMatch) {
                    statusText = 'Outbound: ' + travelingToMatch[1];
                } else if (returningMatch) {
                    statusText = 'Inbound: ' + returningMatch[1];
                }
            } else {
                // Check for being abroad (In [country]) - but not hospital/jail
                const inCountryMatch = statusText.match(/In (.+)/i);
                if (inCountryMatch && !statusText.toLowerCase().includes('hospital') && !statusText.toLowerCase().includes('jail')) {
                    statusClass = 'status-traveling';
                    statusText = 'Abroad: ' + inCountryMatch[1];
                } else if (statusText.toLowerCase().includes('okay') || statusText === 'OK' || statusText.toLowerCase().includes('torn')) {
                    statusText = 'OK';
                    statusClass = 'status-ok';
                }
            }

            return { statusText, statusClass, hospitalEndTime };
        }

        // Format hospital timer as HH:MM:SS
        function formatHospitalTimer(endTime) {
            const now = Date.now();
            const remaining = endTime - now;

            if (remaining <= 0) {
                return 'OK';
            }

            const hours = Math.floor(remaining / (1000 * 60 * 60));
            const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((remaining % (1000 * 60)) / 1000);

            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Update all hospital timers on the page
        function updateHospitalTimers() {
            const timerElements = document.querySelectorAll('.hospital-timer[data-end-time]');
            timerElements.forEach(el => {
                const endTime = parseInt(el.dataset.endTime);
                if (endTime) {
                    const formatted = formatHospitalTimer(endTime);
                    el.textContent = formatted;
                    if (formatted === 'OK') {
                        // Timer expired - update the timer column and status column
                        const parentTimer = el.closest('.portal-member-timer');
                        if (parentTimer) {
                            parentTimer.classList.remove('has-timer');
                            parentTimer.innerHTML = '-';
                        }
                        // Also update the status column in the same row
                        const row = el.closest('.portal-member-row');
                        if (row) {
                            const statusCell = row.querySelector('.portal-member-status');
                            if (statusCell) {
                                statusCell.classList.remove('status-hospital');
                                statusCell.classList.add('status-ok');
                                statusCell.textContent = 'OK';
                            }
                        }
                    }
                }
            });
        }

        // Start hospital timer interval
        function startHospitalTimerInterval() {
            if (hospitalTimerInterval) {
                clearInterval(hospitalTimerInterval);
            }
            hospitalTimerInterval = setInterval(updateHospitalTimers, 1000);
        }

        // Get cell content for portal member row
        // Helper to format individual stat cell
        function formatStatCell(statValue, isReal, daysAgo) {
            if (statValue === null || statValue === undefined) {
                return `<span class="est-value">-</span>`;
            }
            if (isReal) {
                const ageInfo = daysAgo !== null ? ` (${daysAgo}d ago)` : '';
                return `<span class="real-value" title="Spied from TornStats${ageInfo}">${formatStatNumber(statValue)}</span>`;
            } else {
                return `<span class="est-value">${formatStatNumber(statValue)}</span>`;
            }
        }

        function getPortalCellContent(column, member, memberData) {
            const stats = memberData.estStats;
            switch (column) {
                case 'name':
                    return `<div class="portal-member-name" data-column="name">
                        <span class="status-indicator ${memberData.statusClass}"></span>
                        <a href="https://www.torn.com/profiles.php?XID=${member.id}" target="_blank">${member.name}</a>
                    </div>`;
                case 'level':
                    return `<div class="portal-member-level" data-column="level">
                        <span class="level-badge">Lv ${member.level || 'N/A'}</span>
                    </div>`;
                case 'str':
                    return `<div class="portal-member-stats" data-column="str">${formatStatCell(stats.strength, stats.isReal, stats.daysAgo)}</div>`;
                case 'def':
                    return `<div class="portal-member-stats" data-column="def">${formatStatCell(stats.defense, stats.isReal, stats.daysAgo)}</div>`;
                case 'spd':
                    return `<div class="portal-member-stats" data-column="spd">${formatStatCell(stats.speed, stats.isReal, stats.daysAgo)}</div>`;
                case 'dex':
                    return `<div class="portal-member-stats" data-column="dex">${formatStatCell(stats.dexterity, stats.isReal, stats.daysAgo)}</div>`;
                case 'life':
                    return `<div class="portal-member-life ${memberData.lifeClass}" data-column="life">${memberData.life}</div>`;
                case 'status':
                    return `<div class="portal-member-status ${memberData.statusInfo.statusClass}" data-column="status">${memberData.statusInfo.statusText}</div>`;
                case 'timer':
                    return `<div class="portal-member-timer ${memberData.timerClass}" data-column="timer">${memberData.timerDisplay}</div>`;
                default:
                    return `<div data-column="${column}">-</div>`;
            }
        }

        function renderMemberRow(member, isEnemy = false) {
            const statusClass = member.last_action?.status === 'Online' ? 'online' :
                              member.last_action?.status === 'Idle' ? 'idle' : 'offline';

            const profile = member.details || member;
            const life = profile.life ? `${profile.life.current}/${profile.life.maximum}` : 'N/A';
            const lifeClass = profile.life && profile.life.current === profile.life.maximum ? 'full' : 'injured';
            const estStats = getBattleStats(member);

            // Get status info (hospital/traveling/ok)
            const statusInfo = getMemberStatusInfo(member);

            // Timer column - show countdown if in hospital, otherwise empty
            let timerDisplay = '-';
            let timerClass = '';
            if (statusInfo.hospitalEndTime) {
                const timerValue = formatHospitalTimer(statusInfo.hospitalEndTime);
                timerDisplay = `<span class="hospital-timer" data-end-time="${statusInfo.hospitalEndTime}">${timerValue}</span>`;
                timerClass = 'has-timer';
            }

            // Prepare member data for cell rendering
            const memberData = {
                statusClass,
                life,
                lifeClass,
                estStats,
                statusInfo,
                timerDisplay,
                timerClass
            };

            // Get the appropriate column order
            const columnOrder = isEnemy ? enemyPortalColumnOrder : ownPortalColumnOrder;

            // Generate cells in column order
            const cells = columnOrder.map(col => getPortalCellContent(col, member, memberData)).join('');

            return `<div class="portal-member-row">${cells}</div>`;
        }

        function renderWarPortal() {
            const container = document.getElementById('warPortalContainer');
            if (!container) return;

            // Get saved enemy faction ID
            const savedEnemyId = localStorage.getItem('tornEnemyFactionId') || '';

            // Get own faction info - use userFactionData if available, otherwise fall back to factionData
            const ownFaction = userFactionData || factionData;
            const ownMembers = userMembersData.length > 0 ? userMembersData : membersData;
            const ownFactionName = ownFaction ? (ownFaction.name || 'Your Faction') : 'Your Faction';
            const ownFactionTag = ownFaction ? (ownFaction.tag || '') : '';
            const ownMemberCount = ownMembers.length;

            // Get enemy faction info
            const enemyFactionName = enemyFactionData ? (enemyFactionData.name || 'Enemy Faction') : 'Enemy Faction';
            const enemyFactionTag = enemyFactionData ? (enemyFactionData.tag || '') : '';
            const enemyMemberCount = enemyMembersData.length;

            // Sort members
            const sortedOwnMembers = getSortedPortalMembers(ownMembers, ownPortalSortColumn, ownPortalSortDirection);
            const sortedEnemyMembers = getSortedPortalMembers(enemyMembersData, enemyPortalSortColumn, enemyPortalSortDirection);

            // Helper to get sort class
            const getOwnSortClass = (col) => ownPortalSortColumn === col ? (ownPortalSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc') : '';
            const getEnemySortClass = (col) => enemyPortalSortColumn === col ? (enemyPortalSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc') : '';

            // Helper to generate column with resize handle and drag support
            const colWithResize = (colName, sortClass, label, isEnemy) => {
                const widths = isEnemy ? enemyColumnWidths : ownColumnWidths;
                const width = widths[colName] || defaultColumnWidths[colName] || 65;
                const resizeHandle = `<span class="col-resize-handle" onmousedown="startColumnResize(event, '${colName}', ${isEnemy})"></span>`;
                // Map stat columns to use portal-member-stats class
                const statCols = ['str', 'def', 'spd', 'dex'];
                const className = statCols.includes(colName) ? 'stats' : colName;
                return `<div class="portal-member-${className} ${sortClass}"
                    onclick="sortPortalMembers('${colName}', ${isEnemy})"
                    draggable="true"
                    data-column="${colName}"
                    style="width: ${width}px; min-width: ${width}px; flex-shrink: 0;">${label}${resizeHandle}</div>`;
            };

            // Generate headers based on column order
            const generateHeaders = (columnOrder, getSortClass, isEnemy) => {
                return columnOrder.map((col) => {
                    const def = portalColumnDefs[col];
                    return colWithResize(col, getSortClass(col), def.label, isEnemy);
                }).join('');
            };

            // Column headers HTML with resize handles and drag support
            const ownHeadersHtml = `
                <div class="portal-header-row" id="ownPortalHeaderRow">
                    ${generateHeaders(ownPortalColumnOrder, getOwnSortClass, false)}
                </div>
            `;

            const enemyHeadersHtml = `
                <div class="portal-header-row" id="enemyPortalHeaderRow">
                    ${generateHeaders(enemyPortalColumnOrder, getEnemySortClass, true)}
                </div>
            `;

            // Stats color legend
            const statsLegend = `<div class="stats-legend">
                <span class="legend-item"><span class="legend-color" style="background:#28a745;"></span> Spied (TornStats)</span>
                <span class="legend-item"><span class="legend-color" style="background:#667eea;"></span> Estimated</span>
            </div>`;

            container.innerHTML = `
                <div class="war-portal-container">
                    <!-- Your Faction Column -->
                    <div class="faction-column">
                        <div class="faction-input-panel" style="border-radius: 8px 8px 0 0; border: 1px solid #ddd;">
                            <button class="btn" id="ownForceUpdateBtn" onclick="forceUpdateOwnTornStats()" title="Scan all members and refresh TornStats spy data">Force Update</button>
                        </div>
                        <div class="faction-header">
                            <h3>${ownFactionTag ? '[' + ownFactionTag + '] ' : ''}${ownFactionName}</h3>
                            <div class="faction-header-info">${ownMemberCount} Members</div>
                            ${statsLegend}
                        </div>
                        <div class="faction-members-list" id="ownMembersList">
                            ${ownHeadersHtml}
                            ${sortedOwnMembers.length > 0
                                ? sortedOwnMembers.map(member => renderMemberRow(member, false)).join('')
                                : '<div class="portal-no-data">Loading your faction data...</div>'
                            }
                        </div>
                    </div>

                    <!-- Enemy Faction Column -->
                    <div class="faction-column">
                        <div class="faction-input-panel" style="border-radius: 8px 8px 0 0; border: 1px solid #ddd;">
                            <input type="text" id="portalEnemyFactionId" placeholder="Enemy Faction ID" value="${savedEnemyId}" onkeypress="if(event.key==='Enter') loadEnemyFaction()">
                            <button class="btn" onclick="loadEnemyFaction()">Load</button>
                            <button class="btn" onclick="findEnemyForPortal()" style="background: #dc3545;">Find Enemy</button>
                            <button class="btn" id="enemyForceUpdateBtn" onclick="forceUpdateEnemyTornStats()" title="Scan all enemy members and refresh TornStats spy data">Force Update</button>
                        </div>
                        <div class="faction-header enemy" style="border-radius: 0;">
                            <h3>${enemyFactionTag ? '[' + enemyFactionTag + '] ' : ''}${enemyFactionName}</h3>
                            <div class="faction-header-info">${enemyMemberCount > 0 ? enemyMemberCount + ' Members' : 'Not loaded'}</div>
                            ${statsLegend}
                        </div>
                        <div class="faction-members-list" id="enemyMembersList">
                            ${enemyHeadersHtml}
                            ${sortedEnemyMembers.length > 0
                                ? sortedEnemyMembers.map(member => renderMemberRow(member, true)).join('')
                                : '<div class="portal-no-data">Enter enemy faction ID and click Load, or click Find Enemy</div>'
                            }
                        </div>
                    </div>
                </div>
            `;

            // Start the hospital timer interval
            startHospitalTimerInterval();

            // Apply stored column widths to member rows
            applyColumnWidths(false); // Own faction
            applyColumnWidths(true);  // Enemy faction

            // Add drag event listeners for own faction header
            const ownHeaderRow = document.getElementById('ownPortalHeaderRow');
            if (ownHeaderRow) {
                ownHeaderRow.addEventListener('dragstart', (e) => handlePortalDragStart(e, false));
                ownHeaderRow.addEventListener('dragover', (e) => handlePortalDragOver(e, false));
                ownHeaderRow.addEventListener('dragleave', handlePortalDragLeave);
                ownHeaderRow.addEventListener('drop', (e) => handlePortalDrop(e, false));
                ownHeaderRow.addEventListener('dragend', handlePortalDragEnd);
            }

            // Add drag event listeners for enemy faction header
            const enemyHeaderRow = document.getElementById('enemyPortalHeaderRow');
            if (enemyHeaderRow) {
                enemyHeaderRow.addEventListener('dragstart', (e) => handlePortalDragStart(e, true));
                enemyHeaderRow.addEventListener('dragover', (e) => handlePortalDragOver(e, true));
                enemyHeaderRow.addEventListener('dragleave', handlePortalDragLeave);
                enemyHeaderRow.addEventListener('drop', (e) => handlePortalDrop(e, true));
                enemyHeaderRow.addEventListener('dragend', handlePortalDragEnd);
            }
        }

        function filterPortalMembers() {
            // Filtering removed as the new layout doesn't use search/filter
            renderWarPortal();
        }
    </script>
</body>
</html>
