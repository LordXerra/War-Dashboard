<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torn Ranked War Dashboard by Xerra [2775419] with thanks to NestFreemark [2863072] and Pickaxe1977 [2935003]</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 10px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        .header {
            background: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 15px;
        }

        .header h1 {
            color: #333;
            margin-bottom: 10px;
        }

        .api-input-group {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
            align-items: flex-end;
        }

        .input-with-label {
            display: flex;
            flex-direction: column;
            gap: 3px;
        }

        .input-with-label label {
            font-size: 11px;
            font-weight: 600;
            color: #555;
        }

        .api-input-group input {
            width: 180px;
            padding: 6px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-size: 12px;
        }

        .api-input-group input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            padding: 8px 20px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: background 0.3s;
        }

        .btn:hover {
            background: #5568d3;
        }

        .btn-blue {
            background: #1565c0;
        }

        .btn-blue:hover {
            background: #0d47a1;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .info-text {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        .info-text ul {
            list-style-type: disc;
        }

        .warning-box {
            background: #fff3cd;
            border: 1px solid #ffc107;
            color: #856404;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 12px;
        }

        .warning-box strong {
            color: #856404;
        }

        .loading {
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        @keyframes flash {
            0%, 100% { opacity: 1; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
            50% { opacity: 0.7; background: linear-gradient(135deg, #8b9cf7 0%, #9b6fc4 100%); }
        }

        .manual-link {
            display: inline-block;
            padding: 8px 16px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white !important;
            text-decoration: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            animation: flash 1.5s ease-in-out infinite;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.4);
            transition: transform 0.2s, box-shadow 0.2s;
        }

        .manual-link:hover {
            animation: none;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.6);
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            border-left: 4px solid #c33;
        }

        .faction-info {
            background: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 15px;
        }

        .faction-info h2 {
            color: #333;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid #667eea;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-top: 10px;
        }

        .info-item {
            padding: 8px 12px;
            background: #f8f9fa;
            border-radius: 5px;
        }

        .info-item label {
            display: block;
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
            text-transform: uppercase;
            font-weight: 600;
        }

        .info-item value {
            display: block;
            font-size: 20px;
            color: #333;
            font-weight: 600;
        }

        .members-section {
            background: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .members-section h2 {
            color: #333;
            margin-bottom: 10px;
            padding-bottom: 5px;
            border-bottom: 2px solid #667eea;
        }

        .refresh-info {
            font-size: 12px;
            color: #666;
            margin-bottom: 15px;
            font-style: italic;
        }

        .filters {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .filters input,
        .filters select {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .filters input {
            flex: 1;
            min-width: 200px;
        }

        .members-table {
            width: 100%;
            border-collapse: collapse;
            overflow-x: auto;
            display: block;
            font-size: 13px;
        }

        .members-table-wrapper {
            overflow-x: auto;
            width: 100%;
        }

        .members-table thead {
            background: #667eea;
            color: white;
        }

        .members-table th {
            padding: 10px 8px;
            text-align: left;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            white-space: nowrap;
            font-size: 12px;
            position: relative;
            border-right: 1px solid rgba(255,255,255,0.3);
        }

        .members-table th:last-child {
            border-right: none;
        }

        .members-table th:hover {
            background: #5568d3;
        }

        /* Column resize handle for war planning table */
        .members-table th .wp-resize-handle {
            position: absolute;
            right: -3px;
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: col-resize;
            z-index: 20;
            background: transparent;
        }

        .members-table th .wp-resize-handle:hover,
        .members-table th .wp-resize-handle.resizing {
            background: rgba(255, 193, 7, 0.7);
        }

        .members-table th.sortable::after {
            content: ' ‚áÖ';
            opacity: 0.5;
        }

        .members-table th.sorted-asc::after {
            content: ' ‚Üë';
            opacity: 1;
        }

        .members-table th.sorted-desc::after {
            content: ' ‚Üì';
            opacity: 1;
        }

        /* Draggable column styles */
        .members-table th[draggable="true"] {
            cursor: grab;
        }

        .members-table th[draggable="true"]:active {
            cursor: grabbing;
        }

        .members-table th.dragging {
            opacity: 0.5;
            background: #4455bb;
        }

        .members-table th.drag-over-left {
            border-left: 3px solid #ffc107;
        }

        .members-table th.drag-over-right {
            border-right: 3px solid #ffc107;
        }

        .members-table td {
            padding: 8px;
            border-bottom: 1px solid #ddd;
            border-right: 1px solid #eee;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .members-table td:last-child {
            border-right: none;
        }

        .members-table tbody tr:hover {
            background: #f8f9fa;
        }

        .status-online {
            color: #28a745;
            font-weight: 600;
        }

        .status-offline {
            color: #dc3545;
            font-weight: 600;
        }

        .status-idle {
            color: #ffc107;
            font-weight: 600;
        }

        .status-indicator {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 2px;
            margin-right: 8px;
        }

        .status-indicator.online {
            background-color: #28a745;
        }

        .status-indicator.offline {
            background-color: #dc3545;
        }

        .status-indicator.idle {
            background-color: #ffc107;
        }

        .level-badge {
            background: #667eea;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 12px;
            font-weight: 600;
        }

        .position-badge {
            background: #764ba2;
            color: white;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 11px;
        }

        .stats-summary {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
        }

        .stat-card h3 {
            font-size: 14px;
            margin-bottom: 10px;
            opacity: 0.9;
        }

        .stat-card .value {
            font-size: 28px;
            font-weight: 700;
        }

        @media (max-width: 768px) {
            .members-table {
                font-size: 12px;
            }

            .members-table th,
            .members-table td {
                padding: 8px;
            }
        }

        /* Tab Styles */
        .tabs-container {
            margin-bottom: 20px;
        }

        .tab-buttons {
            display: flex;
            gap: 0;
            border-bottom: 2px solid #667eea;
        }

        .tab-button {
            padding: 12px 24px;
            background: #f8f9fa;
            border: none;
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            color: #666;
            transition: all 0.3s;
            margin-right: 4px;
        }

        .tab-button:hover {
            background: #e9ecef;
            color: #333;
        }

        .tab-button.active {
            background: #667eea;
            color: white;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* War Status Banner */
        .war-status-banner {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 10px;
            padding: 15px 20px;
            margin-bottom: 15px;
            color: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .war-status-header {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            margin-bottom: 12px;
            font-size: 18px;
            font-weight: bold;
        }

        .war-status-header .faction-name {
            max-width: 200px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .war-status-header .faction-name.own {
            color: #90EE90;
        }

        .war-status-header .faction-name.enemy {
            color: #ffb3b3;
        }

        .war-status-header .vs-text {
            color: #888;
            font-size: 14px;
        }

        .war-status-scores {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }

        .war-score-box {
            flex: 0 0 auto;
            text-align: center;
            min-width: 100px;
        }

        .war-score-box .score {
            font-size: 36px;
            font-weight: bold;
            line-height: 1;
        }

        .war-score-box .ok-count {
            font-size: 12px;
            margin-top: 5px;
            opacity: 0.9;
        }

        .war-score-box.winning .score {
            color: #90EE90;
        }

        .war-score-box.losing .score {
            color: #ffb3b3;
        }

        .war-lead-target {
            flex: 1;
            text-align: center;
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .war-lead-target .label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #aaa;
            margin-bottom: 5px;
        }

        .war-lead-target .target-info {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .war-lead-target .progress-bar {
            height: 8px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .war-lead-target .progress-bar .own-progress {
            position: absolute;
            left: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            transition: width 0.3s ease;
        }

        .war-lead-target .progress-bar .enemy-progress {
            position: absolute;
            right: 0;
            top: 0;
            height: 100%;
            background: linear-gradient(90deg, #a71d2a, #dc3545);
            transition: width 0.3s ease;
        }

        .war-lead-target .war-timer {
            font-size: 16px;
            font-weight: bold;
            margin-top: 8px;
            color: #ffc107;
        }

        /* War Portal Two-Faction Layout */
        .war-portal-container {
            display: flex;
            gap: 10px;
        }

        .faction-column {
            flex: 1;
            min-width: 0;
        }

        .faction-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 10px 15px;
            border-radius: 8px 8px 0 0;
            margin-bottom: 0;
        }

        .faction-header.enemy {
            background: linear-gradient(135deg, #dc3545 0%, #a71d2a 100%);
        }

        .faction-header h3 {
            margin: 0 0 5px 0;
            font-size: 18px;
        }

        .faction-header-info {
            font-size: 12px;
            opacity: 0.9;
        }

        .faction-input-panel {
            background: #f8f9fa;
            padding: 6px 10px;
            border: 1px solid #ddd;
            border-top: none;
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .faction-input-panel input {
            flex: 1;
            padding: 5px 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 12px;
        }

        .faction-input-panel .btn {
            padding: 5px 12px;
            font-size: 12px;
        }

        .faction-members-list {
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 600px;
            overflow-y: auto;
        }

        .portal-member-row {
            display: flex;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid #eee;
        }

        .portal-member-row:last-child {
            border-bottom: none;
        }

        .portal-member-row:hover {
            background: #f8f9fa;
        }

        .portal-member-name {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 10px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            border-right: 1px solid #ddd;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .portal-member-name a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .portal-member-name a:hover {
            text-decoration: underline;
        }

        .portal-member-name .attack-skull {
            margin-left: auto;
            text-decoration: none;
            font-size: 14px;
            opacity: 0.7;
            transition: opacity 0.2s, transform 0.2s;
            padding-left: 8px;
            flex-shrink: 0;
        }

        .portal-member-name .attack-skull:hover {
            opacity: 1;
            transform: scale(1.2);
            text-decoration: none;
        }

        .portal-member-stats {
            text-align: center;
            font-size: 12px;
            padding: 0 10px;
            border-right: 1px solid #ddd;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .portal-member-stats .est-value {
            font-weight: 600;
            color: #667eea;
        }

        .portal-member-stats .est-range {
            font-size: 10px;
            color: #999;
        }

        .portal-member-stats .real-value {
            font-weight: 600;
            color: #28a745;
        }

        .portal-member-stats .real-range {
            font-size: 10px;
            color: #28a745;
        }

        /* General styles for real/estimated values in tables */
        td .real-value {
            font-weight: 600;
            color: #28a745;
        }

        td .est-value {
            font-weight: 600;
            color: #667eea;
        }

        .stats-legend {
            display: flex;
            gap: 15px;
            font-size: 11px;
            margin-top: 5px;
            justify-content: center;
        }

        .stats-legend .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .stats-legend .legend-color {
            width: 10px;
            height: 10px;
            border-radius: 2px;
            display: inline-block;
        }

        .portal-member-life {
            text-align: center;
            font-size: 12px;
            padding: 0 10px;
            border-right: 1px solid #ddd;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .portal-member-life.full {
            color: #28a745;
        }

        .portal-member-life.injured {
            color: #dc3545;
        }

        .portal-member-level {
            text-align: center;
            padding: 0 10px;
            border-right: 1px solid #ddd;
            box-sizing: border-box;
            flex-shrink: 0;
        }

        .portal-member-status {
            font-size: 11px;
            padding: 0 10px;
            box-sizing: border-box;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 0;
            border-right: 1px solid #ddd;
        }

        .portal-member-timer {
            font-size: 11px;
            padding: 0 10px;
            box-sizing: border-box;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex-shrink: 0;
            font-family: monospace;
            font-weight: 600;
        }

        .portal-member-timer.has-timer {
            color: #dc3545;
        }

        .portal-no-data {
            padding: 30px;
            text-align: center;
            color: #999;
            font-style: italic;
        }

        .portal-header-row {
            display: flex;
            align-items: center;
            padding: 8px 0;
            background: #f0f0f0;
            border-bottom: 2px solid #ddd;
            font-weight: 600;
            font-size: 12px;
            color: #666;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .portal-header-row > div {
            cursor: grab;
            user-select: none;
            padding: 0 10px;
            border-right: 1px solid #ccc;
            box-sizing: border-box;
            position: relative;
        }

        .portal-header-row > div:active {
            cursor: grabbing;
        }

        .portal-header-row > div:last-child {
            border-right: none;
        }

        .portal-header-row > div:hover {
            color: #667eea;
        }

        .portal-header-row > div.dragging {
            opacity: 0.5;
            background: #d0d0d0;
        }

        .portal-header-row > div.drag-over-left {
            border-left: 3px solid #667eea;
        }

        .portal-header-row > div.drag-over-right {
            border-right: 3px solid #667eea;
        }

        .portal-header-row > div.sorted-asc::after {
            content: ' ‚ñ≤';
            font-size: 10px;
        }

        .portal-header-row > div.sorted-desc::after {
            content: ' ‚ñº';
            font-size: 10px;
        }

        /* Column resize handle */
        .col-resize-handle {
            position: absolute;
            right: -3px;
            top: 0;
            bottom: 0;
            width: 6px;
            cursor: col-resize;
            z-index: 20;
            background: transparent;
        }

        .col-resize-handle:hover,
        .col-resize-handle.resizing {
            background: #667eea;
            opacity: 0.5;
        }

        /* Disable text selection while resizing */
        .resizing-columns {
            user-select: none;
            cursor: col-resize !important;
        }

        .resizing-columns * {
            cursor: col-resize !important;
        }

        .portal-member-status.status-ok {
            color: #28a745;
        }

        .portal-member-status.status-hospital {
            color: #dc3545;
        }

        .portal-member-status.status-traveling {
            color: #ffc107;
        }

        .portal-member-status.status-jail {
            color: #6c757d;
        }

        .hospital-timer {
            font-family: monospace;
            font-weight: 600;
        }

        /* Hourly Activity Grid Styles */
        .activity-grid {
            display: flex;
            gap: 1px;
            margin-top: 4px;
        }

        .hour-box {
            width: 24px;
            height: 16px;
            border-radius: 2px;
            font-size: 9px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            cursor: pointer;
            position: relative;
        }

        .hour-box.online {
            background-color: #28a745;
        }

        .hour-box.partial {
            background-color: #ffc107;
        }

        .hour-box.offline {
            background-color: #dc3545;
        }

        .hour-box.unknown {
            background-color: #6c757d;
        }

        .hour-box:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            z-index: 100;
            margin-bottom: 4px;
        }

        .member-name-cell {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }

        .member-name-row {
            display: flex;
            align-items: center;
            width: 100%;
        }

        .member-name-row .attack-skull {
            margin-left: auto;
            text-decoration: none;
            font-size: 14px;
            opacity: 0.7;
            transition: opacity 0.2s, transform 0.2s;
            padding-left: 8px;
        }

        .member-name-row .attack-skull:hover {
            opacity: 1;
            transform: scale(1.2);
            text-decoration: none;
        }

        /* Estimated Stats Column */
        .est-stats {
            font-size: 12px;
            color: #666;
        }

        .est-stats-value {
            font-weight: 600;
            color: #667eea;
        }

        .real-stats-value {
            font-weight: 600;
            color: #28a745;
        }

        .stats-tooltip {
            font-size: 13px;
            font-weight: 600;
        }

        .stats-tooltip[title] {
            position: relative;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                <h1 style="font-size: 1.4em; margin: 0;">Torn Ranked War Dashboard by <a href="https://www.torn.com/profiles.php?XID=2775419" target="_blank" style="color: #667eea; text-decoration: none;">Xerra [2775419]</a> with thanks to <a href="https://www.torn.com/profiles.php?XID=2863072" target="_blank" style="color: #667eea; text-decoration: none;">NestFreemark [2863072]</a> and <a href="https://www.torn.com/profiles.php?XID=2935003" target="_blank" style="color: #667eea; text-decoration: none;">Pickaxe1977 [2935003]</a></h1>
                <span style="font-size: 12px; color: #666; white-space: nowrap; margin-left: 15px;">V0.20 - 31/01/2026</span>
            </div>
            <div style="margin-bottom: 12px;">
                <a href="manual.html" target="_blank" class="manual-link">üìñ User Manual - Click Here for Help</a>
            </div>
            <div class="api-input-group" style="display: flex; justify-content: space-between; align-items: flex-end;">
                <div style="display: flex; gap: 10px; align-items: flex-end;">
                    <div class="input-with-label">
                        <label for="apiKey">Torn API Key</label>
                        <input
                            type="text"
                            id="apiKey"
                            placeholder="Required"
                            value=""
                            onkeypress="handleEnterKey(event)">
                    </div>
                    <div class="input-with-label">
                        <label for="tornStatsApiKey">TornStats API Key</label>
                        <input
                            type="text"
                            id="tornStatsApiKey"
                            placeholder="Optional"
                            value=""
                            onkeypress="handleEnterKey(event)">
                    </div>
                    <button type="button" class="btn" id="getFactionBtn" onclick="getFaction()" style="background: #28a745;">Get Faction</button>
                </div>
                <div style="display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 10px; color: #888; max-width: 200px;">Clears cached data and settings (API keys preserved)</span>
                    <button type="button" class="btn" onclick="resetAllData()" style="background: #dc3545; white-space: nowrap;" title="Reset all cached data and settings. Your API keys will be preserved.">Reset Data</button>
                </div>
            </div>
            <div class="info-text">
                Your API key is stored locally in your browser and never sent anywhere except to Torn's official API.
                You can get your API key from: <a href="https://www.torn.com/preferences.php#tab=api" target="_blank">Torn Settings ‚Üí API Key</a>
                <br><br>
                <div class="warning-box">
                    <strong>‚ÑπÔ∏è API Key Info:</strong><br>
                    A basic API key is sufficient to view all dashboard information. Create one at <a href="https://www.torn.com/preferences.php#tab=api" target="_blank" style="color: #856404; text-decoration: underline;">Torn Preferences ‚Üí API Key</a>.
                    <br><br>
                    <strong>TornStats Integration:</strong> Add your <a href="https://www.tornstats.com/settings" target="_blank" style="color: #856404; text-decoration: underline;">TornStats API key</a> to see real spied battle stats when available. Stats shown in <span style="color: #28a745; font-weight: bold;">green</span> are real spied stats from TornStats.
                    <br><br>
                    <strong>Note:</strong> Some stats may show as N/A if they haven't been set yet or if the player's privacy settings restrict access. Open the browser console (F12) to see detailed API response information.
                </div>
            </div>
        </div>

        <div id="content"></div>
    </div>

    <script>
        // Current version - update this when releasing new versions that require data reset
        const CURRENT_VERSION = '0.20';

        // Current user data (API key owner)
        let currentUserId = null;

        let factionData = null;
        let membersData = [];
        let enemyFactionData = null;
        let enemyMembersData = [];
        let spyFactionData = null;
        let spyMembersData = [];

        // War scores for the current ranked war
        let currentWarScores = {
            ownScore: null,
            enemyScore: null,
            isActiveWar: false,
            target: null,          // Lead target score needed to win (user-entered, not from API)
            ownName: null,         // Own faction name
            enemyName: null,       // Enemy faction name
            ownChain: null,        // Own faction chain
            enemyChain: null,      // Enemy faction chain
            warStart: null,        // War start timestamp
            warEnd: null           // War end timestamp (when it will end if no more hits)
        };

        // Calculate when the war will end based on target decay
        // Target decays 1% per hour after the first 24 hours
        // War ends when target decays to current lead
        function calculateWarEndTime() {
            if (!currentWarScores.isActiveWar || !currentWarScores.warStart || !currentWarScores.target) {
                return null;
            }

            const now = Math.floor(Date.now() / 1000);
            const warStart = currentWarScores.warStart;
            const hoursElapsed = (now - warStart) / 3600;
            const lead = Math.abs(currentWarScores.ownScore - currentWarScores.enemyScore);
            const originalTarget = currentWarScores.target;

            // If lead already meets or exceeds target, war could end soon
            if (lead >= originalTarget) {
                return now; // Already winning
            }

            // Calculate current target (with decay if past 24 hours)
            let currentTarget = originalTarget;
            if (hoursElapsed > 24) {
                const decayHours = hoursElapsed - 24;
                const decayPercent = Math.min(decayHours, 99);
                currentTarget = originalTarget * (1 - decayPercent / 100);
            }

            // If current lead already meets decayed target
            if (lead >= currentTarget) {
                return now;
            }

            // Calculate how many more hours of decay needed for target to reach current lead
            // After 24 hours: target = original * (1 - (hours_past_24 / 100))
            // We need: lead = original * (1 - (hours_past_24 / 100))
            // So: hours_past_24 = 100 * (1 - lead/original)
            const hoursOfDecayNeeded = 100 * (1 - lead / originalTarget);
            const totalHoursToEnd = 24 + hoursOfDecayNeeded;
            const endTime = warStart + (totalHoursToEnd * 3600);

            return Math.floor(endTime);
        }

        // Save enemy faction data to localStorage
        function saveEnemyFactionData() {
            if (enemyFactionData && enemyMembersData.length > 0) {
                try {
                    localStorage.setItem('tornEnemyFactionData', JSON.stringify(enemyFactionData));
                    localStorage.setItem('tornEnemyMembersData', JSON.stringify(enemyMembersData));
                    console.log('Enemy faction data saved to localStorage');
                } catch (e) {
                    console.warn('Failed to save enemy faction data:', e);
                }
            }
        }

        // Load enemy faction data from localStorage
        function loadEnemyFactionDataFromCache() {
            try {
                const savedFactionData = localStorage.getItem('tornEnemyFactionData');
                const savedMembersData = localStorage.getItem('tornEnemyMembersData');
                if (savedFactionData && savedMembersData) {
                    enemyFactionData = JSON.parse(savedFactionData);
                    enemyMembersData = JSON.parse(savedMembersData);
                    console.log(`Restored enemy faction data: ${enemyFactionData.name} with ${enemyMembersData.length} members`);
                    return true;
                }
            } catch (e) {
                console.warn('Failed to load enemy faction data from cache:', e);
            }
            return false;
        }
        let userFactionData = null;
        let userMembersData = [];
        let sortColumn = null;
        let sortDirection = 'asc';
        let refreshInterval = null;
        let lastRefreshTime = null;
        let autoRefreshSeconds = 15; // Default refresh interval in seconds

        // Portal sorting state
        let ownPortalSortColumn = 'name';
        let ownPortalSortDirection = 'asc';
        let enemyPortalSortColumn = 'name';
        let enemyPortalSortDirection = 'asc';

        // Hospital timer interval reference
        let hospitalTimerInterval = null;

        // TornStats spy data cache - stores fetched spy data by player ID
        // This is loaded from localStorage on startup and saved when updated
        let tornStatsCache = {};

        // Load TornStats cache from localStorage
        function loadTornStatsCache() {
            try {
                const saved = localStorage.getItem('tornStatsCache');
                if (saved) {
                    tornStatsCache = JSON.parse(saved);
                    console.log(`Loaded ${Object.keys(tornStatsCache).length} cached TornStats entries`);
                }
            } catch (e) {
                console.warn('Failed to load TornStats cache:', e);
                tornStatsCache = {};
            }
        }

        // Save TornStats cache to localStorage
        function saveTornStatsCache() {
            try {
                localStorage.setItem('tornStatsCache', JSON.stringify(tornStatsCache));
            } catch (e) {
                console.warn('Failed to save TornStats cache:', e);
            }
        }

        // Portal column widths (stored separately for own and enemy factions)
        // Default widths in pixels for: name, level, est_stats, str, def, spd, dex, life, status, timer
        const defaultColumnWidths = {
            name: 150,
            level: 50,
            est_stats: 80,
            str: 65,
            def: 65,
            spd: 65,
            dex: 65,
            life: 70,
            status: 100,
            timer: 90
        };
        let ownColumnWidths = { ...defaultColumnWidths };
        let enemyColumnWidths = { ...defaultColumnWidths };

        // Portal column order (draggable columns)
        const defaultPortalColumns = ['name', 'level', 'est_stats', 'str', 'def', 'spd', 'dex', 'life', 'status', 'timer'];
        let ownPortalColumnOrder = [...defaultPortalColumns];
        let enemyPortalColumnOrder = [...defaultPortalColumns];

        // Portal column definitions
        const portalColumnDefs = {
            name: { label: 'Name', sortKey: 'name' },
            level: { label: 'Level', sortKey: 'level' },
            est_stats: { label: 'Est. Stats', sortKey: 'est_stats' },
            str: { label: 'STR', sortKey: 'str' },
            def: { label: 'DEF', sortKey: 'def' },
            spd: { label: 'SPD', sortKey: 'spd' },
            dex: { label: 'DEX', sortKey: 'dex' },
            life: { label: 'Life', sortKey: 'life' },
            status: { label: 'Status', sortKey: 'status' },
            timer: { label: 'Timer', sortKey: 'timer' }
        };

        // Portal drag state
        let portalDraggedColumn = null;
        let portalDraggedIndex = null;
        let portalDragIsEnemy = false;

        // Load portal column order from localStorage
        function loadPortalColumnOrder() {
            const savedOwn = localStorage.getItem('tornPortalOwnColumnOrder');
            const savedEnemy = localStorage.getItem('tornPortalEnemyColumnOrder');
            if (savedOwn) {
                try {
                    const parsed = JSON.parse(savedOwn);
                    // Check if saved columns match current expected columns
                    const hasAllColumns = defaultPortalColumns.every(col => parsed.includes(col));
                    if (Array.isArray(parsed) && hasAllColumns && parsed.length === defaultPortalColumns.length) {
                        ownPortalColumnOrder = parsed;
                    } else {
                        // Reset to defaults if columns changed (e.g., est_stats -> str/def/spd/dex)
                        ownPortalColumnOrder = [...defaultPortalColumns];
                    }
                } catch (e) {
                    ownPortalColumnOrder = [...defaultPortalColumns];
                }
            }
            if (savedEnemy) {
                try {
                    const parsed = JSON.parse(savedEnemy);
                    const hasAllColumns = defaultPortalColumns.every(col => parsed.includes(col));
                    if (Array.isArray(parsed) && hasAllColumns && parsed.length === defaultPortalColumns.length) {
                        enemyPortalColumnOrder = parsed;
                    } else {
                        // Reset to defaults if columns changed
                        enemyPortalColumnOrder = [...defaultPortalColumns];
                    }
                } catch (e) {
                    enemyPortalColumnOrder = [...defaultPortalColumns];
                }
            }
        }

        // Save portal column order to localStorage
        function savePortalColumnOrder() {
            localStorage.setItem('tornPortalOwnColumnOrder', JSON.stringify(ownPortalColumnOrder));
            localStorage.setItem('tornPortalEnemyColumnOrder', JSON.stringify(enemyPortalColumnOrder));
        }

        // Handle portal drag start
        function handlePortalDragStart(e, isEnemy) {
            portalDraggedColumn = e.target.closest('div[data-column]');
            if (!portalDraggedColumn) return;

            portalDragIsEnemy = isEnemy;
            const parent = portalDraggedColumn.parentNode;
            const siblings = Array.from(parent.querySelectorAll('div[data-column]'));
            portalDraggedIndex = siblings.indexOf(portalDraggedColumn);

            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', portalDraggedIndex);

            setTimeout(() => {
                portalDraggedColumn.classList.add('dragging');
            }, 0);
        }

        // Handle portal drag over
        function handlePortalDragOver(e, isEnemy) {
            e.preventDefault();
            if (portalDragIsEnemy !== isEnemy) return; // Don't allow cross-faction dragging

            e.dataTransfer.dropEffect = 'move';

            const targetCol = e.target.closest('div[data-column]');
            if (!targetCol || targetCol === portalDraggedColumn) return;

            // Clear all indicators in this header row
            const parent = targetCol.parentNode;
            parent.querySelectorAll('div[data-column]').forEach(col => {
                col.classList.remove('drag-over-left', 'drag-over-right');
            });

            const rect = targetCol.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;

            if (e.clientX < midpoint) {
                targetCol.classList.add('drag-over-left');
            } else {
                targetCol.classList.add('drag-over-right');
            }
        }

        // Handle portal drag leave
        function handlePortalDragLeave(e) {
            const targetCol = e.target.closest('div[data-column]');
            if (targetCol) {
                targetCol.classList.remove('drag-over-left', 'drag-over-right');
            }
        }

        // Handle portal drop
        function handlePortalDrop(e, isEnemy) {
            e.preventDefault();
            if (portalDragIsEnemy !== isEnemy) {
                cleanupPortalDrag();
                return;
            }

            const targetCol = e.target.closest('div[data-column]');
            if (!targetCol || !portalDraggedColumn || targetCol === portalDraggedColumn) {
                cleanupPortalDrag();
                return;
            }

            const parent = targetCol.parentNode;
            const siblings = Array.from(parent.querySelectorAll('div[data-column]'));
            const targetIndex = siblings.indexOf(targetCol);

            // Determine insert position
            const rect = targetCol.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;
            let insertIndex = e.clientX < midpoint ? targetIndex : targetIndex + 1;

            if (portalDraggedIndex < insertIndex) {
                insertIndex--;
            }

            // Reorder the column array
            const columnOrder = isEnemy ? enemyPortalColumnOrder : ownPortalColumnOrder;
            const [removed] = columnOrder.splice(portalDraggedIndex, 1);
            columnOrder.splice(insertIndex, 0, removed);

            // Save and re-render
            savePortalColumnOrder();
            renderWarPortal();

            cleanupPortalDrag();
        }

        // Handle portal drag end
        function handlePortalDragEnd(e) {
            cleanupPortalDrag();
        }

        // Clean up portal drag state
        function cleanupPortalDrag() {
            if (portalDraggedColumn) {
                portalDraggedColumn.classList.remove('dragging');
            }
            document.querySelectorAll('.portal-header-row div[data-column]').forEach(col => {
                col.classList.remove('drag-over-left', 'drag-over-right');
            });
            portalDraggedColumn = null;
            portalDraggedIndex = null;
        }

        // Column resize state
        let isResizing = false;
        let resizingColumn = null;
        let resizingIsEnemy = false;
        let resizeStartX = 0;
        let resizeStartWidth = 0;

        // Load column widths from localStorage
        function loadColumnWidths() {
            const savedOwn = localStorage.getItem('tornPortalOwnColumnWidths');
            const savedEnemy = localStorage.getItem('tornPortalEnemyColumnWidths');
            if (savedOwn) {
                try {
                    ownColumnWidths = { ...defaultColumnWidths, ...JSON.parse(savedOwn) };
                } catch (e) {
                    ownColumnWidths = { ...defaultColumnWidths };
                }
            }
            if (savedEnemy) {
                try {
                    enemyColumnWidths = { ...defaultColumnWidths, ...JSON.parse(savedEnemy) };
                } catch (e) {
                    enemyColumnWidths = { ...defaultColumnWidths };
                }
            }
        }

        // Save column widths to localStorage
        function saveColumnWidths() {
            localStorage.setItem('tornPortalOwnColumnWidths', JSON.stringify(ownColumnWidths));
            localStorage.setItem('tornPortalEnemyColumnWidths', JSON.stringify(enemyColumnWidths));
        }

        // Initialize column resize handlers
        function initColumnResize() {
            document.addEventListener('mousemove', handleColumnResize);
            document.addEventListener('mouseup', stopColumnResize);
        }

        // Start resizing a column
        function startColumnResize(e, column, isEnemy) {
            e.preventDefault();
            e.stopPropagation();
            isResizing = true;
            resizingColumn = column;
            resizingIsEnemy = isEnemy;
            resizeStartX = e.clientX;
            resizeStartWidth = isEnemy ? enemyColumnWidths[column] : ownColumnWidths[column];
            document.body.classList.add('resizing-columns');
            e.target.classList.add('resizing');
        }

        // Handle column resize mouse move
        function handleColumnResize(e) {
            if (!isResizing) return;

            const diff = e.clientX - resizeStartX;
            const newWidth = Math.max(40, resizeStartWidth + diff); // Minimum 40px width

            if (resizingIsEnemy) {
                enemyColumnWidths[resizingColumn] = newWidth;
            } else {
                ownColumnWidths[resizingColumn] = newWidth;
            }

            // Update column widths in real-time
            applyColumnWidths(resizingIsEnemy);
        }

        // Stop column resize
        function stopColumnResize() {
            if (isResizing) {
                isResizing = false;
                document.body.classList.remove('resizing-columns');
                document.querySelectorAll('.col-resize-handle.resizing').forEach(el => el.classList.remove('resizing'));
                saveColumnWidths();
                resizingColumn = null;
            }
        }

        // Apply column widths to all rows in a faction list
        function applyColumnWidths(isEnemy) {
            const widths = isEnemy ? enemyColumnWidths : ownColumnWidths;
            const columnOrder = isEnemy ? enemyPortalColumnOrder : ownPortalColumnOrder;
            const listId = isEnemy ? 'enemyMembersList' : 'ownMembersList';
            const list = document.getElementById(listId);
            if (!list) return;

            // Apply to header row using data-column attribute
            const headerRow = list.querySelector('.portal-header-row');
            if (headerRow) {
                const cols = headerRow.querySelectorAll(':scope > div[data-column]');
                cols.forEach(col => {
                    const colName = col.dataset.column;
                    if (colName && widths[colName] !== undefined) {
                        col.style.width = widths[colName] + 'px';
                        col.style.minWidth = widths[colName] + 'px';
                        col.style.flexShrink = '0';
                    }
                });
            }

            // Apply to member rows using data-column attribute
            const memberRows = list.querySelectorAll('.portal-member-row');
            memberRows.forEach(row => {
                const cols = row.querySelectorAll(':scope > div[data-column]');
                cols.forEach(col => {
                    const colName = col.dataset.column;
                    if (colName && widths[colName] !== undefined) {
                        col.style.width = widths[colName] + 'px';
                        col.style.minWidth = widths[colName] + 'px';
                        col.style.flexShrink = '0';
                    }
                });
            });
        }

        // War Planning column order (draggable columns)
        // Note: 'energy' column removed as it requires Full Access API key which most users don't have
        const defaultWarPlanningColumns = [
            'name', 'est_stats', 'level', 'age', 'life', 'elo', 'best_damage',
            'critical_hits', 'rw_hits', 'xanax', 'vicodin', 'overdosed', 'refills', 'location'
        ];
        let warPlanningColumnOrder = [...defaultWarPlanningColumns];

        // War Planning drag state
        let draggedColumn = null;
        let draggedColumnIndex = null;

        // Spy Faction column order (same columns as War Planning)
        let spyFactionColumnOrder = [...defaultWarPlanningColumns];
        let spyFactionSortColumn = 'est_stats';
        let spyFactionSortDirection = 'desc';

        // Spy Faction drag state
        let spyDraggedColumn = null;
        let spyDraggedColumnIndex = null;

        // Spy Faction column widths
        let spyColumnWidths = {};

        // TornStats columns to show alongside est_stats
        const tornStatsColumns = ['str', 'def', 'spd', 'dex'];

        // Column definitions for TornStats columns
        const tornStatsColumnDefs = {
            str: { label: 'STR', sortKey: 'str' },
            def: { label: 'DEF', sortKey: 'def' },
            spd: { label: 'SPD', sortKey: 'spd' },
            dex: { label: 'DEX', sortKey: 'dex' }
        };

        // Load war planning column order from localStorage
        function loadWarPlanningColumnOrder() {
            const saved = localStorage.getItem('tornWarPlanningColumnOrder');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    // Validate that all columns exist
                    const hasAllColumns = defaultWarPlanningColumns.every(col => parsed.includes(col));
                    if (Array.isArray(parsed) && hasAllColumns && parsed.length === defaultWarPlanningColumns.length) {
                        warPlanningColumnOrder = parsed;
                    } else {
                        // Reset to defaults if columns changed
                        warPlanningColumnOrder = [...defaultWarPlanningColumns];
                    }
                } catch (e) {
                    warPlanningColumnOrder = [...defaultWarPlanningColumns];
                }
            }
        }

        // Save war planning column order to localStorage
        function saveWarPlanningColumnOrder() {
            localStorage.setItem('tornWarPlanningColumnOrder', JSON.stringify(warPlanningColumnOrder));
        }

        // Handle drag start for war planning columns
        function handleWarPlanningDragStart(e) {
            draggedColumn = e.target.closest('th');
            if (!draggedColumn) return;

            draggedColumnIndex = Array.from(draggedColumn.parentNode.children).indexOf(draggedColumn);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedColumnIndex);

            // Add dragging class after a short delay to allow drag image to be captured
            setTimeout(() => {
                draggedColumn.classList.add('dragging');
            }, 0);
        }

        // Handle drag over for war planning columns
        function handleWarPlanningDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const th = e.target.closest('th');
            if (!th || th === draggedColumn) return;

            // Add visual indicator
            const allThs = th.parentNode.querySelectorAll('th');
            allThs.forEach(t => t.classList.remove('drag-over-left', 'drag-over-right'));

            const rect = th.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;

            if (e.clientX < midpoint) {
                th.classList.add('drag-over-left');
            } else {
                th.classList.add('drag-over-right');
            }
        }

        // Handle drag leave for war planning columns
        function handleWarPlanningDragLeave(e) {
            const th = e.target.closest('th');
            if (th) {
                th.classList.remove('drag-over-left', 'drag-over-right');
            }
        }

        // Handle drop for war planning columns
        function handleWarPlanningDrop(e) {
            e.preventDefault();

            const targetTh = e.target.closest('th');
            if (!targetTh || !draggedColumn || targetTh === draggedColumn) {
                cleanupDrag();
                return;
            }

            const targetIndex = Array.from(targetTh.parentNode.children).indexOf(targetTh);

            // Determine if we should insert before or after
            const rect = targetTh.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;
            let insertIndex = e.clientX < midpoint ? targetIndex : targetIndex + 1;

            // Adjust for the removed element
            if (draggedColumnIndex < insertIndex) {
                insertIndex--;
            }

            // Reorder the column array
            const [removed] = warPlanningColumnOrder.splice(draggedColumnIndex, 1);
            warPlanningColumnOrder.splice(insertIndex, 0, removed);

            // Save and re-render
            saveWarPlanningColumnOrder();
            filterMembers(); // This will re-render the table with new column order

            cleanupDrag();
        }

        // Handle drag end for war planning columns
        function handleWarPlanningDragEnd(e) {
            cleanupDrag();
        }

        // Clean up drag state
        function cleanupDrag() {
            if (draggedColumn) {
                draggedColumn.classList.remove('dragging');
            }
            document.querySelectorAll('.members-table th').forEach(th => {
                th.classList.remove('drag-over-left', 'drag-over-right');
            });
            draggedColumn = null;
            draggedColumnIndex = null;
        }

        // Load spy faction column order from localStorage
        function loadSpyFactionColumnOrder() {
            const saved = localStorage.getItem('tornSpyFactionColumnOrder');
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    const hasAllColumns = defaultWarPlanningColumns.every(col => parsed.includes(col));
                    if (Array.isArray(parsed) && hasAllColumns && parsed.length === defaultWarPlanningColumns.length) {
                        spyFactionColumnOrder = parsed;
                    } else {
                        spyFactionColumnOrder = [...defaultWarPlanningColumns];
                    }
                } catch (e) {
                    spyFactionColumnOrder = [...defaultWarPlanningColumns];
                }
            }
        }

        // Save spy faction column order to localStorage
        function saveSpyFactionColumnOrder() {
            localStorage.setItem('tornSpyFactionColumnOrder', JSON.stringify(spyFactionColumnOrder));
        }

        // Load spy faction column widths from localStorage
        function loadSpyColumnWidths() {
            const saved = localStorage.getItem('tornSpyColumnWidths');
            if (saved) {
                try {
                    spyColumnWidths = JSON.parse(saved);
                } catch (e) {
                    spyColumnWidths = { ...defaultWPColumnWidths };
                }
            } else {
                spyColumnWidths = { ...defaultWPColumnWidths };
            }
        }

        // Save spy faction column widths to localStorage
        function saveSpyColumnWidths() {
            localStorage.setItem('tornSpyColumnWidths', JSON.stringify(spyColumnWidths));
        }

        // Handle drag start for spy faction columns
        function handleSpyFactionDragStart(e) {
            spyDraggedColumn = e.target.closest('th');
            if (!spyDraggedColumn) return;

            spyDraggedColumnIndex = Array.from(spyDraggedColumn.parentNode.children).indexOf(spyDraggedColumn);
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', spyDraggedColumnIndex);

            setTimeout(() => {
                spyDraggedColumn.classList.add('dragging');
            }, 0);
        }

        // Handle drag over for spy faction columns
        function handleSpyFactionDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';

            const th = e.target.closest('th');
            if (!th || th === spyDraggedColumn) return;

            const allThs = th.parentNode.querySelectorAll('th');
            allThs.forEach(t => t.classList.remove('drag-over-left', 'drag-over-right'));

            const rect = th.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;

            if (e.clientX < midpoint) {
                th.classList.add('drag-over-left');
            } else {
                th.classList.add('drag-over-right');
            }
        }

        // Handle drag leave for spy faction columns
        function handleSpyFactionDragLeave(e) {
            const th = e.target.closest('th');
            if (th) {
                th.classList.remove('drag-over-left', 'drag-over-right');
            }
        }

        // Handle drop for spy faction columns
        function handleSpyFactionDrop(e) {
            e.preventDefault();

            const targetTh = e.target.closest('th');
            if (!targetTh || !spyDraggedColumn || targetTh === spyDraggedColumn) {
                cleanupSpyDrag();
                return;
            }

            const targetIndex = Array.from(targetTh.parentNode.children).indexOf(targetTh);

            const rect = targetTh.getBoundingClientRect();
            const midpoint = rect.left + rect.width / 2;
            let insertIndex = e.clientX < midpoint ? targetIndex : targetIndex + 1;

            if (spyDraggedColumnIndex < insertIndex) {
                insertIndex--;
            }

            const [removed] = spyFactionColumnOrder.splice(spyDraggedColumnIndex, 1);
            spyFactionColumnOrder.splice(insertIndex, 0, removed);

            saveSpyFactionColumnOrder();
            filterSpyMembers();

            cleanupSpyDrag();
        }

        // Handle drag end for spy faction columns
        function handleSpyFactionDragEnd(e) {
            cleanupSpyDrag();
        }

        // Clean up spy drag state
        function cleanupSpyDrag() {
            if (spyDraggedColumn) {
                spyDraggedColumn.classList.remove('dragging');
            }
            document.querySelectorAll('#spyMembersTable th').forEach(th => {
                th.classList.remove('drag-over-left', 'drag-over-right');
            });
            spyDraggedColumn = null;
            spyDraggedColumnIndex = null;
        }

        // Sort spy faction members
        function sortSpyMembers(column) {
            if (spyFactionSortColumn === column) {
                spyFactionSortDirection = spyFactionSortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                spyFactionSortColumn = column;
                spyFactionSortDirection = 'desc';
            }
            filterSpyMembers();
        }

        // Spy column resize state
        let isSpyResizing = false;
        let spyResizingColumn = null;
        let spyResizeStartX = 0;
        let spyResizeStartWidth = 0;

        // Start spy column resize
        function startSpyColumnResize(e, columnName) {
            e.preventDefault();
            e.stopPropagation();
            isSpyResizing = true;
            spyResizingColumn = columnName;
            spyResizeStartX = e.clientX;
            spyResizeStartWidth = spyColumnWidths[columnName] || defaultWPColumnWidths[columnName];
            document.addEventListener('mousemove', handleSpyColumnResize);
            document.addEventListener('mouseup', stopSpyColumnResize);
        }

        // Handle spy column resize
        function handleSpyColumnResize(e) {
            if (!isSpyResizing) return;
            const diff = e.clientX - spyResizeStartX;
            const newWidth = Math.max(40, spyResizeStartWidth + diff);
            spyColumnWidths[spyResizingColumn] = newWidth;

            // Update column width in real-time
            const headers = document.querySelectorAll(`#spyMembersTable th[data-column="${spyResizingColumn}"]`);
            const cells = document.querySelectorAll(`#spyMembersTable td[data-column="${spyResizingColumn}"]`);
            headers.forEach(h => { h.style.width = newWidth + 'px'; h.style.minWidth = newWidth + 'px'; });
            cells.forEach(c => { c.style.width = newWidth + 'px'; c.style.minWidth = newWidth + 'px'; });
        }

        // Stop spy column resize
        function stopSpyColumnResize() {
            if (isSpyResizing) {
                saveSpyColumnWidths();
            }
            isSpyResizing = false;
            spyResizingColumn = null;
            document.removeEventListener('mousemove', handleSpyColumnResize);
            document.removeEventListener('mouseup', stopSpyColumnResize);
        }

        // War Planning column widths (resizable)
        const defaultWPColumnWidths = {
            name: 180,
            est_stats: 100,
            level: 60,
            age: 80,
            life: 80,
            elo: 60,
            best_damage: 90,
            critical_hits: 70,
            rw_hits: 80,
            xanax: 70,
            vicodin: 70,
            overdosed: 50,
            refills: 70,
            location: 120
        };
        let wpColumnWidths = { ...defaultWPColumnWidths };

        // War Planning resize state
        let isWPResizing = false;
        let wpResizingColumn = null;
        let wpResizeStartX = 0;
        let wpResizeStartWidth = 0;

        // Load war planning column widths from localStorage
        function loadWPColumnWidths() {
            const saved = localStorage.getItem('tornWarPlanningColumnWidths');
            if (saved) {
                try {
                    wpColumnWidths = { ...defaultWPColumnWidths, ...JSON.parse(saved) };
                } catch (e) {
                    wpColumnWidths = { ...defaultWPColumnWidths };
                }
            }
        }

        // Save war planning column widths to localStorage
        function saveWPColumnWidths() {
            localStorage.setItem('tornWarPlanningColumnWidths', JSON.stringify(wpColumnWidths));
        }

        // Start resizing a war planning column
        function startWPColumnResize(e, column) {
            e.preventDefault();
            e.stopPropagation();
            isWPResizing = true;
            wpResizingColumn = column;
            wpResizeStartX = e.clientX;
            wpResizeStartWidth = wpColumnWidths[column] || defaultWPColumnWidths[column];
            document.body.classList.add('resizing-columns');
            e.target.classList.add('resizing');
        }

        // Handle war planning column resize mouse move
        function handleWPColumnResize(e) {
            if (!isWPResizing) return;

            const diff = e.clientX - wpResizeStartX;
            const newWidth = Math.max(40, wpResizeStartWidth + diff);

            wpColumnWidths[wpResizingColumn] = newWidth;
            applyWPColumnWidths();
        }

        // Stop war planning column resize
        function stopWPColumnResize() {
            if (isWPResizing) {
                isWPResizing = false;
                document.body.classList.remove('resizing-columns');
                document.querySelectorAll('.wp-resize-handle.resizing').forEach(el => el.classList.remove('resizing'));
                saveWPColumnWidths();
                wpResizingColumn = null;
            }
        }

        // Apply column widths to war planning table
        function applyWPColumnWidths() {
            const table = document.querySelector('.members-table');
            if (!table) return;

            // Apply to header cells
            const headerCells = table.querySelectorAll('thead th');
            headerCells.forEach(th => {
                const col = th.dataset.column;
                if (col && wpColumnWidths[col]) {
                    th.style.width = wpColumnWidths[col] + 'px';
                    th.style.minWidth = wpColumnWidths[col] + 'px';
                }
            });

            // Apply to body cells
            const rows = table.querySelectorAll('tbody tr');
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                cells.forEach((td, index) => {
                    const col = warPlanningColumnOrder[index];
                    if (col && wpColumnWidths[col]) {
                        td.style.width = wpColumnWidths[col] + 'px';
                        td.style.minWidth = wpColumnWidths[col] + 'px';
                    }
                });
            });
        }

        // Initialize war planning column resize handlers
        function initWPColumnResize() {
            document.addEventListener('mousemove', handleWPColumnResize);
            document.addEventListener('mouseup', stopWPColumnResize);
        }

        // Activity history: stores status for each member per hour
        // Format: { memberId: { hour: { online: count, total: count } } }
        let activityHistory = {};

        // Load activity history from localStorage
        function loadActivityHistory() {
            const saved = localStorage.getItem('tornActivityHistory');
            if (saved) {
                try {
                    activityHistory = JSON.parse(saved);
                    // Clean old data (older than 24 hours)
                    cleanOldActivityData();
                } catch (e) {
                    activityHistory = {};
                }
            }
        }

        // Save activity history to localStorage
        function saveActivityHistory() {
            localStorage.setItem('tornActivityHistory', JSON.stringify(activityHistory));
        }

        // Clean data older than 24 hours
        function cleanOldActivityData() {
            const now = new Date();
            const today = now.toISOString().split('T')[0];
            const yesterday = new Date(now - 24 * 60 * 60 * 1000).toISOString().split('T')[0];

            for (const memberId in activityHistory) {
                for (const hourKey in activityHistory[memberId]) {
                    if (!hourKey.startsWith(today) && !hourKey.startsWith(yesterday)) {
                        delete activityHistory[memberId][hourKey];
                    }
                }
            }
        }

        // Infer historical activity from last_action.timestamp
        // This marks the hour of their last known activity as online
        function inferHistoricalActivity(member) {
            if (!member.last_action || !member.last_action.timestamp) return;

            const lastActionTime = new Date(member.last_action.timestamp * 1000);
            const now = new Date();
            const hoursDiff = Math.floor((now - lastActionTime) / (60 * 60 * 1000));

            // Only infer for last 24 hours
            if (hoursDiff > 24) return;

            if (!activityHistory[member.id]) {
                activityHistory[member.id] = {};
            }

            // Mark the hour of last activity as online (if we don't already have data for it)
            const lastActionHourKey = lastActionTime.toISOString().split('T')[0] + '-' + lastActionTime.getHours().toString().padStart(2, '0');

            if (!activityHistory[member.id][lastActionHourKey]) {
                activityHistory[member.id][lastActionHourKey] = { online: 1, idle: 0, total: 1 };
            }

            // If they were active recently (within last hour), they were likely online for recent hours too
            // Mark hours between last action and now as partially known
            if (hoursDiff <= 1 && (member.last_action.status === 'Online' || member.last_action.status === 'Idle')) {
                const currentHourKey = now.toISOString().split('T')[0] + '-' + now.getHours().toString().padStart(2, '0');
                if (!activityHistory[member.id][currentHourKey]) {
                    if (member.last_action.status === 'Online') {
                        activityHistory[member.id][currentHourKey] = { online: 1, idle: 0, total: 1 };
                    } else {
                        activityHistory[member.id][currentHourKey] = { online: 0, idle: 1, total: 1 };
                    }
                }
            }
        }

        // Record current status for all members
        function recordActivityStatus() {
            const now = new Date();
            const hourKey = now.toISOString().split('T')[0] + '-' + now.getHours().toString().padStart(2, '0');

            membersData.forEach(member => {
                // First, infer any historical data from their last_action timestamp
                inferHistoricalActivity(member);

                if (!activityHistory[member.id]) {
                    activityHistory[member.id] = {};
                }
                if (!activityHistory[member.id][hourKey]) {
                    activityHistory[member.id][hourKey] = { online: 0, idle: 0, total: 0 };
                }

                activityHistory[member.id][hourKey].total++;
                if (member.last_action.status === 'Online') {
                    activityHistory[member.id][hourKey].online++;
                } else if (member.last_action.status === 'Idle') {
                    activityHistory[member.id][hourKey].idle++;
                }
            });

            saveActivityHistory();
        }

        // Get activity status for an hour (returns 'online', 'partial', 'offline', or 'unknown')
        function getHourStatus(memberId, hourKey) {
            if (!activityHistory[memberId] || !activityHistory[memberId][hourKey]) {
                return 'unknown';
            }

            const data = activityHistory[memberId][hourKey];
            if (data.total === 0) return 'unknown';

            const onlineRatio = (data.online + data.idle * 0.5) / data.total;

            if (onlineRatio >= 0.8) return 'online';
            if (onlineRatio >= 0.2) return 'partial';
            return 'offline';
        }

        // Generate 24-hour activity grid HTML
        function generateActivityGrid(memberId) {
            const now = new Date();
            const hours = [];

            // Generate last 24 hours
            for (let i = 23; i >= 0; i--) {
                const hourDate = new Date(now - i * 60 * 60 * 1000);
                const hourKey = hourDate.toISOString().split('T')[0] + '-' + hourDate.getHours().toString().padStart(2, '0');
                const hourLabel = hourDate.getHours().toString().padStart(2, '0') + ':00';
                const status = getHourStatus(memberId, hourKey);

                hours.push(`<div class="hour-box ${status}" data-tooltip="${hourLabel}" title="${hourLabel}">${hourDate.getHours()}</div>`);
            }

            return `<div class="activity-grid">${hours.join('')}</div>`;
        }

        // Estimate battle stats based on publicly available data
        // Formula based on community research: xanax is a strong indicator
        // ~500M total stats per 1000 xanax as conservative baseline
        function estimateBattleStats(member) {
            const stats = member.details.personalstats || {};
            const profile = member.details || {};

            const level = member.level || 1;
            const age = profile.age || 1;
            const xanax = stats.xantaken || 0;
            const refills = stats.energydrinkused || stats.refills || 0;
            const attacks = (stats.attackswon || 0) + (stats.attackslost || 0);

            // Base estimation using multiple factors
            let estimate = 0;

            // Primary factor: Xanax (most reliable indicator)
            // Community research suggests ~500-750M total stats per 1000 xanax
            if (xanax > 0) {
                estimate = xanax * 500000; // 500K per xanax as baseline
            }

            // Secondary factors - dampened to avoid over-inflation
            // Level adds modest multiplier (up to 1.3x at level 100)
            const levelFactor = 1 + (level / 333);
            // Age adds modest multiplier (up to 1.3x over 10 years)
            const ageFactor = 1 + Math.min(age / 12167, 0.3);

            // If no xanax data, use level/age based estimation
            if (estimate === 0) {
                const baseStat = 1000000;
                estimate = baseStat * levelFactor * ageFactor;
            } else {
                // Apply dampened modifiers (factor * 0.2 + 0.8 gives range 0.8-1.06)
                estimate = estimate * (levelFactor * 0.2 + 0.8) * (ageFactor * 0.2 + 0.8);
            }

            // Refills boost - reduced impact (up to 20% boost instead of 50%)
            if (refills > 0) {
                estimate *= 1 + Math.min(refills / 10000, 0.2);
            }

            return {
                low: Math.round(estimate * 0.6),
                mid: Math.round(estimate),
                high: Math.round(estimate * 1.5)
            };
        }

        // Get energy display for a member
        // Show TornStats checking indicator on a faction list
        function showTornStatsIndicator(isEnemy, message) {
            const listId = isEnemy ? 'enemyMembersList' : 'ownMembersList';
            const list = document.getElementById(listId);
            if (list) {
                // Check if indicator already exists
                let indicator = list.querySelector('.tornstats-indicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.className = 'tornstats-indicator';
                    indicator.style.cssText = 'background: #e3f2fd; color: #1565c0; padding: 8px 12px; text-align: center; font-size: 12px; border-bottom: 1px solid #ddd;';
                    // Insert after header row
                    const headerRow = list.querySelector('.portal-header-row');
                    if (headerRow && headerRow.nextSibling) {
                        list.insertBefore(indicator, headerRow.nextSibling);
                    } else {
                        list.insertBefore(indicator, list.firstChild);
                    }
                }
                indicator.innerHTML = message;
            }
        }

        // Hide TornStats checking indicator
        function hideTornStatsIndicator(isEnemy) {
            const listId = isEnemy ? 'enemyMembersList' : 'ownMembersList';
            const list = document.getElementById(listId);
            if (list) {
                const indicator = list.querySelector('.tornstats-indicator');
                if (indicator) {
                    indicator.remove();
                }
            }
        }

        // Batched fetch for member details to avoid hitting API rate limits
        // Returns array of member details, updates a container element with progress
        // containerSelector: DOM element, CSS selector string, or 'global' to use the main loading indicator
        async function fetchMemberDetailsBatched(memberIds, apiKey, containerSelector = null, labelText = 'Loading members') {
            const batchSize = 5;
            const delayMs = 1000; // 1 second between batches to stay well under rate limit
            const results = [];

            // Determine which progress indicator to use
            const useGlobalLoader = containerSelector === 'global';
            let container = null;
            if (!useGlobalLoader && containerSelector) {
                container = typeof containerSelector === 'string'
                    ? document.querySelector(containerSelector)
                    : containerSelector;
            }

            const updateProgress = (current, total) => {
                if (useGlobalLoader) {
                    updateLoadingProgress(current, total, labelText);
                } else if (container) {
                    container.innerHTML = `
                        <div style="padding: 40px; text-align: center;">
                            <div style="color: #666; margin-bottom: 15px;">${labelText}...</div>
                            <div style="width: 200px; height: 20px; background: #e0e0e0; border-radius: 10px; margin: 0 auto; overflow: hidden;">
                                <div style="width: ${(current/total)*100}%; height: 100%; background: linear-gradient(90deg, #4a7c4e, #6a9b6e); transition: width 0.3s;"></div>
                            </div>
                            <div style="color: #888; margin-top: 10px; font-size: 14px;">${current} / ${total} members</div>
                        </div>
                    `;
                }
            };

            updateProgress(0, memberIds.length);

            for (let i = 0; i < memberIds.length; i += batchSize) {
                const batch = memberIds.slice(i, i + batchSize);

                const batchPromises = batch.map(id =>
                    fetch(`https://api.torn.com/user/${id}?selections=profile,personalstats&key=${apiKey}`)
                        .then(r => r.json())
                        .then(d => ({ id, ...d }))
                        .catch(e => ({ id, error: e.message }))
                );

                const batchResults = await Promise.all(batchPromises);
                results.push(...batchResults);

                updateProgress(Math.min(i + batchSize, memberIds.length), memberIds.length);

                // Delay before next batch (except for last batch)
                if (i + batchSize < memberIds.length) {
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                }
            }

            return results;
        }

        // Fetch spy data from TornStats for a list of player IDs
        // forceUpdate: if true, fetches all players regardless of cache
        // isEnemy: optional, indicates which faction list to show indicator on
        // Returns the number of players with real spy data found
        async function fetchTornStatsSpyData(playerIds, forceUpdate = false, isEnemy = null) {
            const tornStatsApiKey = document.getElementById('tornStatsApiKey').value.trim();
            if (!tornStatsApiKey) {
                console.log('TornStats: No API key provided, skipping fetch');
                return 0; // No TornStats API key provided
            }

            console.log(`TornStats: Fetching spy data for ${playerIds.length} players (forceUpdate: ${forceUpdate})...`);

            // Filter out players we already have valid cached data for (unless force update)
            // For normal refresh, skip players we've already checked (even if no data)
            // For force update, re-fetch everyone
            const idsToFetch = forceUpdate ? [...playerIds] : playerIds.filter(id => {
                const cached = tornStatsCache[id];
                // Skip if we have valid spy data with a timestamp
                if (cached && cached.total && cached.timestamp) {
                    console.log(`TornStats: Player ${id} already has cached data`);
                    return false;
                }
                // Skip if we checked recently and found no data (check again after 1 hour)
                if (cached && cached.noData && cached.checkedAt) {
                    const hoursSinceCheck = (Date.now() - cached.checkedAt) / (1000 * 60 * 60);
                    if (hoursSinceCheck < 1) {
                        console.log(`TornStats: Player ${id} checked recently (${hoursSinceCheck.toFixed(1)}h ago), skipping`);
                        return false;
                    }
                }
                return true;
            });

            console.log(`TornStats: Will fetch ${idsToFetch.length} players (${playerIds.length - idsToFetch.length} cached)`);

            if (idsToFetch.length === 0) {
                console.log('All players already in TornStats cache');
                return 0;
            }

            // Show indicator if we know which list this is for
            if (isEnemy !== null) {
                showTornStatsIndicator(isEnemy, `Checking TornStats... (0/${idsToFetch.length})`);
            }

            let foundCount = 0;
            let checkedCount = 0;

            // TornStats API has rate limits (10 req/sec), so we batch requests with delays
            const batchSize = 5;
            const delayMs = 1000; // 1 second between batches

            for (let i = 0; i < idsToFetch.length; i += batchSize) {
                const batch = idsToFetch.slice(i, i + batchSize);

                const promises = batch.map(async (playerId) => {
                    try {
                        const response = await fetch(
                            `https://www.tornstats.com/api/v2/${tornStatsApiKey}/spy/user/${playerId}`
                        );
                        const data = await response.json();

                        console.log(`TornStats API response for ${playerId}:`, data);

                        if (data.status === true && data.spy && data.spy.total) {
                            const newTimestamp = data.spy.timestamp || null;
                            const existingData = tornStatsCache[playerId];

                            // Only update if new data is more recent or we don't have data
                            if (!existingData || !existingData.timestamp || !newTimestamp ||
                                newTimestamp >= existingData.timestamp) {
                                tornStatsCache[playerId] = {
                                    total: data.spy.total,
                                    strength: data.spy.strength || null,
                                    speed: data.spy.speed || null,
                                    defense: data.spy.defense || null,
                                    dexterity: data.spy.dexterity || null,
                                    timestamp: newTimestamp,
                                    isEstimate: data.spy.target_score !== undefined
                                };
                                foundCount++;
                                console.log(`TornStats: Got spy data for ${playerId}: ${formatStatNumber(data.spy.total)}`);
                            }
                        } else {
                            // No spy data available, mark as checked with timestamp
                            console.log(`TornStats: No spy data for ${playerId}`);
                            tornStatsCache[playerId] = { noData: true, checkedAt: Date.now() };
                        }
                    } catch (error) {
                        console.warn(`TornStats: Error fetching spy for ${playerId}:`, error.message);
                        tornStatsCache[playerId] = { error: true, checkedAt: Date.now() };
                    }
                });

                await Promise.all(promises);
                checkedCount += batch.length;

                // Update indicator
                if (isEnemy !== null) {
                    showTornStatsIndicator(isEnemy, `Checking TornStats... (${checkedCount}/${idsToFetch.length})`);
                }

                // Delay before next batch (except for last batch)
                if (i + batchSize < idsToFetch.length) {
                    await new Promise(resolve => setTimeout(resolve, delayMs));
                }
            }

            // Hide indicator
            if (isEnemy !== null) {
                hideTornStatsIndicator(isEnemy);
            }

            // Save cache to localStorage
            saveTornStatsCache();

            console.log(`TornStats spy data fetch complete. Found ${foundCount} players with spy data.`);
            return foundCount;
        }

        // Get battle stats for a player (prefers TornStats real data, falls back to estimate)
        function getBattleStats(member) {
            const playerId = member.id || member.player_id;
            const spyData = tornStatsCache[playerId];

            if (spyData && spyData.total && !spyData.noData && !spyData.error) {
                // We have real spy data from TornStats
                const spyDate = spyData.timestamp ? new Date(spyData.timestamp * 1000) : null;
                const daysAgo = spyDate ? Math.floor((Date.now() - spyDate) / (1000 * 60 * 60 * 24)) : null;

                return {
                    total: spyData.total,
                    strength: spyData.strength,
                    speed: spyData.speed,
                    defense: spyData.defense,
                    dexterity: spyData.dexterity,
                    isReal: true,
                    isEstimate: spyData.isEstimate || false,
                    spyDate: spyDate,
                    daysAgo: daysAgo
                };
            }

            // Fall back to estimated stats
            const estimated = estimateBattleStats(member);
            return {
                total: estimated.mid,
                low: estimated.low,
                high: estimated.high,
                isReal: false,
                isEstimate: true
            };
        }

        // Format large numbers
        function formatStatNumber(num) {
            if (num >= 1e12) return (num / 1e12).toFixed(1) + 'T';
            if (num >= 1e9) return (num / 1e9).toFixed(1) + 'B';
            if (num >= 1e6) return (num / 1e6).toFixed(1) + 'M';
            if (num >= 1e3) return (num / 1e3).toFixed(1) + 'K';
            return num.toString();
        }

        // Format stats with tooltip showing breakdown
        function formatStatsWithTooltip(battleStats) {
            if (!battleStats || !battleStats.total) {
                return '<span class="est-stats-value">N/A</span>';
            }

            const total = battleStats.total;
            const totalFormatted = formatStatNumber(total);
            const isReal = battleStats.isReal;
            const colorClass = isReal ? 'real-value' : 'est-value';

            let tooltip = '';
            if (isReal && battleStats.strength !== undefined) {
                // Real spy data - show individual stats
                tooltip = `STR: ${formatStatNumber(battleStats.strength)}&#10;DEF: ${formatStatNumber(battleStats.defense)}&#10;SPD: ${formatStatNumber(battleStats.speed)}&#10;DEX: ${formatStatNumber(battleStats.dexterity)}&#10;Total: ${formatStatNumber(total)}`;
                if (battleStats.daysAgo !== null) {
                    tooltip += `&#10;(Spied ${battleStats.daysAgo} day${battleStats.daysAgo !== 1 ? 's' : ''} ago)`;
                }
            } else if (battleStats.low !== undefined && battleStats.high !== undefined) {
                // Estimated stats - show range
                tooltip = `Estimated Total: ${formatStatNumber(total)}&#10;Range: ${formatStatNumber(battleStats.low)} - ${formatStatNumber(battleStats.high)}`;
            } else {
                tooltip = `Total: ${formatStatNumber(total)}`;
            }

            return `<span class="${colorClass} stats-tooltip" title="${tooltip}" style="cursor: help;">${totalFormatted}</span>`;
        }

        // Handle Enter key press on input fields
        function handleEnterKey(event) {
            if (event.key === 'Enter') {
                getFaction();
            }
        }

        // Get faction: Load user's faction and switch to My Faction tab
        async function getFaction() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const tornStatsApiKey = document.getElementById('tornStatsApiKey').value.trim();

            if (!apiKey) {
                showError('Please enter your API key first');
                return;
            }

            // Save API keys to localStorage
            localStorage.setItem('tornApiKey', apiKey);
            if (tornStatsApiKey) {
                localStorage.setItem('tornStatsApiKey', tornStatsApiKey);
            }

            showLoading();

            try {
                // Get the user's faction ID
                const userResponse = await fetch(`https://api.torn.com/user?selections=profile&key=${apiKey}`);
                const userData = await userResponse.json();

                if (userData.error) {
                    throw new Error(userData.error.error);
                }

                const myFactionId = userData.faction?.faction_id || userData.faction_id;

                if (!myFactionId) {
                    throw new Error('You are not in a faction');
                }

                // Store current user's ID
                currentUserId = userData.player_id?.toString() || null;

                // Save user's faction ID
                localStorage.setItem('tornUserFactionId', myFactionId.toString());

                // Load the user's faction data
                const factionUrl = `https://api.torn.com/faction/${myFactionId}?selections=basic&key=${apiKey}`;
                const factionResponse = await fetch(factionUrl);
                const factionBasicData = await factionResponse.json();

                if (factionBasicData.error) {
                    throw new Error(factionBasicData.error.error);
                }

                factionData = factionBasicData;

                // Extract member IDs and fetch their details with batching
                const memberIds = factionBasicData.members ? Object.keys(factionBasicData.members) : [];
                const memberDetails = await fetchMemberDetailsBatched(
                    memberIds,
                    apiKey,
                    'global',
                    'Loading faction members'
                );

                membersData = memberIds.map(id => {
                    const member = factionBasicData.members[id];
                    const details = memberDetails.find(d => d.id === id) || {};
                    return {
                        id,
                        ...member,
                        details: details || {}
                    };
                });

                // Also set userFactionData and userMembersData
                userFactionData = factionBasicData;
                userMembersData = [...membersData];

                // Render the dashboard
                renderDashboard();

                // Switch to My Faction tab
                switchToTab('my-faction');

                // Fetch TornStats spy data
                await fetchTornStatsSpyData(memberIds, false, false);

                // Re-render to show updated stats
                renderMembersTable(membersData);
            } catch (error) {
                showError(error.message);
            }
        }

        // Reset all saved data from localStorage
        function resetAllData(skipConfirm = false) {
            const confirmed = skipConfirm || confirm(
                'Are you sure you want to reset all data?\n\n' +
                'This will clear:\n' +
                '- All cached faction data\n' +
                '- TornStats spy cache\n' +
                '- Column settings and preferences\n' +
                '- All other saved configuration\n\n' +
                'Your API keys will be preserved.\n\n' +
                'This action cannot be undone.'
            );

            if (confirmed) {
                // Save API keys before reset
                const savedApiKey = localStorage.getItem('tornApiKey');
                const savedTornStatsKey = localStorage.getItem('tornStatsApiKey');
                const savedVersion = localStorage.getItem('tornDashboardVersion');

                // Get all localStorage keys that start with 'torn'
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('torn')) {
                        keysToRemove.push(key);
                    }
                }

                // Remove all torn-related keys
                keysToRemove.forEach(key => localStorage.removeItem(key));

                // Restore API keys and version
                if (savedApiKey) {
                    localStorage.setItem('tornApiKey', savedApiKey);
                }
                if (savedTornStatsKey) {
                    localStorage.setItem('tornStatsApiKey', savedTornStatsKey);
                }
                if (savedVersion) {
                    localStorage.setItem('tornDashboardVersion', savedVersion);
                }

                // Reset in-memory data
                factionData = null;
                membersData = [];
                enemyFactionData = null;
                enemyMembersData = [];
                userFactionData = null;
                userMembersData = [];
                spyFactionData = null;
                spyMembersData = [];
                tornStatsCache = {};

                // Clear the content area
                document.getElementById('content').innerHTML = '';

                alert('All data has been reset. Your API keys have been preserved. Click "Get Faction" to reload your data.');
            }
        }

        // Validate that cached enemy faction matches current ranked war opponent
        async function validateEnemyFaction() {
            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) return false;

            const cachedEnemyId = localStorage.getItem('tornEnemyFactionId');
            if (!cachedEnemyId) return false;

            try {
                // Get user's faction ID
                const myFactionId = localStorage.getItem('tornUserFactionId');
                if (!myFactionId) return false;

                // Get faction's ranked war info
                const factionResponse = await fetch(`https://api.torn.com/faction/${myFactionId}?selections=rankedwars&key=${apiKey}`);
                const factionRWData = await factionResponse.json();

                if (factionRWData.error) {
                    console.warn('Error fetching ranked wars:', factionRWData.error);
                    return false;
                }

                // Find active ranked war enemy
                const rankedWars = factionRWData.rankedwars || {};
                let currentEnemyId = null;
                const now = Math.floor(Date.now() / 1000);

                const sortedWarIds = Object.keys(rankedWars).sort((a, b) => parseInt(b) - parseInt(a));

                for (const warId of sortedWarIds) {
                    const war = rankedWars[warId];
                    const hasEnded = war.end && war.end > 0 && war.end < now;

                    if (!hasEnded && war.factions) {
                        for (const fId in war.factions) {
                            if (fId != myFactionId) {
                                currentEnemyId = fId;
                                break;
                            }
                        }
                    }
                    if (currentEnemyId) break;
                }

                // Check if cached enemy matches current enemy
                if (currentEnemyId && cachedEnemyId !== currentEnemyId) {
                    console.log(`Enemy faction mismatch: cached ${cachedEnemyId}, current ${currentEnemyId}`);
                    // Clear old enemy data
                    localStorage.removeItem('tornEnemyFactionId');
                    localStorage.removeItem('tornEnemyFactionData');
                    localStorage.removeItem('tornEnemyMembersData');
                    enemyFactionData = null;
                    enemyMembersData = [];

                    // Notify user
                    alert(`Your ranked war opponent has changed!\n\nOld enemy data has been cleared.\nPlease use "Load Enemy" to load your current opponent.`);
                    return false;
                }

                return true;
            } catch (error) {
                console.error('Error validating enemy faction:', error);
                return false;
            }
        }

        // Find and load enemy faction from current ranked war
        async function findEnemy() {
            const apiKey = document.getElementById('apiKey').value.trim();

            if (!apiKey) {
                showError('Please enter your API key first');
                return;
            }

            showLoading();

            try {
                // First, get the user's faction ID
                const userResponse = await fetch(`https://api.torn.com/user?selections=basic&key=${apiKey}`);
                const userData = await userResponse.json();

                if (userData.error) {
                    throw new Error(userData.error.error);
                }

                const myFactionId = userData.faction.faction_id;

                if (!myFactionId) {
                    throw new Error('You are not in a faction');
                }

                // Get faction's ranked war info
                const factionResponse = await fetch(`https://api.torn.com/faction/${myFactionId}?selections=rankedwars&key=${apiKey}`);
                const factionData = await factionResponse.json();

                if (factionData.error) {
                    throw new Error(factionData.error.error);
                }

                console.log('Ranked wars data:', factionData);

                // Find active ranked war
                const rankedWars = factionData.rankedwars || {};
                let enemyFactionId = null;

                for (const warId in rankedWars) {
                    const war = rankedWars[warId];
                    // Check if war is active (has factions but no winner yet or is ongoing)
                    if (war.factions) {
                        for (const factionId in war.factions) {
                            if (factionId != myFactionId) {
                                enemyFactionId = factionId;
                                break;
                            }
                        }
                    }
                    if (enemyFactionId) break;
                }

                if (!enemyFactionId) {
                    throw new Error('You are not currently matched for a Ranked War against another faction!');
                }

                // Load the enemy faction
                localStorage.setItem('tornFactionId', enemyFactionId);
                loadFactionData();

            } catch (error) {
                console.error('Error finding enemy:', error);
                showError(`Error finding enemy faction: ${error.message}`);
            }
        }

        // War Layout: Switch to War Portal and load both factions
        async function warLayout() {
            const apiKey = document.getElementById('apiKey').value.trim();

            if (!apiKey) {
                showError('Please enter your API key first');
                return;
            }

            showLoading();

            try {
                // First, get the user's faction ID
                const userResponse = await fetch(`https://api.torn.com/user?selections=profile&key=${apiKey}`);
                const userData = await userResponse.json();

                console.log('User API response:', userData);

                if (userData.error) {
                    throw new Error(userData.error.error);
                }

                // Check for faction ID in different possible locations
                const myFactionId = userData.faction?.faction_id || userData.faction_id;

                if (!myFactionId) {
                    console.log('Faction data not found. userData.faction:', userData.faction);
                    throw new Error('You are not in a faction');
                }

                // Save user's faction ID
                localStorage.setItem('tornUserFactionId', myFactionId.toString());

                // Get faction's ranked war info
                const factionResponse = await fetch(`https://api.torn.com/faction/${myFactionId}?selections=rankedwars&key=${apiKey}`);
                const factionRWData = await factionResponse.json();

                if (factionRWData.error) {
                    throw new Error(factionRWData.error.error);
                }

                // Find active ranked war enemy (war without an end time or end time in future)
                const rankedWars = factionRWData.rankedwars || {};
                let enemyFactionId = null;
                const now = Math.floor(Date.now() / 1000);

                console.log('Ranked wars data:', rankedWars);

                // Sort war IDs descending (newest first) to get the most recent war
                const sortedWarIds = Object.keys(rankedWars).sort((a, b) => parseInt(b) - parseInt(a));

                for (const warId of sortedWarIds) {
                    const war = rankedWars[warId];
                    console.log(`War ${warId}:`, war, `end: ${war.end}, now: ${now}, hasEnded: ${war.end && war.end > 0 && war.end < now}`);

                    // Check if war has ended (has an end time that's in the past)
                    const hasEnded = war.end && war.end > 0 && war.end < now;

                    if (!hasEnded && war.factions) {
                        for (const fId in war.factions) {
                            if (fId != myFactionId) {
                                enemyFactionId = fId;
                                console.log(`Found active enemy faction: ${fId} in war ${warId}`);
                                break;
                            }
                        }
                    }
                    if (enemyFactionId) break;
                }

                if (!enemyFactionId) {
                    throw new Error('You are not currently matched for a Ranked War against another faction!');
                }

                // Save enemy faction ID
                localStorage.setItem('tornEnemyFactionId', enemyFactionId);

                // First load the user's faction data to populate factionData and membersData
                // This is needed so renderDashboard() has data to work with
                const factionUrl = `https://api.torn.com/faction/${myFactionId}?selections=basic&key=${apiKey}`;
                const factionResponse2 = await fetch(factionUrl);
                const factionBasicData = await factionResponse2.json();

                if (factionBasicData.error) {
                    throw new Error(factionBasicData.error.error);
                }

                factionData = factionBasicData;

                // Extract member IDs and fetch their details with batching
                const memberIds = factionBasicData.members ? Object.keys(factionBasicData.members) : [];
                const memberDetails = await fetchMemberDetailsBatched(
                    memberIds,
                    apiKey,
                    'global',
                    'Loading your faction members'
                );

                membersData = memberIds.map(id => {
                    const member = factionBasicData.members[id];
                    const details = memberDetails.find(d => d.id === id) || {};
                    return {
                        id,
                        ...member,
                        details: details || {}
                    };
                });

                // Also set userFactionData and userMembersData
                userFactionData = factionBasicData;
                userMembersData = [...membersData];

                // Now render the dashboard (this creates the warPortalContainer)
                renderDashboard();

                // Switch to War Portal tab first so indicators can be shown
                switchToWarPortal();

                // Fetch TornStats spy data (show indicator on own faction list)
                await fetchTornStatsSpyData(memberIds, false, false);

                // Re-render to show updated stats
                renderWarPortal();

                // Load enemy faction into right side
                await loadEnemyFaction(enemyFactionId);

            } catch (error) {
                console.error('Error in war layout:', error);
                document.getElementById('content').innerHTML = '';
                showError(`Error setting up war layout: ${error.message}`);
            }
        }

        // Helper function to switch to War Portal tab programmatically
        function switchToWarPortal() {
            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            const portalBtn = document.querySelector('.tab-button[onclick*="war-portal"]');
            if (portalBtn) {
                portalBtn.classList.add('active');
            }

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const portalContent = document.getElementById('war-portal');
            if (portalContent) {
                portalContent.classList.add('active');
            }

            // Save active tab to localStorage
            localStorage.setItem('tornActiveTab', 'war-portal');
        }

        // Helper function to switch to any tab programmatically
        function switchToTab(tabId) {
            // Get current tab before switching
            const currentTab = localStorage.getItem('tornActiveTab');

            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            const tabBtn = document.querySelector(`.tab-button[onclick*="${tabId}"]`);
            if (tabBtn) {
                tabBtn.classList.add('active');
            }

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            const tabContent = document.getElementById(tabId);
            if (tabContent) {
                tabContent.classList.add('active');
            }

            // Save active tab to localStorage
            localStorage.setItem('tornActiveTab', tabId);

            // Handle faction info display and auto-refresh visibility based on tab
            const autoRefreshInfo = document.getElementById('autoRefreshInfo');
            const membersOverviewTitle = document.getElementById('membersOverviewTitle');

            if (tabId === 'faction-spying') {
                // Hide auto-refresh info on Faction Spying tab
                if (autoRefreshInfo) autoRefreshInfo.style.display = 'none';
                // Update title for spying
                if (membersOverviewTitle) membersOverviewTitle.textContent = 'Faction Spying';
                // Update faction info and stats if we have spy data
                if (spyFactionData) {
                    updateMainFactionInfoForSpy();
                    updateStatsSummaryForSpy();
                }
                // Refresh war history dropdown
                populateWarHistoryDropdown();
            } else if (tabId === 'war-portal') {
                // Show auto-refresh info on War Portal tab
                if (autoRefreshInfo) autoRefreshInfo.style.display = 'block';
                // Update title for war portal
                if (membersOverviewTitle) membersOverviewTitle.textContent = 'War Portal';
                // Update faction info and stats for war portal (both factions)
                updateMainFactionInfoForWarPortal();
                updateStatsSummaryForWarPortal();
                // Auto-load enemy faction if not loaded, or validate existing
                if (enemyMembersData.length === 0) {
                    autoLoadEnemyFaction();
                } else {
                    validateEnemyFaction();
                }
            } else {
                // Show auto-refresh info on other tabs
                if (autoRefreshInfo) autoRefreshInfo.style.display = 'block';
                // Restore user's faction info when switching away from faction-spying or war-portal
                if (currentTab === 'faction-spying' || currentTab === 'war-portal') {
                    restoreUserFactionInfo();
                    restoreStatsSummaryForUser();
                    if (membersOverviewTitle && factionData) {
                        membersOverviewTitle.textContent = `Members Overview: ${factionData.name || 'Unknown Faction'}`;
                    }
                }
            }
        }

        // Load user faction specifically for War Layout (includes TornStats)
        async function loadUserFactionForWarLayout(factionId, apiKey) {
            const ownList = document.getElementById('ownMembersList');

            try {
                // Load user's faction data
                if (ownList) {
                    ownList.innerHTML = '<div class="portal-no-data">Loading your faction info...</div>';
                }

                const factionUrl = `https://api.torn.com/faction/${factionId}?selections=basic&key=${apiKey}`;
                const response = await fetch(factionUrl);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.error);
                }

                userFactionData = data;

                // Extract member IDs from the faction data
                const memberIds = data.members ? Object.keys(data.members) : [];

                // Fetch details for all members with batching
                const memberDetails = await fetchMemberDetailsBatched(
                    memberIds,
                    apiKey,
                    ownList,
                    'Loading your faction members'
                );

                // Merge member details with basic faction member data
                userMembersData = memberIds.map(id => {
                    const member = data.members[id];
                    const details = memberDetails.find(d => d.id === id) || {};
                    return {
                        id,
                        ...member,
                        details: details || {}
                    };
                });

                // Fetch TornStats spy data for own faction members (if API key provided)
                await fetchTornStatsSpyData(memberIds, false, false);

                // Save user faction data to localStorage for restore on reload
                saveUserFactionData();

                // Update the War Portal display
                renderWarPortal();

            } catch (error) {
                console.error('Error loading user faction for war layout:', error);
            }
        }

        // Save user faction data to localStorage
        function saveUserFactionData() {
            if (userFactionData && userMembersData.length > 0) {
                try {
                    localStorage.setItem('tornUserFactionData', JSON.stringify(userFactionData));
                    localStorage.setItem('tornUserMembersData', JSON.stringify(userMembersData));
                    console.log('User faction data saved to localStorage');
                } catch (e) {
                    console.warn('Failed to save user faction data:', e);
                }
            }
        }

        // Find enemy for War Portal (loads into enemy column instead of main view)
        async function findEnemyForPortal() {
            const apiKey = document.getElementById('apiKey').value.trim();

            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            try {
                // First, get the user's faction ID
                const userResponse = await fetch(`https://api.torn.com/user?selections=basic&key=${apiKey}`);
                const userData = await userResponse.json();

                if (userData.error) {
                    throw new Error(userData.error.error);
                }

                const myFactionId = userData.faction.faction_id;

                if (!myFactionId) {
                    throw new Error('You are not in a faction');
                }

                // Get faction's ranked war info
                const factionResponse = await fetch(`https://api.torn.com/faction/${myFactionId}?selections=rankedwars&key=${apiKey}`);
                const factionRWData = await factionResponse.json();

                if (factionRWData.error) {
                    throw new Error(factionRWData.error.error);
                }

                // Find active ranked war
                const rankedWars = factionRWData.rankedwars || {};
                let enemyFactionId = null;

                for (const warId in rankedWars) {
                    const war = rankedWars[warId];
                    if (war.factions) {
                        for (const fId in war.factions) {
                            if (fId != myFactionId) {
                                enemyFactionId = fId;
                                break;
                            }
                        }
                    }
                    if (enemyFactionId) break;
                }

                if (!enemyFactionId) {
                    throw new Error('You are not currently matched for a Ranked War against another faction!');
                }

                // Update the portal enemy input and load enemy
                const portalEnemyInput = document.getElementById('portalEnemyFactionId');
                if (portalEnemyInput) {
                    portalEnemyInput.value = enemyFactionId;
                }
                loadEnemyFaction(enemyFactionId);

            } catch (error) {
                console.error('Error finding enemy:', error);
                alert(`Error finding enemy faction: ${error.message}`);
            }
        }

        // Automatically load enemy faction when switching to War Portal
        async function autoLoadEnemyFaction() {
            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) return;

            // Show loading message
            const enemyList = document.getElementById('enemyMembersList');
            if (enemyList) {
                enemyList.innerHTML = '<div class="portal-no-data">Searching for ranked war enemy...</div>';
            }

            try {
                const myFactionId = localStorage.getItem('tornUserFactionId');
                if (!myFactionId) {
                    throw new Error('NO_FACTION');
                }

                // Get faction's ranked war info
                const factionResponse = await fetch(`https://api.torn.com/faction/${myFactionId}?selections=rankedwars&key=${apiKey}`);
                const factionRWData = await factionResponse.json();

                if (factionRWData.error) {
                    throw new Error(factionRWData.error.error);
                }

                // Find active ranked war enemy
                const rankedWars = factionRWData.rankedwars || {};
                let enemyFactionId = null;
                const now = Math.floor(Date.now() / 1000);

                const sortedWarIds = Object.keys(rankedWars).sort((a, b) => parseInt(b) - parseInt(a));

                for (const warId of sortedWarIds) {
                    const war = rankedWars[warId];
                    const hasEnded = war.end && war.end > 0 && war.end < now;

                    if (!hasEnded && war.factions) {
                        for (const fId in war.factions) {
                            if (fId != myFactionId) {
                                enemyFactionId = fId;
                                // Capture war scores
                                currentWarScores.ownScore = war.factions[myFactionId]?.score || 0;
                                currentWarScores.enemyScore = war.factions[fId]?.score || 0;
                                currentWarScores.isActiveWar = true;
                                break;
                            }
                        }
                    }
                    if (enemyFactionId) break;
                }

                if (!enemyFactionId) {
                    currentWarScores.isActiveWar = false;
                    throw new Error('NO_RANKED_WAR');
                }

                // Load the enemy faction
                await loadEnemyFaction(enemyFactionId);

            } catch (error) {
                console.error('Error auto-loading enemy faction:', error);
                if (enemyList) {
                    if (error.message === 'NO_RANKED_WAR') {
                        enemyList.innerHTML = `<div class="portal-no-data" style="padding: 40px;">
                            <div style="font-size: 18px; font-weight: bold; color: #dc3545; margin-bottom: 15px;">
                                ‚ö†Ô∏è NOT CURRENTLY IN A RANKED WAR
                            </div>
                            <p style="color: #666; margin-bottom: 15px;">Your faction is not currently matched against any opponent in a Ranked War.</p>
                            <p style="font-size: 12px; color: #888;">If you want to view another faction, you can enter their ID below:</p>
                            <div style="display: flex; gap: 8px; margin-top: 10px; justify-content: center;">
                                <input type="text" id="manualEnemyId" placeholder="Faction ID" style="padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; width: 100px;">
                                <button class="btn" onclick="loadManualEnemy()">Load</button>
                            </div>
                        </div>`;
                    } else if (error.message === 'NO_FACTION') {
                        enemyList.innerHTML = `<div class="portal-no-data" style="padding: 40px;">
                            <p style="color: #666;">Please load your faction first using the "Get Faction" button.</p>
                        </div>`;
                    } else {
                        enemyList.innerHTML = `<div class="portal-no-data" style="padding: 40px;">
                            <p style="color: #dc3545;">Error: ${error.message}</p>
                            <button class="btn" onclick="autoLoadEnemyFaction()" style="margin-top: 10px;">Try Again</button>
                        </div>`;
                    }
                }
            }
        }

        // Find and load enemy faction from ranked war for War Portal (button version)
        async function findAndLoadEnemy() {
            const apiKey = document.getElementById('apiKey').value.trim();

            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            // Show loading message
            const enemyList = document.getElementById('enemyMembersList');
            if (enemyList) {
                enemyList.innerHTML = '<div class="portal-no-data">Searching for ranked war enemy...</div>';
            }

            try {
                // Get user's faction ID
                const myFactionId = localStorage.getItem('tornUserFactionId');
                if (!myFactionId) {
                    throw new Error('Your faction ID is not set. Please reload your faction first.');
                }

                // Get faction's ranked war info
                const factionResponse = await fetch(`https://api.torn.com/faction/${myFactionId}?selections=rankedwars&key=${apiKey}`);
                const factionRWData = await factionResponse.json();

                if (factionRWData.error) {
                    throw new Error(factionRWData.error.error);
                }

                // Find active ranked war enemy
                const rankedWars = factionRWData.rankedwars || {};
                let enemyFactionId = null;
                const now = Math.floor(Date.now() / 1000);

                const sortedWarIds = Object.keys(rankedWars).sort((a, b) => parseInt(b) - parseInt(a));

                for (const warId of sortedWarIds) {
                    const war = rankedWars[warId];
                    const hasEnded = war.end && war.end > 0 && war.end < now;

                    if (!hasEnded && war.factions) {
                        for (const fId in war.factions) {
                            if (fId != myFactionId) {
                                enemyFactionId = fId;
                                break;
                            }
                        }
                    }
                    if (enemyFactionId) break;
                }

                if (!enemyFactionId) {
                    throw new Error('You are not currently matched for a Ranked War against another faction!');
                }

                // Load the enemy faction
                await loadEnemyFaction(enemyFactionId);

            } catch (error) {
                console.error('Error finding enemy faction:', error);
                if (enemyList) {
                    enemyList.innerHTML = `<div class="portal-no-data" style="color: #dc3545;">
                        <p>${error.message}</p>
                        <button class="btn" onclick="findAndLoadEnemy()" style="margin-top: 10px;">Try Again</button>
                        <p style="font-size: 11px; color: #888; margin-top: 8px;">Or enter a faction ID manually:</p>
                        <div style="display: flex; gap: 8px; margin-top: 5px; justify-content: center;">
                            <input type="text" id="manualEnemyId" placeholder="Faction ID" style="padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; width: 100px;">
                            <button class="btn" onclick="loadManualEnemy()">Load</button>
                        </div>
                    </div>`;
                }
            }
        }

        // Load enemy faction from manual input
        function loadManualEnemy() {
            const enemyId = document.getElementById('manualEnemyId')?.value.trim();
            if (!enemyId) {
                alert('Please enter a faction ID');
                return;
            }
            loadEnemyFaction(enemyId);
        }

        // Load enemy faction data for War Portal
        async function loadEnemyFaction(enemyId) {
            const apiKey = document.getElementById('apiKey').value.trim();
            const enemyFactionId = enemyId || document.getElementById('portalEnemyFactionId').value.trim();

            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            if (!enemyFactionId) {
                alert('Please enter an enemy faction ID');
                return;
            }

            // Save enemy faction ID
            localStorage.setItem('tornEnemyFactionId', enemyFactionId);

            // Show loading in enemy column
            const enemyList = document.getElementById('enemyMembersList');

            try {
                // Load enemy faction basic info
                if (enemyList) {
                    enemyList.innerHTML = '<div class="portal-no-data">Loading enemy faction info...</div>';
                }

                const factionUrl = `https://api.torn.com/faction/${enemyFactionId}?selections=basic&key=${apiKey}`;
                const response = await fetch(factionUrl);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.error);
                }

                enemyFactionData = data;

                // Extract member IDs from the faction data
                const memberIds = data.members ? Object.keys(data.members) : [];

                // Fetch details for all enemy members with batching and progress indicator
                const memberDetails = await fetchMemberDetailsBatched(
                    memberIds,
                    apiKey,
                    enemyList,
                    'Loading enemy members'
                );

                // Merge member details with basic faction member data
                enemyMembersData = memberIds.map(id => {
                    const member = data.members[id];
                    const details = memberDetails.find(d => d.id === id) || {};
                    return {
                        id,
                        ...member,
                        details: details || {}
                    };
                });

                // Fetch TornStats spy data for enemy members (if API key provided)
                await fetchTornStatsSpyData(memberIds, false, true);

                // Save enemy faction data to localStorage for restore on reload
                saveEnemyFactionData();

                // Update the War Portal display
                renderWarPortal();

                // Start/restart lightweight refresh for status updates
                if (apiKey) {
                    startLightweightRefresh(apiKey);
                }

            } catch (error) {
                console.error('Error loading enemy faction:', error);
                const enemyList = document.getElementById('enemyMembersList');
                if (enemyList) {
                    enemyList.innerHTML = `<div class="portal-no-data">Error: ${error.message}</div>`;
                }
            }
        }

        // Load user's own faction data for War Portal
        async function loadUserFaction() {
            const apiKey = document.getElementById('apiKey').value.trim();

            if (!apiKey) {
                return;
            }

            // Show loading in own members column
            const ownList = document.getElementById('ownMembersList');

            try {
                // First, get the user's faction ID
                if (ownList) {
                    ownList.innerHTML = '<div class="portal-no-data">Loading your faction info...</div>';
                }

                const userResponse = await fetch(`https://api.torn.com/user?selections=basic&key=${apiKey}`);
                const userData = await userResponse.json();

                if (userData.error) {
                    throw new Error(userData.error.error);
                }

                const myFactionId = userData.faction.faction_id;

                if (!myFactionId) {
                    console.log('User is not in a faction');
                    return;
                }

                // Save user's faction ID
                localStorage.setItem('tornUserFactionId', myFactionId.toString());

                // Load user's faction data
                const factionUrl = `https://api.torn.com/faction/${myFactionId}?selections=basic&key=${apiKey}`;
                const response = await fetch(factionUrl);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.error);
                }

                userFactionData = data;

                // Extract member IDs from the faction data
                const memberIds = data.members ? Object.keys(data.members) : [];

                // Fetch details for all members with batching and progress indicator
                const memberDetails = await fetchMemberDetailsBatched(
                    memberIds,
                    apiKey,
                    ownList,
                    'Loading your faction members'
                );

                // Merge member details with basic faction member data
                userMembersData = memberIds.map(id => {
                    const member = data.members[id];
                    const details = memberDetails.find(d => d.id === id) || {};
                    return {
                        id,
                        ...member,
                        details: details || {}
                    };
                });

                // Fetch TornStats spy data for own faction members (if API key provided)
                await fetchTornStatsSpyData(memberIds, false, false);

                // Update the War Portal display
                renderWarPortal();

                // Start/restart lightweight refresh for status updates
                startLightweightRefresh(apiKey);

            } catch (error) {
                console.error('Error loading user faction:', error);
            }
        }

        // Force update TornStats data for own faction
        async function forceUpdateOwnTornStats() {
            // Use userMembersData if available, otherwise fall back to membersData
            const ownMembers = userMembersData.length > 0 ? userMembersData : membersData;

            if (!ownMembers || ownMembers.length === 0) {
                alert('Please load your faction data first');
                return;
            }

            const tornStatsApiKey = document.getElementById('tornStatsApiKey').value.trim();
            if (!tornStatsApiKey) {
                alert('Please enter your TornStats API key first');
                return;
            }

            const memberIds = ownMembers.map(m => m.id);
            const btn = document.getElementById('ownForceUpdateBtn');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Updating...';
            }

            try {
                await fetchTornStatsSpyData(memberIds, true, false);
                renderWarPortal();
            } catch (e) {
                alert('Error updating TornStats: ' + e.message);
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Force Update';
                }
            }
        }

        // Force update TornStats data for enemy faction
        async function forceUpdateEnemyTornStats() {
            if (!enemyMembersData || enemyMembersData.length === 0) {
                alert('Please load enemy faction data first');
                return;
            }

            const tornStatsApiKey = document.getElementById('tornStatsApiKey').value.trim();
            if (!tornStatsApiKey) {
                alert('Please enter your TornStats API key first');
                return;
            }

            const memberIds = enemyMembersData.map(m => m.id);
            const btn = document.getElementById('enemyForceUpdateBtn');
            if (btn) {
                btn.disabled = true;
                btn.textContent = 'Updating...';
            }

            try {
                await fetchTornStatsSpyData(memberIds, true, true);
                renderWarPortal();
            } catch (e) {
                alert('Error updating TornStats: ' + e.message);
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = 'Force Update';
                }
            }
        }

        // Load faction for Faction Spying tab
        async function loadSpyFaction() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const spyFactionId = document.getElementById('spyFactionId').value.trim();

            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            if (!spyFactionId) {
                alert('Please enter a Faction ID');
                return;
            }

            const container = document.getElementById('spyFactionContainer');
            try {
                // Load faction basic info
                if (container) {
                    container.innerHTML = '<div style="padding: 40px; text-align: center; color: #666;"><p>Loading faction info...</p></div>';
                }

                const factionUrl = `https://api.torn.com/faction/${spyFactionId}?selections=basic&key=${apiKey}`;
                const response = await fetch(factionUrl);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.error);
                }

                spyFactionData = data;

                // Extract member IDs
                const memberIds = data.members ? Object.keys(data.members) : [];

                // Fetch details for all members with batching and progress indicator
                const memberDetails = await fetchMemberDetailsBatched(
                    memberIds,
                    apiKey,
                    container,
                    'Loading faction members'
                );

                // Merge member details with basic faction member data
                spyMembersData = memberIds.map(id => {
                    const member = data.members[id];
                    const details = memberDetails.find(d => d.id === id) || {};
                    return {
                        id,
                        ...member,
                        details: details || {}
                    };
                });

                // Fetch TornStats spy data
                await fetchTornStatsSpyData(memberIds);

                // Save last spied faction ID
                localStorage.setItem('tornSpyFactionId', spyFactionId);

                // Render the spy faction view
                renderSpyFaction();

            } catch (error) {
                console.error('Error loading spy faction:', error);
                if (container) {
                    container.innerHTML = `<div style="padding: 40px; text-align: center; color: #c33;"><p>Error: ${error.message}</p></div>`;
                }
            }
        }

        // Render the Faction Spying tab content
        function renderSpyFaction() {
            const container = document.getElementById('spyFactionContainer');
            if (!container || !spyFactionData) return;

            // Update the main faction info area with spy faction data
            updateMainFactionInfoForSpy();

            // Hide auto-refresh info and update title
            const autoRefreshInfo = document.getElementById('autoRefreshInfo');
            const membersOverviewTitle = document.getElementById('membersOverviewTitle');
            if (autoRefreshInfo) autoRefreshInfo.style.display = 'none';
            if (membersOverviewTitle) membersOverviewTitle.textContent = 'Faction Spying';

            // Update stats summary with spy faction stats
            updateStatsSummaryForSpy();

            // Render only the filters and table in the spy container
            container.innerHTML = `
                <div class="filters" style="padding: 10px 15px;">
                    <input type="text" id="spySearchInput" placeholder="Search members..." onkeyup="filterSpyMembers()">
                    <select id="spyStatusFilter" onchange="filterSpyMembers()">
                        <option value="">All Status</option>
                        <option value="Online">Online</option>
                        <option value="Idle">Idle</option>
                        <option value="Offline">Offline</option>
                    </select>
                </div>
                <div id="spyMembersTableContainer"></div>
            `;

            filterSpyMembers();
        }

        // Update stats summary for spy faction
        function updateStatsSummaryForSpy() {
            const statsSummary = document.getElementById('statsSummary');
            if (!statsSummary || !spyFactionData) return;

            // Make sure it's visible (may have been hidden by War Portal)
            statsSummary.style.display = '';

            const onlineCount = spyMembersData.filter(m => m.last_action?.status === 'Online').length;
            const idleCount = spyMembersData.filter(m => m.last_action?.status === 'Idle').length;
            const offlineCount = spyMembersData.filter(m => m.last_action?.status === 'Offline').length;
            const totalLevel = spyMembersData.reduce((sum, m) => sum + (m.level || 0), 0);
            const avgLevel = spyMembersData.length > 0 ? Math.round(totalLevel / spyMembersData.length) : 0;

            statsSummary.innerHTML = `
                <div class="stat-card" style="background: linear-gradient(135deg, #1565c0 0%, #0d47a1 100%);">
                    <h3>Online</h3>
                    <div class="value">${onlineCount}</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, #1565c0 0%, #0d47a1 100%);">
                    <h3>Idle</h3>
                    <div class="value">${idleCount}</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, #1565c0 0%, #0d47a1 100%);">
                    <h3>Offline</h3>
                    <div class="value">${offlineCount}</div>
                </div>
                <div class="stat-card" style="background: linear-gradient(135deg, #1565c0 0%, #0d47a1 100%);">
                    <h3>Average Level</h3>
                    <div class="value">${avgLevel}</div>
                </div>
            `;
        }

        // Restore stats summary for user's faction
        function restoreStatsSummaryForUser() {
            const statsSummary = document.getElementById('statsSummary');
            if (!statsSummary || !membersData.length) return;

            // Make sure it's visible (may have been hidden by War Portal)
            statsSummary.style.display = '';

            const onlineCount = membersData.filter(m => m.last_action?.status === 'Online').length;
            const idleCount = membersData.filter(m => m.last_action?.status === 'Idle').length;
            const offlineCount = membersData.filter(m => m.last_action?.status === 'Offline').length;
            const totalLevel = membersData.reduce((sum, m) => sum + (m.level || 0), 0);
            const avgLevel = membersData.length > 0 ? Math.round(totalLevel / membersData.length) : 0;

            statsSummary.innerHTML = `
                <div class="stat-card">
                    <h3>Online</h3>
                    <div class="value">${onlineCount}</div>
                </div>
                <div class="stat-card">
                    <h3>Idle</h3>
                    <div class="value">${idleCount}</div>
                </div>
                <div class="stat-card">
                    <h3>Offline</h3>
                    <div class="value">${offlineCount}</div>
                </div>
                <div class="stat-card">
                    <h3>Average Level</h3>
                    <div class="value">${avgLevel}</div>
                </div>
            `;
        }

        // Update main faction info area for War Portal - hide it since info is in the War Portal panel
        function updateMainFactionInfoForWarPortal() {
            const mainFactionInfo = document.getElementById('mainFactionInfo');
            if (!mainFactionInfo) return;
            // Hide the main faction info area - all info is shown in the War Portal comparison panel
            mainFactionInfo.style.display = 'none';
        }

        // Update stats summary for War Portal - hide it since info is in the War Portal panel
        function updateStatsSummaryForWarPortal() {
            const statsSummary = document.getElementById('statsSummary');
            if (!statsSummary) return;
            // Hide the stats summary - all info is shown in the War Portal comparison panel
            statsSummary.style.display = 'none';
        }

        // Get spy faction leader name
        function getSpyLeaderName() {
            if (!spyFactionData || !spyFactionData.leader) return 'Unknown';
            const leader = spyMembersData.find(m => m.id == spyFactionData.leader);
            return leader ? leader.name : 'Unknown';
        }

        // Restore user's faction info to the main display
        function restoreUserFactionInfo() {
            const mainFactionInfo = document.getElementById('mainFactionInfo');
            if (!mainFactionInfo || !factionData) return;

            // Make sure it's visible (may have been hidden by War Portal)
            mainFactionInfo.style.display = '';

            mainFactionInfo.innerHTML = `
                <h2>${factionData.name || 'Faction Information'}</h2>
                <div class="info-grid">
                    <div class="info-item">
                        <label>Faction ID</label>
                        <value>${factionData.ID || 'N/A'}</value>
                    </div>
                    <div class="info-item">
                        <label>Members</label>
                        <value>${membersData.length}</value>
                    </div>
                    <div class="info-item">
                        <label>Respect</label>
                        <value>${(factionData.respect || 0).toLocaleString()}</value>
                    </div>
                    <div class="info-item">
                        <label>Age</label>
                        <value>${factionData.age || 'N/A'} days</value>
                    </div>
                    <div class="info-item">
                        <label>Capacity</label>
                        <value>${factionData.capacity || 'N/A'}</value>
                    </div>
                    <div class="info-item">
                        <label>Leader</label>
                        <value>${factionData.leader ? `<a href="https://www.torn.com/profiles.php?XID=${factionData.leader}" target="_blank" style="color: #667eea; text-decoration: none;">${getLeaderName()}</a>` : 'N/A'}</value>
                    </div>
                </div>
            `;
        }

        // Update main faction info area for spy faction
        function updateMainFactionInfoForSpy() {
            const mainFactionInfo = document.getElementById('mainFactionInfo');
            if (!mainFactionInfo || !spyFactionData) return;

            // Make sure it's visible (may have been hidden by War Portal)
            mainFactionInfo.style.display = '';

            mainFactionInfo.innerHTML = `
                <h2 style="color: #1565c0;">${spyFactionData.name || 'Faction Information'} <span style="font-size: 12px; font-weight: normal; color: #666;">- Spying</span></h2>
                <div class="info-grid">
                    <div class="info-item">
                        <label>Faction ID</label>
                        <value>${spyFactionData.ID || 'N/A'}</value>
                    </div>
                    <div class="info-item">
                        <label>Members</label>
                        <value>${spyMembersData.length}</value>
                    </div>
                    <div class="info-item">
                        <label>Respect</label>
                        <value>${(spyFactionData.respect || 0).toLocaleString()}</value>
                    </div>
                    <div class="info-item">
                        <label>Age</label>
                        <value>${spyFactionData.age || 'N/A'} days</value>
                    </div>
                    <div class="info-item">
                        <label>Capacity</label>
                        <value>${spyFactionData.capacity || 'N/A'}</value>
                    </div>
                    <div class="info-item">
                        <label>Leader</label>
                        <value>${spyFactionData.leader ? `<a href="https://www.torn.com/profiles.php?XID=${spyFactionData.leader}" target="_blank" style="color: #667eea; text-decoration: none;">${getSpyLeaderName()}</a>` : 'N/A'}</value>
                    </div>
                </div>
            `;
        }

        // Filter spy faction members
        function filterSpyMembers() {
            const searchTerm = document.getElementById('spySearchInput')?.value.toLowerCase() || '';
            const statusFilter = document.getElementById('spyStatusFilter')?.value || '';

            let filtered = [...spyMembersData];

            if (searchTerm) {
                filtered = filtered.filter(m => m.name?.toLowerCase().includes(searchTerm));
            }

            if (statusFilter) {
                filtered = filtered.filter(m => m.last_action?.status === statusFilter);
            }

            // Sort the filtered data
            filtered = sortSpyMembersData(filtered);

            renderSpyMembersTable(filtered);
        }

        // Sort spy members data based on current sort column and direction
        function sortSpyMembersData(members) {
            return members.sort((a, b) => {
                let aVal, bVal;

                switch (spyFactionSortColumn) {
                    case 'name':
                        aVal = a.name?.toLowerCase() || '';
                        bVal = b.name?.toLowerCase() || '';
                        break;
                    case 'est_stats':
                        aVal = estimateBattleStats(a).mid || 0;
                        bVal = estimateBattleStats(b).mid || 0;
                        break;
                    case 'level':
                        aVal = a.level || 0;
                        bVal = b.level || 0;
                        break;
                    case 'age':
                        aVal = a.details?.age || 0;
                        bVal = b.details?.age || 0;
                        break;
                    case 'life':
                        aVal = a.details?.life?.current || 0;
                        bVal = b.details?.life?.current || 0;
                        break;
                    case 'elo':
                        aVal = a.details?.personalstats?.elo || a.details?.personalstats?.rankedwarrating || 0;
                        bVal = b.details?.personalstats?.elo || b.details?.personalstats?.rankedwarrating || 0;
                        break;
                    case 'best_damage':
                        aVal = a.details?.personalstats?.bestdamage || a.details?.personalstats?.highestbeaten || 0;
                        bVal = b.details?.personalstats?.bestdamage || b.details?.personalstats?.highestbeaten || 0;
                        break;
                    case 'critical_hits':
                        const aHits = a.details?.personalstats?.attackhits || 0;
                        const aCrits = a.details?.personalstats?.attackcriticalhits || 0;
                        aVal = aHits > 0 ? (aCrits / aHits) * 100 : 0;
                        const bHits = b.details?.personalstats?.attackhits || 0;
                        const bCrits = b.details?.personalstats?.attackcriticalhits || 0;
                        bVal = bHits > 0 ? (bCrits / bHits) * 100 : 0;
                        break;
                    case 'rw_hits':
                        aVal = a.details?.personalstats?.rankedwarhits || 0;
                        bVal = b.details?.personalstats?.rankedwarhits || 0;
                        break;
                    case 'xanax':
                        aVal = a.details?.personalstats?.xantaken || 0;
                        bVal = b.details?.personalstats?.xantaken || 0;
                        break;
                    case 'vicodin':
                        aVal = a.details?.personalstats?.victaken || 0;
                        bVal = b.details?.personalstats?.victaken || 0;
                        break;
                    case 'overdosed':
                        aVal = a.details?.personalstats?.overdosed || 0;
                        bVal = b.details?.personalstats?.overdosed || 0;
                        break;
                    case 'refills':
                        aVal = a.details?.personalstats?.energydrinkused || a.details?.personalstats?.refills || 0;
                        bVal = b.details?.personalstats?.energydrinkused || b.details?.personalstats?.refills || 0;
                        break;
                    case 'location':
                        aVal = a.details?.status?.description || a.details?.status?.state || '';
                        bVal = b.details?.status?.description || b.details?.status?.state || '';
                        break;
                    case 'str':
                        aVal = getBattleStats(a).strength || 0;
                        bVal = getBattleStats(b).strength || 0;
                        break;
                    case 'def':
                        aVal = getBattleStats(a).defense || 0;
                        bVal = getBattleStats(b).defense || 0;
                        break;
                    case 'spd':
                        aVal = getBattleStats(a).speed || 0;
                        bVal = getBattleStats(b).speed || 0;
                        break;
                    case 'dex':
                        aVal = getBattleStats(a).dexterity || 0;
                        bVal = getBattleStats(b).dexterity || 0;
                        break;
                    default:
                        aVal = 0;
                        bVal = 0;
                }

                if (typeof aVal === 'string') {
                    const comparison = aVal.localeCompare(bVal);
                    return spyFactionSortDirection === 'asc' ? comparison : -comparison;
                }
                return spyFactionSortDirection === 'asc' ? aVal - bVal : bVal - aVal;
            });
        }

        // Render spy members table (same format as My Faction table)
        function renderSpyMembersTable(members) {
            const container = document.getElementById('spyMembersTableContainer');
            if (!container) return;

            const getSortClass = (column) => {
                if (spyFactionSortColumn !== column) return 'sortable';
                return spyFactionSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc';
            };

            // Build columns list - show est_stats followed by TornStats columns (str, def, spd, dex)
            const estStatsIndex = spyFactionColumnOrder.indexOf('est_stats');
            let columnsToShow;
            if (estStatsIndex !== -1) {
                // Insert TornStats columns right after est_stats
                columnsToShow = [
                    ...spyFactionColumnOrder.slice(0, estStatsIndex + 1),
                    ...tornStatsColumns,
                    ...spyFactionColumnOrder.slice(estStatsIndex + 1)
                ];
            } else {
                // If no est_stats column, just append TornStats at the end
                columnsToShow = [...spyFactionColumnOrder, ...tornStatsColumns];
            }

            // Combined column definitions
            const allColumnDefs = { ...warPlanningColumnDefs, ...tornStatsColumnDefs };
            const defaultWidths = { ...defaultWPColumnWidths, str: 70, def: 70, spd: 70, dex: 70 };

            // Generate header row based on column order with resize handles
            const headerCells = columnsToShow.map((col, index) => {
                const def = allColumnDefs[col];
                if (!def) return '';
                const width = spyColumnWidths[col] || defaultWidths[col] || 70;
                const isLast = index === columnsToShow.length - 1;
                const resizeHandle = isLast ? '' : `<span class="wp-resize-handle" onmousedown="startSpyColumnResize(event, '${col}')"></span>`;
                return `<th class="${getSortClass(def.sortKey)}"
                    onclick="sortSpyMembers('${def.sortKey}')"
                    draggable="true"
                    data-column="${col}"
                    style="width: ${width}px; min-width: ${width}px;">${def.label}${resizeHandle}</th>`;
            }).join('');

            // Generate body rows
            const bodyRows = members.map(member => {
                const stats = member.details?.personalstats || {};
                const profile = member.details || member;
                const battleStats = getBattleStats(member);

                // Pre-calculate all member data
                const memberData = {
                    age: profile.age || 'N/A',
                    life: profile.life ? `${profile.life.current}/${profile.life.maximum}` : 'N/A',
                    elo: stats.elo || stats.rankedwarrating || 'N/A',
                    bestDamage: stats.bestdamage || stats.highestbeaten || 'N/A',
                    criticalPct: (stats.attackhits || 0) > 0 ? (((stats.attackcriticalhits || 0) / stats.attackhits) * 100).toFixed(2) : '0.00',
                    rwHits: stats.rankedwarhits || 'N/A',
                    xanax: stats.xantaken || 'N/A',
                    vicodin: stats.victaken || 'N/A',
                    overdosed: stats.overdosed || 'N/A',
                    refills: stats.energydrinkused || stats.refills || 'N/A',
                    estStats: estimateBattleStats(member),
                    battleStats: battleStats,
                    statusIndicatorClass: member.last_action?.status === 'Online' ? 'online' :
                                         member.last_action?.status === 'Idle' ? 'idle' : 'offline',
                    locationText: 'Unknown',
                    locationClass: ''
                };

                // Get location/status information
                const userStatus = profile.status || {};
                if (userStatus.description) {
                    memberData.locationText = userStatus.description;
                } else if (userStatus.state) {
                    memberData.locationText = userStatus.state;
                }

                // Format travel status to be shorter
                const flyingToMatch = memberData.locationText.match(/Flying to (.+)/i);
                const returningMatch = memberData.locationText.match(/Returning to (.+)/i);
                const travelingToMatch = memberData.locationText.match(/Traveling to (.+)/i);
                const inCountryMatch = memberData.locationText.match(/In (.+)/i);

                if (flyingToMatch) {
                    memberData.locationText = 'Outbound: ' + flyingToMatch[1];
                } else if (travelingToMatch) {
                    memberData.locationText = 'Outbound: ' + travelingToMatch[1];
                } else if (returningMatch) {
                    memberData.locationText = 'Inbound: ' + returningMatch[1];
                } else if (inCountryMatch && !memberData.locationText.toLowerCase().includes('hospital') && !memberData.locationText.toLowerCase().includes('jail')) {
                    memberData.locationText = 'Abroad: ' + inCountryMatch[1];
                }

                // Add color coding for different states
                if (memberData.locationText.toLowerCase().includes('okay') || memberData.locationText.toLowerCase().includes('torn')) {
                    memberData.locationClass = 'status-online';
                } else if (memberData.locationText.toLowerCase().includes('hospital') || memberData.locationText.toLowerCase().includes('jail')) {
                    memberData.locationClass = 'status-offline';
                } else if (memberData.locationText.toLowerCase().includes('outbound') || memberData.locationText.toLowerCase().includes('inbound') || memberData.locationText.toLowerCase().includes('abroad')) {
                    memberData.locationClass = 'status-idle';
                }

                // Generate cells in column order using the same function as My Faction
                const cells = columnsToShow.map(col => getSpyCellContent(col, member, memberData)).join('');

                return `<tr>${cells}</tr>`;
            }).join('');

            container.innerHTML = `
                <table class="members-table" id="spyMembersTable">
                    <thead>
                        <tr>${headerCells}</tr>
                    </thead>
                    <tbody>
                        ${bodyRows}
                    </tbody>
                </table>
            `;

            // Add drag event listeners for spy faction header
            const spyHeaderRow = container.querySelector('thead tr');
            if (spyHeaderRow) {
                spyHeaderRow.addEventListener('dragstart', handleSpyFactionDragStart);
                spyHeaderRow.addEventListener('dragover', handleSpyFactionDragOver);
                spyHeaderRow.addEventListener('dragleave', handleSpyFactionDragLeave);
                spyHeaderRow.addEventListener('drop', handleSpyFactionDrop);
                spyHeaderRow.addEventListener('dragend', handleSpyFactionDragEnd);
            }
        }

        // Get cell content for spy faction table (similar to getWarPlanningCellContent but without activity grid)
        function getSpyCellContent(column, member, memberData) {
            const stats = memberData.battleStats;
            const hasRealStats = stats && stats.isReal && stats.strength !== undefined;

            switch (column) {
                case 'name':
                    return `<td>
                        <div class="member-name-cell">
                            <div class="member-name-row">
                                <span class="status-indicator ${memberData.statusIndicatorClass}"></span>
                                <a href="https://www.torn.com/profiles.php?XID=${member.id}" target="_blank">
                                    ${member.name}
                                </a>
                                <a href="https://www.torn.com/loader.php?sid=attack&user2ID=${member.id}" target="_blank" class="attack-skull" title="Attack ${member.name}">üíÄ</a>
                            </div>
                        </div>
                    </td>`;
                case 'est_stats':
                    // Show estimated stats only when we don't have real TornStats data
                    if (hasRealStats) {
                        return `<td class="est-stats"><span style="color: #999;">-</span></td>`;
                    } else {
                        const estTotal = stats?.total || 0;
                        const tooltip = `Estimated Total: ${formatStatNumber(estTotal)}`;
                        return `<td class="est-stats"><span class="est-value" title="${tooltip}" style="cursor: help;">${formatStatNumber(estTotal)}</span></td>`;
                    }
                case 'level':
                    return `<td><span class="level-badge">${member.level || 'N/A'}</span></td>`;
                case 'age':
                    return `<td>${memberData.age}</td>`;
                case 'life':
                    return `<td>${memberData.life}</td>`;
                case 'elo':
                    return `<td>${memberData.elo}</td>`;
                case 'best_damage':
                    return `<td>${typeof memberData.bestDamage === 'number' ? memberData.bestDamage.toLocaleString() : memberData.bestDamage}</td>`;
                case 'critical_hits':
                    return `<td>${memberData.criticalPct}%</td>`;
                case 'rw_hits':
                    return `<td>${typeof memberData.rwHits === 'number' ? memberData.rwHits.toLocaleString() : memberData.rwHits}</td>`;
                case 'xanax':
                    return `<td>${typeof memberData.xanax === 'number' ? memberData.xanax.toLocaleString() : memberData.xanax}</td>`;
                case 'vicodin':
                    return `<td>${typeof memberData.vicodin === 'number' ? memberData.vicodin.toLocaleString() : memberData.vicodin}</td>`;
                case 'overdosed':
                    return `<td>${typeof memberData.overdosed === 'number' ? memberData.overdosed.toLocaleString() : memberData.overdosed}</td>`;
                case 'refills':
                    return `<td>${typeof memberData.refills === 'number' ? memberData.refills.toLocaleString() : memberData.refills}</td>`;
                case 'location':
                    return `<td class="${memberData.locationClass}">${memberData.locationText}</td>`;
                case 'str':
                    // Show real stats only when we have TornStats data
                    if (hasRealStats) {
                        return `<td>${formatStatCell(stats.strength, true, stats.daysAgo)}</td>`;
                    } else {
                        return `<td><span style="color: #999;">-</span></td>`;
                    }
                case 'def':
                    if (hasRealStats) {
                        return `<td>${formatStatCell(stats.defense, true, stats.daysAgo)}</td>`;
                    } else {
                        return `<td><span style="color: #999;">-</span></td>`;
                    }
                case 'spd':
                    if (hasRealStats) {
                        return `<td>${formatStatCell(stats.speed, true, stats.daysAgo)}</td>`;
                    } else {
                        return `<td><span style="color: #999;">-</span></td>`;
                    }
                case 'dex':
                    if (hasRealStats) {
                        return `<td>${formatStatCell(stats.dexterity, true, stats.daysAgo)}</td>`;
                    } else {
                        return `<td><span style="color: #999;">-</span></td>`;
                    }
                default:
                    return '<td>-</td>';
            }
        }

        // Load saved API key and faction ID from localStorage
        // Check if this is a new version that requires data reset notification
        function checkVersionAndPromptReset() {
            const lastAcknowledgedVersion = localStorage.getItem('tornDashboardVersion');

            // If this is version 0.19 and user hasn't acknowledged it yet
            if (CURRENT_VERSION === '0.19' && lastAcknowledgedVersion !== '0.19') {
                const shouldReset = confirm(
                    'üîÑ Welcome to Torn War Dashboard V0.19!\n\n' +
                    'This update includes significant changes to the War Portal and data structures.\n\n' +
                    'It is STRONGLY RECOMMENDED that you reset your cached data to ensure everything works correctly.\n\n' +
                    '‚úì Your API keys will be preserved\n' +
                    '‚úó Cached faction data will be cleared\n' +
                    '‚úó Column settings will be reset\n\n' +
                    'Click OK to reset data now (recommended)\n' +
                    'Click Cancel to skip (may cause display issues)'
                );

                // Mark this version as acknowledged so we don't prompt again
                localStorage.setItem('tornDashboardVersion', CURRENT_VERSION);

                if (shouldReset) {
                    resetAllData(true); // Skip the confirmation since user just confirmed
                    return true; // Indicate reset was performed
                }
            } else if (lastAcknowledgedVersion !== CURRENT_VERSION) {
                // For future versions, just update the stored version without prompting
                localStorage.setItem('tornDashboardVersion', CURRENT_VERSION);
            }

            return false; // No reset performed
        }

        window.addEventListener('DOMContentLoaded', () => {
            loadActivityHistory();
            loadColumnWidths();
            loadPortalColumnOrder();
            loadPortalSortState();
            loadWarPlanningColumnOrder();
            loadWPColumnWidths();
            loadSpyFactionColumnOrder();
            loadSpyColumnWidths();
            initColumnResize();
            initWPColumnResize();
            loadTornStatsCache();
            loadEnemyFactionDataFromCache();
            loadUserFactionDataFromCache();

            // Load saved auto-refresh interval
            const savedAutoRefresh = localStorage.getItem('tornAutoRefreshSeconds');
            if (savedAutoRefresh) {
                autoRefreshSeconds = parseInt(savedAutoRefresh);
            }

            const savedKey = localStorage.getItem('tornApiKey');
            if (savedKey) {
                document.getElementById('apiKey').value = savedKey;
            }

            // savedFactionId kept in localStorage but input field removed

            const savedTornStatsKey = localStorage.getItem('tornStatsApiKey');
            if (savedTornStatsKey) {
                document.getElementById('tornStatsApiKey').value = savedTornStatsKey;
            }

            // Restore saved spy faction ID if available
            const savedSpyFactionId = localStorage.getItem('tornSpyFactionId');
            if (savedSpyFactionId) {
                const spyInput = document.getElementById('spyFactionId');
                if (spyInput) {
                    spyInput.value = savedSpyFactionId;
                }
            }

            // Check for version update and prompt for reset if needed
            const wasReset = checkVersionAndPromptReset();

            // Initialize based on saved tab preference (skip if data was just reset)
            if (savedKey && !wasReset) {
                initializeDashboard();
            }
        });

        // Main initialization function
        async function initializeDashboard() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const savedTab = localStorage.getItem('tornActiveTab');

            if (!apiKey) {
                return;
            }

            showLoading();

            try {
                // Get the API key owner's faction ID
                const userResponse = await fetch(`https://api.torn.com/user?selections=profile&key=${apiKey}`);
                const userData = await userResponse.json();

                if (userData.error) {
                    throw new Error(userData.error.error);
                }

                const ownerFactionId = userData.faction?.faction_id;

                if (!ownerFactionId) {
                    throw new Error('You are not in a faction');
                }

                // Store current user's ID
                currentUserId = userData.player_id?.toString() || null;

                // Save owner's faction ID
                localStorage.setItem('tornUserFactionId', ownerFactionId.toString());

                if (savedTab === 'war-portal') {
                    // User was on War Portal - restore that view
                    await initializeWarPortal(apiKey, ownerFactionId);
                } else if (savedTab === 'faction-spying') {
                    // User was on Faction Spying - load faction data then switch to that tab
                    localStorage.setItem('tornFactionId', ownerFactionId.toString());
                    await loadFactionDataForPlanning(apiKey, ownerFactionId);
                    switchToTab('faction-spying');
                    // Auto-load the last spied faction if available
                    const savedSpyFactionId = localStorage.getItem('tornSpyFactionId');
                    if (savedSpyFactionId) {
                        document.getElementById('spyFactionId').value = savedSpyFactionId;
                        loadSpyFaction();
                    }
                } else {
                    // Default: Load My Faction tab with owner's faction
                    localStorage.setItem('tornFactionId', ownerFactionId.toString());
                    await loadFactionDataForPlanning(apiKey, ownerFactionId);
                }

            } catch (error) {
                console.error('Error initializing dashboard:', error);
                showError(`Error initializing: ${error.message}`);
            }
        }

        // Initialize War Portal tab
        async function initializeWarPortal(apiKey, ownerFactionId) {
            // Try to load cached faction data first
            const hasCachedUserFaction = loadUserFactionDataFromCache();
            const hasCachedEnemyFaction = loadEnemyFactionDataFromCache();

            console.log('Initializing War Portal - cached user:', hasCachedUserFaction, 'cached enemy:', hasCachedEnemyFaction);

            // We need minimal data to render the dashboard structure
            // Use cached data if available, otherwise fetch minimal data
            if (hasCachedUserFaction && userFactionData) {
                // Use cached data for factionData and membersData to render dashboard
                factionData = userFactionData;
                membersData = [...userMembersData];
            } else {
                // Fetch minimal faction data to render dashboard structure
                const factionUrl = `https://api.torn.com/faction/${ownerFactionId}?selections=basic&key=${apiKey}`;
                const response = await fetch(factionUrl);
                const data = await response.json();
                if (!data.error) {
                    factionData = data;
                    userFactionData = data;
                    // Create basic membersData from faction members
                    const memberIds = data.members ? Object.keys(data.members) : [];
                    membersData = memberIds.map(id => ({
                        id,
                        ...data.members[id],
                        details: {}
                    }));
                    userMembersData = [...membersData];
                }
            }

            // Now render the dashboard (creates the warPortalContainer)
            renderDashboard();

            // Switch to War Portal tab
            switchToWarPortal();

            if (hasCachedUserFaction && hasCachedEnemyFaction) {
                // Both factions cached - just render and do lightweight status refresh
                renderWarPortal();
                // Start lightweight refresh for status updates only
                startLightweightRefresh(apiKey);
            } else {
                // Missing cached data - need to do full load
                if (!hasCachedUserFaction) {
                    await loadFullUserFaction(ownerFactionId, apiKey);
                }

                if (!hasCachedEnemyFaction) {
                    // Find and load enemy faction
                    const enemyId = await findEnemyFactionId(ownerFactionId, apiKey);
                    if (enemyId) {
                        localStorage.setItem('tornEnemyFactionId', enemyId);
                        await loadEnemyFaction(enemyId);
                    }
                } else {
                    renderWarPortal();
                }

                // Start lightweight refresh for status updates after loading completes
                startLightweightRefresh(apiKey);
            }
        }

        // Find enemy faction ID from ranked wars
        async function findEnemyFactionId(ownerFactionId, apiKey) {
            try {
                const factionResponse = await fetch(`https://api.torn.com/faction/${ownerFactionId}?selections=rankedwars&key=${apiKey}`);
                const factionRWData = await factionResponse.json();

                if (factionRWData.error) return null;

                const rankedWars = factionRWData.rankedwars || {};
                const now = Math.floor(Date.now() / 1000);
                const sortedWarIds = Object.keys(rankedWars).sort((a, b) => parseInt(b) - parseInt(a));

                for (const warId of sortedWarIds) {
                    const war = rankedWars[warId];
                    const hasEnded = war.end && war.end > 0 && war.end < now;

                    if (!hasEnded && war.factions) {
                        for (const fId in war.factions) {
                            if (fId != ownerFactionId) {
                                return fId;
                            }
                        }
                    }
                }
            } catch (e) {
                console.log('Could not find enemy faction:', e);
            }
            return null;
        }

        // Fetch ranked war history and return list of opponent factions
        async function fetchRankedWarHistory() {
            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) return [];

            try {
                const userFactionId = localStorage.getItem('tornUserFactionId');
                if (!userFactionId) return [];

                const factionResponse = await fetch(`https://api.torn.com/faction/${userFactionId}?selections=rankedwars&key=${apiKey}`);
                const factionRWData = await factionResponse.json();

                if (factionRWData.error) return [];

                const rankedWars = factionRWData.rankedwars || {};
                const opponents = [];
                const seenFactions = new Set();

                // Sort wars by ID (descending = most recent first)
                const sortedWarIds = Object.keys(rankedWars).sort((a, b) => parseInt(b) - parseInt(a));

                for (const warId of sortedWarIds) {
                    const war = rankedWars[warId];
                    if (war.factions) {
                        for (const fId in war.factions) {
                            if (fId != userFactionId && !seenFactions.has(fId)) {
                                seenFactions.add(fId);
                                const factionInfo = war.factions[fId];
                                opponents.push({
                                    id: fId,
                                    name: factionInfo.name || `Faction ${fId}`,
                                    score: factionInfo.score || 0,
                                    warId: warId
                                });
                            }
                        }
                    }
                }

                // Save to localStorage for quick access
                localStorage.setItem('tornRankedWarHistory', JSON.stringify(opponents));
                return opponents;
            } catch (e) {
                console.log('Could not fetch ranked war history:', e);
                return [];
            }
        }

        // Load ranked war history from cache
        function loadRankedWarHistoryFromCache() {
            try {
                const cached = localStorage.getItem('tornRankedWarHistory');
                return cached ? JSON.parse(cached) : [];
            } catch (e) {
                return [];
            }
        }

        // Populate the ranked war history dropdown
        async function populateWarHistoryDropdown() {
            const dropdown = document.getElementById('warHistoryDropdown');
            if (!dropdown) return;

            // First try cached data for instant display
            let opponents = loadRankedWarHistoryFromCache();

            // Then fetch fresh data in background
            fetchRankedWarHistory().then(freshOpponents => {
                if (freshOpponents.length > 0) {
                    opponents = freshOpponents;
                    updateWarHistoryDropdownOptions(dropdown, opponents);
                }
            });

            updateWarHistoryDropdownOptions(dropdown, opponents);
        }

        // Update dropdown options
        function updateWarHistoryDropdownOptions(dropdown, opponents) {
            dropdown.innerHTML = '<option value="">-- Recent War Opponents --</option>';

            if (opponents.length === 0) {
                dropdown.innerHTML += '<option value="" disabled>No ranked war history found</option>';
                return;
            }

            opponents.forEach((opponent, index) => {
                const option = document.createElement('option');
                option.value = opponent.id;
                option.textContent = `${opponent.name} [${opponent.id}]`;
                dropdown.appendChild(option);
            });
        }

        // Handle war history dropdown selection
        function selectWarHistoryFaction(factionId) {
            if (!factionId) return;

            const spyInput = document.getElementById('spyFactionId');
            if (spyInput) {
                spyInput.value = factionId;
            }

            // Auto-load the faction
            loadSpyFaction();

            // Reset dropdown to placeholder
            const dropdown = document.getElementById('warHistoryDropdown');
            if (dropdown) {
                dropdown.selectedIndex = 0;
            }
        }

        // Full load of user faction with all details and TornStats
        async function loadFullUserFaction(factionId, apiKey) {
            const ownList = document.getElementById('ownMembersList');

            try {
                if (ownList) {
                    ownList.innerHTML = '<div class="portal-no-data">Loading your faction info...</div>';
                }

                const factionUrl = `https://api.torn.com/faction/${factionId}?selections=basic&key=${apiKey}`;
                const response = await fetch(factionUrl);
                const data = await response.json();

                if (data.error) throw new Error(data.error.error);

                userFactionData = data;
                factionData = data;

                const memberIds = data.members ? Object.keys(data.members) : [];
                const memberDetails = await fetchMemberDetailsBatched(
                    memberIds,
                    apiKey,
                    ownList,
                    'Loading your faction members'
                );

                userMembersData = memberIds.map(id => {
                    const member = data.members[id];
                    const details = memberDetails.find(d => d.id === id) || {};
                    return { id, ...member, details: details || {} };
                });
                membersData = [...userMembersData];

                await fetchTornStatsSpyData(memberIds, false, false);
                saveUserFactionData();
                renderWarPortal();
            } catch (error) {
                console.error('Error loading full user faction:', error);
            }
        }

        // Check Status - instant lightweight refresh triggered by button
        async function checkStatus() {
            const apiKey = document.getElementById('apiKey').value.trim();
            if (!apiKey) {
                alert('Please enter your API key first');
                return;
            }

            // Disable both buttons and show updating message
            const ownBtn = document.getElementById('ownCheckStatusBtn');
            const enemyBtn = document.getElementById('enemyCheckStatusBtn');
            const originalText = 'Check Status';

            if (ownBtn) {
                ownBtn.disabled = true;
                ownBtn.textContent = 'Updating...';
            }
            if (enemyBtn) {
                enemyBtn.disabled = true;
                enemyBtn.textContent = 'Updating...';
            }

            try {
                await doLightweightRefresh(apiKey);
            } finally {
                // Re-enable buttons and restore text
                if (ownBtn) {
                    ownBtn.disabled = false;
                    ownBtn.textContent = originalText;
                }
                if (enemyBtn) {
                    enemyBtn.disabled = false;
                    enemyBtn.textContent = originalText;
                }
            }
        }

        // Lightweight refresh - only updates status, life, hospital timers, online status
        // Does NOT re-fetch full member details or TornStats
        async function startLightweightRefresh(apiKey) {
            // Do an initial lightweight refresh
            await doLightweightRefresh(apiKey);

            // Start the unified auto-refresh (handles both tabs)
            startUnifiedAutoRefresh();
        }

        // Refresh war scores from the API
        async function refreshWarScores(apiKey) {
            try {
                const myFactionId = localStorage.getItem('tornUserFactionId');
                if (!myFactionId) return;

                const factionResponse = await fetch(`https://api.torn.com/faction/${myFactionId}?selections=rankedwars&key=${apiKey}`);
                const factionRWData = await factionResponse.json();

                if (factionRWData.error) return;

                const rankedWars = factionRWData.rankedwars || {};
                const now = Math.floor(Date.now() / 1000);
                const sortedWarIds = Object.keys(rankedWars).sort((a, b) => parseInt(b) - parseInt(a));

                for (const warId of sortedWarIds) {
                    const rankedWar = rankedWars[warId];
                    // The war details are in rankedWar.war, factions in rankedWar.factions
                    const warInfo = rankedWar.war || {};
                    const hasEnded = warInfo.end && warInfo.end > 0 && warInfo.end < now;

                    if (!hasEnded && rankedWar.factions) {
                        // Find the enemy faction in this war
                        for (const fId in rankedWar.factions) {
                            if (fId != myFactionId) {
                                const ownFaction = rankedWar.factions[myFactionId];
                                const enemyFaction = rankedWar.factions[fId];

                                currentWarScores.ownScore = ownFaction?.score || 0;
                                currentWarScores.enemyScore = enemyFaction?.score || 0;
                                currentWarScores.isActiveWar = true;
                                currentWarScores.ownName = ownFaction?.name || 'Your Faction';
                                currentWarScores.enemyName = enemyFaction?.name || 'Enemy Faction';
                                currentWarScores.ownChain = ownFaction?.chain || 0;
                                currentWarScores.enemyChain = enemyFaction?.chain || 0;

                                // Get war timing and target from the nested war object
                                currentWarScores.warStart = warInfo.start || null;
                                currentWarScores.target = warInfo.target || 0;
                                currentWarScores.warEnd = warInfo.end || null;

                                console.log('Full ranked war data:', rankedWar);
                                console.log('War info:', warInfo);
                                console.log('War scores updated:', currentWarScores);
                                return;
                            }
                        }
                    }
                }
                currentWarScores.isActiveWar = false;
            } catch (error) {
                console.error('Error refreshing war scores:', error);
            }
        }

        async function doLightweightRefresh(apiKey) {
            // This function refreshes War Portal data specifically
            try {
                // Refresh war scores first
                await refreshWarScores(apiKey);

                // Get user faction ID
                const userFactionId = localStorage.getItem('tornUserFactionId');
                const enemyFactionId = localStorage.getItem('tornEnemyFactionId');

                // Fetch basic faction data (includes member status, last_action, life)
                if (userFactionId && userMembersData.length > 0) {
                    const userFactionUrl = `https://api.torn.com/faction/${userFactionId}?selections=basic&key=${apiKey}`;
                    const userResponse = await fetch(userFactionUrl);
                    const userData = await userResponse.json();

                    if (!userData.error && userData.members) {
                        // Update only status fields in userMembersData
                        userMembersData.forEach(member => {
                            const freshData = userData.members[member.id];
                            if (freshData) {
                                member.last_action = freshData.last_action;
                                member.status = freshData.status;
                                // Update life and status in details if available
                                if (member.details) {
                                    member.details.life = freshData.life || member.details.life;
                                    member.details.status = freshData.status || member.details.status;
                                }
                            }
                        });
                    }
                }

                if (enemyFactionId && enemyMembersData.length > 0) {
                    const enemyFactionUrl = `https://api.torn.com/faction/${enemyFactionId}?selections=basic&key=${apiKey}`;
                    const enemyResponse = await fetch(enemyFactionUrl);
                    const enemyData = await enemyResponse.json();

                    if (!enemyData.error && enemyData.members) {
                        // Update only status fields in enemyMembersData
                        enemyMembersData.forEach(member => {
                            const freshData = enemyData.members[member.id];
                            if (freshData) {
                                member.last_action = freshData.last_action;
                                member.status = freshData.status;
                                if (member.details) {
                                    member.details.life = freshData.life || member.details.life;
                                    member.details.status = freshData.status || member.details.status;
                                }
                            }
                        });
                    }
                }

                // Re-render the portal with updated data
                renderWarPortal();
                lastRefreshTime = new Date();

                // Update the refresh time display
                const refreshTimeElement = document.getElementById('lastRefreshTime');
                if (refreshTimeElement) {
                    refreshTimeElement.textContent = formatTime(lastRefreshTime);
                }

            } catch (error) {
                console.error('Lightweight refresh error:', error);
            }
        }

        // Unified auto-refresh that handles both My Faction and War Portal tabs
        function startUnifiedAutoRefresh() {
            // Clear any existing interval
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }

            refreshInterval = setInterval(async () => {
                const apiKey = document.getElementById('apiKey').value.trim();
                if (!apiKey) return;

                const savedTab = localStorage.getItem('tornActiveTab');

                try {
                    if (savedTab === 'war-portal') {
                        // Refresh War Portal
                        await doLightweightRefresh(apiKey);
                    } else if (savedTab === 'my-faction') {
                        // Refresh My Faction tab
                        await doMyFactionRefresh(apiKey);
                    }
                    // Other tabs don't need auto-refresh
                } catch (error) {
                    console.error('Auto-refresh error:', error);
                }
            }, autoRefreshSeconds * 1000);
        }

        // Refresh function for My Faction tab
        async function doMyFactionRefresh(apiKey) {
            try {
                const userFactionId = localStorage.getItem('tornUserFactionId');
                if (!userFactionId) return;

                // Use efficient faction-level API call
                const factionUrl = `https://api.torn.com/faction/${userFactionId}?selections=basic&key=${apiKey}`;
                const response = await fetch(factionUrl);
                const data = await response.json();

                if (data.error || !data.members) return;

                // Update member status from faction data
                const updateMemberFromFaction = (member) => {
                    const freshData = data.members[member.id];
                    if (freshData) {
                        return {
                            ...member,
                            status: freshData.status || member.status,
                            last_action: freshData.last_action || member.last_action,
                            details: {
                                ...member.details,
                                status: freshData.status || member.details?.status,
                                last_action: freshData.last_action || member.details?.last_action,
                                life: freshData.life || member.details?.life
                            }
                        };
                    }
                    return member;
                };

                // Update faction members
                if (membersData.length > 0) {
                    membersData = membersData.map(updateMemberFromFaction);
                }
                if (userMembersData.length > 0) {
                    userMembersData = userMembersData.map(updateMemberFromFaction);
                }

                lastRefreshTime = new Date();

                // Update the refresh time display
                const refreshTimeElement = document.getElementById('lastRefreshTime');
                if (refreshTimeElement) {
                    refreshTimeElement.textContent = formatTime(lastRefreshTime);
                }

                // Re-render the members table
                renderMembersTable(membersData);
            } catch (error) {
                console.error('My Faction refresh error:', error);
            }
        }

        // Load faction data specifically for War Planning tab
        async function loadFactionDataForPlanning(apiKey, factionId) {
            const tornStatsApiKey = document.getElementById('tornStatsApiKey').value.trim();

            if (tornStatsApiKey) {
                localStorage.setItem('tornStatsApiKey', tornStatsApiKey);
            }

            try {
                const factionUrl = `https://api.torn.com/faction/${factionId}?selections=basic&key=${apiKey}`;
                const response = await fetch(factionUrl);
                const data = await response.json();

                if (data.error) {
                    throw new Error(data.error.error);
                }

                factionData = data;

                // Extract member IDs
                const memberIds = data.members ? Object.keys(data.members) : [];

                // Fetch details with batching
                const memberDetails = await fetchMemberDetailsBatched(
                    memberIds,
                    apiKey,
                    'global',
                    'Loading faction members'
                );

                membersData = memberIds.map(id => {
                    const member = data.members[id];
                    const details = memberDetails.find(d => d.id === id) || {};
                    return {
                        id,
                        ...member,
                        details: details || {}
                    };
                });

                // Fetch TornStats spy data
                await fetchTornStatsSpyData(memberIds);

                // Also load user's faction for War Portal
                userFactionData = data;
                userMembersData = [...membersData];

                renderDashboard();

            } catch (error) {
                console.error('Error loading faction data:', error);
                showError(`Error loading faction: ${error.message}`);
            }
        }

        // Load user faction data from cache
        function loadUserFactionDataFromCache() {
            try {
                const savedFactionData = localStorage.getItem('tornUserFactionData');
                const savedMembersData = localStorage.getItem('tornUserMembersData');
                if (savedFactionData && savedMembersData) {
                    userFactionData = JSON.parse(savedFactionData);
                    userMembersData = JSON.parse(savedMembersData);
                    console.log(`Restored user faction data: ${userFactionData.name} with ${userMembersData.length} members`);
                    return true;
                }
            } catch (e) {
                console.warn('Failed to load user faction data from cache:', e);
            }
            return false;
        }

        async function loadFactionData() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const tornStatsApiKey = document.getElementById('tornStatsApiKey').value.trim();
            const factionId = localStorage.getItem('tornFactionId') || '';

            if (!apiKey) {
                showError('Please enter your API key');
                return;
            }

            // Save API key to localStorage
            localStorage.setItem('tornApiKey', apiKey);

            // Save TornStats API key to localStorage (if provided)
            if (tornStatsApiKey) {
                localStorage.setItem('tornStatsApiKey', tornStatsApiKey);
            }

            showLoading();

            try {
                // Load faction basic info and members
                // Note: Using API without /v2 for better compatibility
                const factionUrl = factionId
                    ? `https://api.torn.com/faction/${factionId}?selections=basic&key=${apiKey}`
                    : `https://api.torn.com/faction?selections=basic&key=${apiKey}`;

                const response = await fetch(factionUrl);
                const data = await response.json();

                console.log('Faction data response:', data);

                if (data.error) {
                    throw new Error(data.error.error);
                }

                factionData = data;

                // If faction ID was blank, store the loaded faction's ID for future use
                if (!factionId && data.ID) {
                    localStorage.setItem('tornFactionId', data.ID.toString());
                }

                // Extract member IDs from the faction data which includes members in basic
                const memberIds = data.members ? Object.keys(data.members) : [];
                console.log('Fetching details for', memberIds.length, 'members');

                // Fetch details with batching and progress indicator
                const memberDetails = await fetchMemberDetailsBatched(
                    memberIds,
                    apiKey,
                    'global',
                    'Loading faction members'
                );

                membersData = Object.entries(data.members || {}).map(([id, member]) => {
                    const details = memberDetails.find(d => d.id == id || d.player_id == id);

                    // Check if the details have an error
                    if (details && details.error) {
                        console.warn(`Member ${id} details have error:`, details.error);
                    }

                    return {
                        id,
                        ...member,
                        details: details || {}
                    };
                });

                // Check if any member details failed to load
                const failedMembers = memberDetails.filter(d => d.error);
                if (failedMembers.length > 0) {
                    console.warn(`Failed to load details for ${failedMembers.length} members. This may be due to API key permissions.`);
                }

                lastRefreshTime = new Date();
                recordActivityStatus(); // Record activity for tracking
                renderDashboard();
                restoreActiveTab(); // Restore saved tab after rendering
                startAutoRefresh();

                // Also load user's own faction for War Portal if not already loaded
                if (userMembersData.length === 0) {
                    loadUserFaction();
                }
            } catch (error) {
                console.error('Error details:', error);
                showError(`Error loading faction data: ${error.message}<br><br>Check browser console (F12) for more details.`);
            }
        }

        function startAutoRefresh() {
            // Use the unified auto-refresh that handles both tabs
            startUnifiedAutoRefresh();
        }

        function changeAutoRefreshInterval(seconds) {
            autoRefreshSeconds = parseInt(seconds);
            localStorage.setItem('tornAutoRefreshSeconds', autoRefreshSeconds);

            // Update the display text
            const displaySpan = document.getElementById('autoRefreshDisplay');
            if (displaySpan) {
                displaySpan.textContent = autoRefreshSeconds;
            }

            // Restart the auto-refresh with the new interval
            startUnifiedAutoRefresh();
        }

        function showLoading(message = 'Loading faction data...') {
            document.getElementById('content').innerHTML = `
                <div class="loading">
                    <div class="loading-spinner"></div>
                    <p id="loadingMessage">${message}</p>
                    <div id="loadingProgress" style="display: none; margin-top: 15px;">
                        <div style="width: 200px; height: 20px; background: #e0e0e0; border-radius: 10px; margin: 0 auto; overflow: hidden;">
                            <div id="loadingProgressBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, #4a7c4e, #6a9b6e); transition: width 0.3s;"></div>
                        </div>
                        <div id="loadingProgressText" style="color: #888; margin-top: 10px; font-size: 14px;"></div>
                    </div>
                </div>
            `;
        }

        function updateLoadingProgress(current, total, label = 'Loading members') {
            const progressDiv = document.getElementById('loadingProgress');
            const progressBar = document.getElementById('loadingProgressBar');
            const progressText = document.getElementById('loadingProgressText');
            const message = document.getElementById('loadingMessage');

            if (progressDiv) progressDiv.style.display = 'block';
            if (progressBar) progressBar.style.width = `${(current/total)*100}%`;
            if (progressText) progressText.textContent = `${current} / ${total} members`;
            if (message) message.textContent = `${label}...`;
        }

        function showError(message) {
            document.getElementById('content').innerHTML = `
                <div class="error">
                    <strong>Error:</strong> ${message}
                </div>
            `;
        }

        function renderDashboard() {
            const content = document.getElementById('content');

            const onlineCount = membersData.filter(m => m.last_action.status === 'Online').length;
            const idleCount = membersData.filter(m => m.last_action.status === 'Idle').length;
            const offlineCount = membersData.filter(m => m.last_action.status === 'Offline').length;
            const totalLevel = membersData.reduce((sum, m) => sum + (m.level || 0), 0);
            const avgLevel = Math.round(totalLevel / membersData.length);

            content.innerHTML = `
                <div class="faction-info" id="mainFactionInfo">
                    <h2>${factionData.name || 'Faction Information'}</h2>
                    <div class="info-grid">
                        <div class="info-item">
                            <label>Faction ID</label>
                            <value>${factionData.ID || 'N/A'}</value>
                        </div>
                        <div class="info-item">
                            <label>Members</label>
                            <value>${membersData.length}</value>
                        </div>
                        <div class="info-item">
                            <label>Respect</label>
                            <value>${(factionData.respect || 0).toLocaleString()}</value>
                        </div>
                        <div class="info-item">
                            <label>Age</label>
                            <value>${factionData.age || 'N/A'} days</value>
                        </div>
                        <div class="info-item">
                            <label>Capacity</label>
                            <value>${factionData.capacity || 'N/A'}</value>
                        </div>
                        <div class="info-item">
                            <label>Leader</label>
                            <value>${factionData.leader ? `<a href="https://www.torn.com/profiles.php?XID=${factionData.leader}" target="_blank" style="color: #667eea; text-decoration: none;">${getLeaderName()}</a>` : 'N/A'}</value>
                        </div>
                    </div>
                </div>

                <div class="members-section">
                    <h2 id="membersOverviewTitle">Members Overview: ${factionData.name || 'Unknown Faction'}</h2>
                    <div class="refresh-info" id="autoRefreshInfo">
                        Auto-refreshing every <span id="autoRefreshDisplay">${autoRefreshSeconds}</span> seconds.
                        <select id="autoRefreshSelect" onchange="changeAutoRefreshInterval(this.value)" style="margin-left: 10px; padding: 2px 5px; border-radius: 3px; border: 1px solid #ddd;">
                            <option value="5" ${autoRefreshSeconds === 5 ? 'selected' : ''}>5s</option>
                            <option value="10" ${autoRefreshSeconds === 10 ? 'selected' : ''}>10s</option>
                            <option value="15" ${autoRefreshSeconds === 15 ? 'selected' : ''}>15s</option>
                            <option value="30" ${autoRefreshSeconds === 30 ? 'selected' : ''}>30s</option>
                        </select>
                        Last updated: <span id="lastRefreshTime">${formatTime(lastRefreshTime)}</span>
                    </div>

                    <div class="stats-summary" id="statsSummary">
                        <div class="stat-card">
                            <h3>Online</h3>
                            <div class="value">${onlineCount}</div>
                        </div>
                        <div class="stat-card">
                            <h3>Idle</h3>
                            <div class="value">${idleCount}</div>
                        </div>
                        <div class="stat-card">
                            <h3>Offline</h3>
                            <div class="value">${offlineCount}</div>
                        </div>
                        <div class="stat-card">
                            <h3>Average Level</h3>
                            <div class="value">${avgLevel}</div>
                        </div>
                    </div>

                    <div class="tabs-container">
                        <div class="tab-buttons">
                            <button class="tab-button active" onclick="switchTab('my-faction')">My Faction</button>
                            <button class="tab-button" onclick="switchTab('faction-spying')">Faction Spying</button>
                            <button class="tab-button" onclick="switchTab('war-portal')">War Portal</button>
                        </div>

                        <div id="my-faction" class="tab-content active">
                            <div class="filters">
                                <input type="text" id="searchInput" placeholder="Search members..." onkeyup="filterMembers()">
                                <select id="statusFilter" onchange="filterMembers()">
                                    <option value="">All Status</option>
                                    <option value="Online">Online</option>
                                    <option value="Idle">Idle</option>
                                    <option value="Offline">Offline</option>
                                </select>
                                <select id="locationFilter" onchange="filterMembers()">
                                    <option value="">All Locations</option>
                                    ${getUniqueLocations().map(loc => `<option value="${loc.toLowerCase()}">${loc}</option>`).join('')}
                                </select>
                                <select id="positionFilter" onchange="filterMembers()">
                                    <option value="">All Positions</option>
                                    ${getUniquePositions().map(pos => `<option value="${pos}">${pos}</option>`).join('')}
                                </select>
                            </div>
                            <div id="membersTableContainer"></div>
                        </div>

                        <div id="faction-spying" class="tab-content">
                            <div class="faction-spying-input" style="padding: 15px; background: #f8f9fa; border-bottom: 1px solid #ddd; display: flex; align-items: center; gap: 10px; flex-wrap: wrap;">
                                <label for="spyFactionId" style="font-weight: 600; font-size: 13px;">Faction ID:</label>
                                <input type="text" id="spyFactionId" placeholder="Enter Faction ID" style="padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; width: 150px;" onkeypress="if(event.key==='Enter') loadSpyFaction()">
                                <button class="btn" onclick="loadSpyFaction()">Load Faction</button>
                                <span style="color: #999; margin: 0 5px;">or</span>
                                <select id="warHistoryDropdown" onchange="selectWarHistoryFaction(this.value)" style="padding: 6px 10px; border: 1px solid #ccc; border-radius: 4px; font-size: 12px; min-width: 220px; max-width: 300px;">
                                    <option value="">-- Recent War Opponents --</option>
                                </select>
                            </div>
                            <div id="spyFactionContainer">
                                <div style="padding: 40px; text-align: center; color: #666;">
                                    <p>Enter a Faction ID above or select from recent war opponents to view their members and stats.</p>
                                </div>
                            </div>
                        </div>

                        <div id="war-portal" class="tab-content">
                            <div id="warPortalContainer"></div>
                        </div>
                    </div>
                </div>
            `;

            renderMembersTable(membersData);
            renderWarPortal();
            populateWarHistoryDropdown();
        }

        function getUniquePositions() {
            const positions = new Set(membersData.map(m => m.position));
            return Array.from(positions).sort();
        }

        function getUniqueLocations() {
            const locations = new Set();
            membersData.forEach(m => {
                const userStatus = (m.details && m.details.status) || {};
                let locationText = (userStatus.description || userStatus.state || 'Unknown').trim();

                if (locationText && locationText !== 'Unknown') {
                    // Normalize hospital statuses to just "In Hospital"
                    if (locationText.toLowerCase().includes('hospital')) {
                        locationText = 'In Hospital';
                    }
                    // Normalize jail statuses to just "In Jail"
                    else if (locationText.toLowerCase().includes('jail')) {
                        locationText = 'In Jail';
                    }
                    // Normalize traveling statuses
                    else if (locationText.toLowerCase().includes('traveling') || locationText.toLowerCase().includes('flying')) {
                        locationText = 'Traveling';
                    }

                    locations.add(locationText);
                }
            });
            return Array.from(locations).sort();
        }

        function filterMembers() {
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const statusFilter = document.getElementById('statusFilter').value;
            const locationFilter = document.getElementById('locationFilter').value.toLowerCase();
            const positionFilter = document.getElementById('positionFilter').value;

            let filtered = membersData.filter(member => {
                const matchesSearch = member.name.toLowerCase().includes(searchTerm);
                const matchesStatus = !statusFilter || member.last_action.status === statusFilter;

                // Check location filter using the status from details
                let matchesLocation = true;
                if (locationFilter) {
                    const userStatus = (member.details && member.details.status) || {};
                    const locationText = (userStatus.description || userStatus.state || '').toLowerCase();
                    matchesLocation = locationText.includes(locationFilter);
                }

                const matchesPosition = !positionFilter || member.position === positionFilter;
                return matchesSearch && matchesStatus && matchesLocation && matchesPosition;
            });

            renderMembersTable(filtered);
        }

        function sortMembers(column) {
            if (sortColumn === column) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortColumn = column;
                sortDirection = 'asc';
            }

            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const statusFilter = document.getElementById('statusFilter').value;
            const locationFilter = document.getElementById('locationFilter').value.toLowerCase();
            const positionFilter = document.getElementById('positionFilter').value;

            let filtered = membersData.filter(member => {
                const matchesSearch = member.name.toLowerCase().includes(searchTerm);
                const matchesStatus = !statusFilter || member.last_action.status === statusFilter;

                // Check location filter using the status from details
                let matchesLocation = true;
                if (locationFilter) {
                    const userStatus = (member.details && member.details.status) || {};
                    const locationText = (userStatus.description || userStatus.state || '').toLowerCase();
                    matchesLocation = locationText.includes(locationFilter);
                }

                const matchesPosition = !positionFilter || member.position === positionFilter;
                return matchesSearch && matchesStatus && matchesLocation && matchesPosition;
            });

            filtered.sort((a, b) => {
                let aVal, bVal;

                switch(column) {
                    case 'name':
                        aVal = a.name.toLowerCase();
                        bVal = b.name.toLowerCase();
                        break;
                    case 'est_stats':
                        const aStats = getBattleStats(a);
                        const bStats = getBattleStats(b);
                        aVal = aStats.total || 0;
                        bVal = bStats.total || 0;
                        break;
                    case 'level':
                        aVal = a.level || 0;
                        bVal = b.level || 0;
                        break;
                    case 'age':
                        aVal = (a.details && a.details.age) || 0;
                        bVal = (b.details && b.details.age) || 0;
                        break;
                    case 'life':
                        aVal = (a.details && a.details.life && a.details.life.current) || 0;
                        bVal = (b.details && b.details.life && b.details.life.current) || 0;
                        break;
                    case 'elo':
                        aVal = (a.details && a.details.personalstats && (a.details.personalstats.elo || a.details.personalstats.rankedwarrating)) || 0;
                        bVal = (b.details && b.details.personalstats && (b.details.personalstats.elo || b.details.personalstats.rankedwarrating)) || 0;
                        break;
                    case 'best_damage':
                        aVal = (a.details && a.details.personalstats && (a.details.personalstats.bestdamage || a.details.personalstats.highestbeaten)) || 0;
                        bVal = (b.details && b.details.personalstats && (b.details.personalstats.bestdamage || b.details.personalstats.highestbeaten)) || 0;
                        break;
                    case 'critical_hits':
                        const aCrit = (a.details && a.details.personalstats && a.details.personalstats.attackcriticalhits) || 0;
                        const aTotal = (a.details && a.details.personalstats && a.details.personalstats.attackhits) || 1;
                        const bCrit = (b.details && b.details.personalstats && b.details.personalstats.attackcriticalhits) || 0;
                        const bTotal = (b.details && b.details.personalstats && b.details.personalstats.attackhits) || 1;
                        aVal = aCrit / aTotal;
                        bVal = bCrit / bTotal;
                        break;
                    case 'rw_hits':
                        aVal = (a.details && a.details.personalstats && a.details.personalstats.rankedwarhits) || 0;
                        bVal = (b.details && b.details.personalstats && b.details.personalstats.rankedwarhits) || 0;
                        break;
                    case 'xanax':
                        aVal = (a.details && a.details.personalstats && a.details.personalstats.xantaken) || 0;
                        bVal = (b.details && b.details.personalstats && b.details.personalstats.xantaken) || 0;
                        break;
                    case 'vicodin':
                        aVal = (a.details && a.details.personalstats && a.details.personalstats.victaken) || 0;
                        bVal = (b.details && b.details.personalstats && b.details.personalstats.victaken) || 0;
                        break;
                    case 'overdosed':
                        aVal = (a.details && a.details.personalstats && a.details.personalstats.overdosed) || 0;
                        bVal = (b.details && b.details.personalstats && b.details.personalstats.overdosed) || 0;
                        break;
                    case 'refills':
                        aVal = (a.details && a.details.personalstats && (a.details.personalstats.energydrinkused || a.details.personalstats.refills)) || 0;
                        bVal = (b.details && b.details.personalstats && (b.details.personalstats.energydrinkused || b.details.personalstats.refills)) || 0;
                        break;
                    case 'location':
                        const aStatus = (a.details && a.details.status) || {};
                        const bStatus = (b.details && b.details.status) || {};
                        const aLocText = (aStatus.description || aStatus.state || 'Unknown').toLowerCase();
                        const bLocText = (bStatus.description || bStatus.state || 'Unknown').toLowerCase();
                        const aInHospital = aLocText.includes('hospital');
                        const bInHospital = bLocText.includes('hospital');

                        // If both in hospital, sort by hospital end time
                        if (aInHospital && bInHospital) {
                            aVal = aStatus.until || Number.MAX_SAFE_INTEGER;
                            bVal = bStatus.until || Number.MAX_SAFE_INTEGER;
                        } else if (aInHospital) {
                            // Hospital players sort before non-hospital when ascending
                            aVal = 0;
                            bVal = 1;
                        } else if (bInHospital) {
                            aVal = 1;
                            bVal = 0;
                        } else {
                            // Neither in hospital, sort alphabetically
                            aVal = aLocText;
                            bVal = bLocText;
                        }
                        break;
                    case 'status':
                        aVal = a.last_action.status;
                        bVal = b.last_action.status;
                        break;
                    case 'position':
                        aVal = a.position;
                        bVal = b.position;
                        break;
                    default:
                        return 0;
                }

                if (aVal < bVal) return sortDirection === 'asc' ? -1 : 1;
                if (aVal > bVal) return sortDirection === 'asc' ? 1 : -1;
                return 0;
            });

            renderMembersTable(filtered);
        }

        // Column definitions for War Planning table
        const warPlanningColumnDefs = {
            name: { label: 'Name / 24h Activity', sortKey: 'name' },
            est_stats: { label: 'Stats', sortKey: 'est_stats' },
            level: { label: 'Level', sortKey: 'level' },
            age: { label: 'Age (days)', sortKey: 'age' },
            life: { label: 'Life', sortKey: 'life' },
            elo: { label: 'ELO', sortKey: 'elo' },
            best_damage: { label: 'Best DMG', sortKey: 'best_damage' },
            critical_hits: { label: 'Crit %', sortKey: 'critical_hits' },
            rw_hits: { label: 'RW Hits', sortKey: 'rw_hits' },
            xanax: { label: 'Xanax', sortKey: 'xanax' },
            vicodin: { label: 'Vicodin', sortKey: 'vicodin' },
            overdosed: { label: 'OD', sortKey: 'overdosed' },
            refills: { label: 'Refills', sortKey: 'refills' },
            location: { label: 'Location', sortKey: 'location' }
        };

        // Get cell content for a specific column
        function getWarPlanningCellContent(column, member, memberData) {
            switch (column) {
                case 'name':
                    return `<td>
                        <div class="member-name-cell">
                            <div class="member-name-row">
                                <span class="status-indicator ${memberData.statusIndicatorClass}"></span>
                                <a href="https://www.torn.com/profiles.php?XID=${member.id}" target="_blank">
                                    ${member.name}
                                </a>
                            </div>
                            ${generateActivityGrid(member.id)}
                        </div>
                    </td>`;
                case 'est_stats':
                    return `<td class="est-stats">${formatStatsWithTooltip(memberData.battleStats)}</td>`;
                case 'level':
                    return `<td><span class="level-badge">${member.level || 'N/A'}</span></td>`;
                case 'age':
                    return `<td>${memberData.age}</td>`;
                case 'life':
                    return `<td>${memberData.life}</td>`;
                case 'elo':
                    return `<td>${memberData.elo}</td>`;
                case 'best_damage':
                    return `<td>${typeof memberData.bestDamage === 'number' ? memberData.bestDamage.toLocaleString() : memberData.bestDamage}</td>`;
                case 'critical_hits':
                    return `<td>${memberData.criticalPct}%</td>`;
                case 'rw_hits':
                    return `<td>${typeof memberData.rwHits === 'number' ? memberData.rwHits.toLocaleString() : memberData.rwHits}</td>`;
                case 'xanax':
                    return `<td>${typeof memberData.xanax === 'number' ? memberData.xanax.toLocaleString() : memberData.xanax}</td>`;
                case 'vicodin':
                    return `<td>${typeof memberData.vicodin === 'number' ? memberData.vicodin.toLocaleString() : memberData.vicodin}</td>`;
                case 'overdosed':
                    return `<td>${typeof memberData.overdosed === 'number' ? memberData.overdosed.toLocaleString() : memberData.overdosed}</td>`;
                case 'refills':
                    return `<td>${typeof memberData.refills === 'number' ? memberData.refills.toLocaleString() : memberData.refills}</td>`;
                case 'location':
                    return `<td class="${memberData.locationClass}">${memberData.locationText}</td>`;
                default:
                    return '<td>-</td>';
            }
        }

        function renderMembersTable(members) {
            const container = document.getElementById('membersTableContainer');

            const getSortClass = (column) => {
                if (sortColumn !== column) return 'sortable';
                return sortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc';
            };

            // Generate header row based on column order with resize handles
            const headerCells = warPlanningColumnOrder.map((col, index) => {
                const def = warPlanningColumnDefs[col];
                const width = wpColumnWidths[col] || defaultWPColumnWidths[col];
                const isLast = index === warPlanningColumnOrder.length - 1;
                const resizeHandle = isLast ? '' : `<span class="wp-resize-handle" onmousedown="startWPColumnResize(event, '${col}')"></span>`;
                return `<th class="${getSortClass(def.sortKey)}"
                    onclick="sortMembers('${def.sortKey}')"
                    draggable="true"
                    data-column="${col}"
                    style="width: ${width}px; min-width: ${width}px;">${def.label}${resizeHandle}</th>`;
            }).join('');

            // Generate body rows
            const bodyRows = members.map(member => {
                const stats = member.details.personalstats || {};
                const profile = member.details || member;

                // Pre-calculate all member data
                const memberData = {
                    age: profile.age || 'N/A',
                    life: profile.life ? `${profile.life.current}/${profile.life.maximum}` : 'N/A',
                    elo: stats.elo || stats.rankedwarrating || 'N/A',
                    bestDamage: stats.bestdamage || stats.highestbeaten || 'N/A',
                    criticalPct: (stats.attackhits || 0) > 0 ? (((stats.attackcriticalhits || 0) / stats.attackhits) * 100).toFixed(2) : '0.00',
                    rwHits: stats.rankedwarhits || 'N/A',
                    xanax: stats.xantaken || 'N/A',
                    vicodin: stats.victaken || 'N/A',
                    overdosed: stats.overdosed || 'N/A',
                    refills: stats.energydrinkused || stats.refills || 'N/A',
                    estStats: estimateBattleStats(member),
                    battleStats: getBattleStats(member),
                    statusIndicatorClass: member.last_action.status === 'Online' ? 'online' :
                                         member.last_action.status === 'Idle' ? 'idle' : 'offline',
                    locationText: 'Unknown',
                    locationClass: ''
                };

                // Get location/status information
                const userStatus = profile.status || {};
                if (userStatus.description) {
                    memberData.locationText = userStatus.description;
                } else if (userStatus.state) {
                    memberData.locationText = userStatus.state;
                }

                // Format travel status to be shorter
                const flyingToMatch = memberData.locationText.match(/Flying to (.+)/i);
                const returningMatch = memberData.locationText.match(/Returning to (.+)/i);
                const travelingToMatch = memberData.locationText.match(/Traveling to (.+)/i);
                const inCountryMatch = memberData.locationText.match(/In (.+)/i);

                if (flyingToMatch) {
                    memberData.locationText = 'Outbound: ' + flyingToMatch[1];
                } else if (travelingToMatch) {
                    memberData.locationText = 'Outbound: ' + travelingToMatch[1];
                } else if (returningMatch) {
                    memberData.locationText = 'Inbound: ' + returningMatch[1];
                } else if (inCountryMatch && !memberData.locationText.toLowerCase().includes('hospital') && !memberData.locationText.toLowerCase().includes('jail')) {
                    memberData.locationText = 'Abroad: ' + inCountryMatch[1];
                }

                // Add color coding for different states
                if (memberData.locationText.toLowerCase().includes('okay') || memberData.locationText.toLowerCase().includes('torn')) {
                    memberData.locationClass = 'status-online';
                } else if (memberData.locationText.toLowerCase().includes('hospital') || memberData.locationText.toLowerCase().includes('jail')) {
                    memberData.locationClass = 'status-offline';
                } else if (memberData.locationText.toLowerCase().includes('outbound') || memberData.locationText.toLowerCase().includes('inbound') || memberData.locationText.toLowerCase().includes('abroad')) {
                    memberData.locationClass = 'status-idle';
                }

                // Generate cells in column order
                const cells = warPlanningColumnOrder.map(col => getWarPlanningCellContent(col, member, memberData)).join('');

                return `<tr>${cells}</tr>`;
            }).join('');

            container.innerHTML = `
                <table class="members-table">
                    <thead>
                        <tr>${headerCells}</tr>
                    </thead>
                    <tbody>
                        ${bodyRows}
                    </tbody>
                </table>
            `;

            // Add drag event listeners to header cells
            const headerRow = container.querySelector('thead tr');
            if (headerRow) {
                headerRow.addEventListener('dragstart', handleWarPlanningDragStart);
                headerRow.addEventListener('dragover', handleWarPlanningDragOver);
                headerRow.addEventListener('dragleave', handleWarPlanningDragLeave);
                headerRow.addEventListener('drop', handleWarPlanningDrop);
                headerRow.addEventListener('dragend', handleWarPlanningDragEnd);
            }

            // Apply stored column widths to body cells
            applyWPColumnWidths();
        }

        function formatTime(date) {
            if (!date) return 'Never';
            return date.toLocaleTimeString();
        }

        function getLeaderName() {
            if (!factionData || !factionData.leader) return 'N/A';
            // Look up leader name from members data
            if (factionData.members && factionData.members[factionData.leader]) {
                return factionData.members[factionData.leader].name;
            }
            // Fallback: check membersData array
            const leaderMember = membersData.find(m => m.id == factionData.leader);
            if (leaderMember) {
                return leaderMember.name;
            }
            return 'N/A';
        }

        // Get own faction leader name for War Portal
        function getOwnLeaderName(faction, members) {
            if (!faction || !faction.leader) return 'N/A';
            // Look up leader name from faction members data
            if (faction.members && faction.members[faction.leader]) {
                return faction.members[faction.leader].name;
            }
            // Fallback: check members array
            const leaderMember = members.find(m => m.id == faction.leader);
            if (leaderMember) {
                return leaderMember.name;
            }
            return 'N/A';
        }

        // Get enemy faction leader name for War Portal
        function getEnemyLeaderName() {
            if (!enemyFactionData || !enemyFactionData.leader) return 'N/A';
            // Look up leader name from enemy faction members data
            if (enemyFactionData.members && enemyFactionData.members[enemyFactionData.leader]) {
                return enemyFactionData.members[enemyFactionData.leader].name;
            }
            // Fallback: check enemyMembersData array
            const leaderMember = enemyMembersData.find(m => m.id == enemyFactionData.leader);
            if (leaderMember) {
                return leaderMember.name;
            }
            return 'N/A';
        }

        function switchTab(tabId) {
            // Get current tab before switching
            const currentTab = localStorage.getItem('tornActiveTab');

            // Update tab buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Update tab content
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabId).classList.add('active');

            // Save active tab to localStorage
            localStorage.setItem('tornActiveTab', tabId);

            // Handle faction info display and auto-refresh visibility based on tab
            const autoRefreshInfo = document.getElementById('autoRefreshInfo');
            const membersOverviewTitle = document.getElementById('membersOverviewTitle');

            if (tabId === 'faction-spying') {
                // Hide auto-refresh info on Faction Spying tab
                if (autoRefreshInfo) autoRefreshInfo.style.display = 'none';
                // Update title for spying
                if (membersOverviewTitle) membersOverviewTitle.textContent = 'Faction Spying';
                // Update faction info and stats if we have spy data
                if (spyFactionData) {
                    updateMainFactionInfoForSpy();
                    updateStatsSummaryForSpy();
                }
                // Refresh war history dropdown
                populateWarHistoryDropdown();
            } else if (tabId === 'war-portal') {
                // Show auto-refresh info on War Portal tab
                if (autoRefreshInfo) autoRefreshInfo.style.display = 'block';
                // Update title for war portal
                if (membersOverviewTitle) membersOverviewTitle.textContent = 'War Portal';
                // Update faction info and stats for war portal (both factions)
                updateMainFactionInfoForWarPortal();
                updateStatsSummaryForWarPortal();
                // Auto-load enemy faction if not loaded, or validate existing
                const apiKey = document.getElementById('apiKey').value.trim();
                if (enemyMembersData.length === 0) {
                    autoLoadEnemyFaction();
                } else {
                    validateEnemyFaction();
                    // Ensure auto-refresh is running when switching to War Portal with existing data
                    if (apiKey) {
                        startUnifiedAutoRefresh();
                    }
                }
            } else {
                // Show auto-refresh info on other tabs (including My Faction)
                if (autoRefreshInfo) autoRefreshInfo.style.display = 'block';
                // Restore user's faction info when switching away from faction-spying or war-portal
                if (currentTab === 'faction-spying' || currentTab === 'war-portal') {
                    restoreUserFactionInfo();
                    restoreStatsSummaryForUser();
                    if (membersOverviewTitle && factionData) {
                        membersOverviewTitle.textContent = `Members Overview: ${factionData.name || 'Unknown Faction'}`;
                    }
                }
                // Ensure auto-refresh is running when switching to My Faction tab
                if (tabId === 'my-faction') {
                    const apiKey = document.getElementById('apiKey').value.trim();
                    if (apiKey) {
                        startUnifiedAutoRefresh();
                    }
                }
            }
        }

        // Restore active tab from localStorage
        function restoreActiveTab() {
            const savedTab = localStorage.getItem('tornActiveTab');
            if (savedTab) {
                const tabContent = document.getElementById(savedTab);
                const tabButton = document.querySelector(`.tab-button[onclick*="${savedTab}"]`);
                if (tabContent && tabButton) {
                    // Deactivate all tabs
                    document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
                    // Activate saved tab
                    tabButton.classList.add('active');
                    tabContent.classList.add('active');
                }
            }
        }

        // Sort portal members
        function sortPortalMembers(column, isEnemy) {
            if (isEnemy) {
                if (enemyPortalSortColumn === column) {
                    enemyPortalSortDirection = enemyPortalSortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    enemyPortalSortColumn = column;
                    enemyPortalSortDirection = 'asc';
                }
                // Save enemy sort state
                localStorage.setItem('tornEnemyPortalSortColumn', enemyPortalSortColumn);
                localStorage.setItem('tornEnemyPortalSortDirection', enemyPortalSortDirection);
            } else {
                if (ownPortalSortColumn === column) {
                    ownPortalSortDirection = ownPortalSortDirection === 'asc' ? 'desc' : 'asc';
                } else {
                    ownPortalSortColumn = column;
                    ownPortalSortDirection = 'asc';
                }
                // Save own sort state
                localStorage.setItem('tornOwnPortalSortColumn', ownPortalSortColumn);
                localStorage.setItem('tornOwnPortalSortDirection', ownPortalSortDirection);
            }
            renderWarPortal();
        }

        // Load portal sort state from localStorage
        function loadPortalSortState() {
            const savedOwnCol = localStorage.getItem('tornOwnPortalSortColumn');
            const savedOwnDir = localStorage.getItem('tornOwnPortalSortDirection');
            const savedEnemyCol = localStorage.getItem('tornEnemyPortalSortColumn');
            const savedEnemyDir = localStorage.getItem('tornEnemyPortalSortDirection');

            if (savedOwnCol) ownPortalSortColumn = savedOwnCol;
            if (savedOwnDir) ownPortalSortDirection = savedOwnDir;
            if (savedEnemyCol) enemyPortalSortColumn = savedEnemyCol;
            if (savedEnemyDir) enemyPortalSortDirection = savedEnemyDir;
        }

        // Get sorted members for portal
        function getSortedPortalMembers(members, sortCol, sortDir) {
            return [...members].sort((a, b) => {
                let aVal, bVal;

                switch(sortCol) {
                    case 'name':
                        aVal = a.name?.toLowerCase() || '';
                        bVal = b.name?.toLowerCase() || '';
                        break;
                    case 'level':
                        aVal = a.level || 0;
                        bVal = b.level || 0;
                        break;
                    case 'est_stats':
                        // Sort by total estimated/real stats
                        aVal = getBattleStats(a).total || 0;
                        bVal = getBattleStats(b).total || 0;
                        break;
                    case 'str':
                        aVal = getBattleStats(a).strength || 0;
                        bVal = getBattleStats(b).strength || 0;
                        break;
                    case 'def':
                        aVal = getBattleStats(a).defense || 0;
                        bVal = getBattleStats(b).defense || 0;
                        break;
                    case 'spd':
                        aVal = getBattleStats(a).speed || 0;
                        bVal = getBattleStats(b).speed || 0;
                        break;
                    case 'dex':
                        aVal = getBattleStats(a).dexterity || 0;
                        bVal = getBattleStats(b).dexterity || 0;
                        break;
                    case 'life':
                        const aLife = a.details?.life;
                        const bLife = b.details?.life;
                        aVal = aLife ? aLife.current / aLife.maximum : 0;
                        bVal = bLife ? bLife.current / bLife.maximum : 0;
                        break;
                    case 'status':
                        aVal = getMemberStatusText(a);
                        bVal = getMemberStatusText(b);
                        break;
                    case 'timer':
                        // Sort by hospital end time - players coming out first should be at top when ascending
                        // Players not in hospital get a very high value so they sort to bottom
                        const aInfo = getMemberStatusInfo(a);
                        const bInfo = getMemberStatusInfo(b);
                        aVal = aInfo.hospitalEndTime || Number.MAX_SAFE_INTEGER;
                        bVal = bInfo.hospitalEndTime || Number.MAX_SAFE_INTEGER;
                        break;
                    default:
                        aVal = a.name?.toLowerCase() || '';
                        bVal = b.name?.toLowerCase() || '';
                }

                if (aVal < bVal) return sortDir === 'asc' ? -1 : 1;
                if (aVal > bVal) return sortDir === 'asc' ? 1 : -1;
                return 0;
            });
        }

        // Get member status text for sorting/display
        function getMemberStatusText(member) {
            const profile = member.details || member;
            const userStatus = profile.status || {};
            let statusText = userStatus.description || userStatus.state || 'OK';
            return statusText;
        }

        // Get member status info for display
        function getMemberStatusInfo(member) {
            const profile = member.details || member;
            const userStatus = profile.status || {};
            let statusText = userStatus.description || userStatus.state || 'OK';
            let statusClass = 'status-ok';
            let hospitalEndTime = null;

            if (statusText.toLowerCase().includes('hospital')) {
                statusClass = 'status-hospital';
                statusText = 'HOSPITAL'; // Show just "HOSPITAL" - timer goes in separate column
                // Extract hospital time from status
                if (userStatus.until) {
                    hospitalEndTime = userStatus.until * 1000; // Convert to milliseconds
                }
            } else if (statusText.toLowerCase().includes('jail')) {
                statusClass = 'status-jail';
                statusText = 'Jail';
            } else if (statusText.toLowerCase().includes('travel') ||
                       statusText.toLowerCase().includes('flying') ||
                       statusText.toLowerCase().includes('returning')) {
                statusClass = 'status-traveling';
                // Shorten travel text - match war planning tab format
                const flyingMatch = statusText.match(/Flying to (.+)/i);
                const travelingToMatch = statusText.match(/Traveling to (.+)/i);
                const returningMatch = statusText.match(/Returning to (.+)/i);
                if (flyingMatch) {
                    statusText = 'Outbound: ' + flyingMatch[1];
                } else if (travelingToMatch) {
                    statusText = 'Outbound: ' + travelingToMatch[1];
                } else if (returningMatch) {
                    statusText = 'Inbound: ' + returningMatch[1];
                }
            } else {
                // Check for being abroad (In [country]) - but not hospital/jail
                const inCountryMatch = statusText.match(/In (.+)/i);
                if (inCountryMatch && !statusText.toLowerCase().includes('hospital') && !statusText.toLowerCase().includes('jail')) {
                    statusClass = 'status-traveling';
                    statusText = 'Abroad: ' + inCountryMatch[1];
                } else if (statusText.toLowerCase().includes('okay') || statusText === 'OK' || statusText.toLowerCase().includes('torn')) {
                    statusText = 'OK';
                    statusClass = 'status-ok';
                }
            }

            return { statusText, statusClass, hospitalEndTime };
        }

        // Format hospital timer as HH:MM:SS
        function formatHospitalTimer(endTime) {
            const now = Date.now();
            const remaining = endTime - now;

            if (remaining <= 0) {
                return 'OK';
            }

            const hours = Math.floor(remaining / (1000 * 60 * 60));
            const minutes = Math.floor((remaining % (1000 * 60 * 60)) / (1000 * 60));
            const seconds = Math.floor((remaining % (1000 * 60)) / 1000);

            return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }

        // Update all hospital timers on the page
        function updateHospitalTimers() {
            const timerElements = document.querySelectorAll('.hospital-timer[data-end-time]');
            timerElements.forEach(el => {
                const endTime = parseInt(el.dataset.endTime);
                if (endTime) {
                    const formatted = formatHospitalTimer(endTime);
                    el.textContent = formatted;
                    if (formatted === 'OK') {
                        // Timer expired - update the timer column and status column
                        const parentTimer = el.closest('.portal-member-timer');
                        if (parentTimer) {
                            parentTimer.classList.remove('has-timer');
                            parentTimer.innerHTML = '-';
                        }
                        // Also update the status column in the same row
                        const row = el.closest('.portal-member-row');
                        if (row) {
                            const statusCell = row.querySelector('.portal-member-status');
                            if (statusCell) {
                                statusCell.classList.remove('status-hospital');
                                statusCell.classList.add('status-ok');
                                statusCell.textContent = 'OK';
                            }
                        }
                    }
                }
            });

            // Update war end timer - recalculate based on current lead vs decaying target
            const warTimerEl = document.getElementById('warEndTimer');
            if (warTimerEl && currentWarScores.isActiveWar && currentWarScores.target > 0) {
                const calculatedEndTime = calculateWarEndTime();
                if (calculatedEndTime && calculatedEndTime > 0) {
                    const now = Math.floor(Date.now() / 1000);
                    const remaining = calculatedEndTime - now;
                    if (remaining <= 0) {
                        warTimerEl.textContent = '00:00:00';
                    } else {
                        const hours = Math.floor(remaining / 3600);
                        const minutes = Math.floor((remaining % 3600) / 60);
                        const seconds = remaining % 60;
                        warTimerEl.textContent = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
                    }
                    // Update the data attribute too
                    warTimerEl.dataset.endTime = calculatedEndTime;
                }
            }
        }

        // Start hospital timer interval
        function startHospitalTimerInterval() {
            if (hospitalTimerInterval) {
                clearInterval(hospitalTimerInterval);
            }
            hospitalTimerInterval = setInterval(updateHospitalTimers, 1000);
        }

        // Get cell content for portal member row
        // Helper to format individual stat cell with optional age tooltip
        function formatStatCell(statValue, isReal, daysAgo) {
            if (statValue === null || statValue === undefined) {
                return `<span class="est-value">-</span>`;
            }
            if (isReal) {
                const ageText = daysAgo !== null && daysAgo !== undefined ? `Spy data: ${daysAgo} day${daysAgo !== 1 ? 's' : ''} old` : '';
                return `<span class="real-value" title="${ageText}" style="cursor: ${ageText ? 'help' : 'default'};">${formatStatNumber(statValue)}</span>`;
            } else {
                return `<span class="est-value">${formatStatNumber(statValue)}</span>`;
            }
        }

        function getPortalCellContent(column, member, memberData, isEnemy = false) {
            const stats = memberData.estStats;
            const hasRealStats = stats.isReal && stats.strength !== undefined;
            switch (column) {
                case 'name':
                    const attackLink = isEnemy ? `<a href="https://www.torn.com/loader.php?sid=attack&user2ID=${member.id}" target="_blank" class="attack-skull" title="Attack ${member.name}">üíÄ</a>` : '';
                    return `<div class="portal-member-name" data-column="name">
                        <span class="status-indicator ${memberData.statusClass}"></span>
                        <a href="https://www.torn.com/profiles.php?XID=${member.id}" target="_blank">${member.name}</a>
                        ${attackLink}
                    </div>`;
                case 'level':
                    return `<div class="portal-member-level" data-column="level">
                        <span class="level-badge">Lv ${member.level || 'N/A'}</span>
                    </div>`;
                case 'est_stats':
                    // Show estimated stats only when we don't have real TornStats data
                    if (hasRealStats) {
                        return `<div class="portal-member-stats" data-column="est_stats"><span style="color: #999;">-</span></div>`;
                    } else {
                        const estTotal = stats.total || 0;
                        const tooltip = `Estimated Total: ${formatStatNumber(estTotal)}`;
                        return `<div class="portal-member-stats" data-column="est_stats">
                            <span class="est-value" title="${tooltip}" style="cursor: help;">${formatStatNumber(estTotal)}</span>
                        </div>`;
                    }
                case 'str':
                    // Show real stats only when we have TornStats data
                    if (hasRealStats) {
                        return `<div class="portal-member-stats" data-column="str">${formatStatCell(stats.strength, true, stats.daysAgo)}</div>`;
                    } else {
                        return `<div class="portal-member-stats" data-column="str"><span style="color: #999;">-</span></div>`;
                    }
                case 'def':
                    if (hasRealStats) {
                        return `<div class="portal-member-stats" data-column="def">${formatStatCell(stats.defense, true, stats.daysAgo)}</div>`;
                    } else {
                        return `<div class="portal-member-stats" data-column="def"><span style="color: #999;">-</span></div>`;
                    }
                case 'spd':
                    if (hasRealStats) {
                        return `<div class="portal-member-stats" data-column="spd">${formatStatCell(stats.speed, true, stats.daysAgo)}</div>`;
                    } else {
                        return `<div class="portal-member-stats" data-column="spd"><span style="color: #999;">-</span></div>`;
                    }
                case 'dex':
                    if (hasRealStats) {
                        return `<div class="portal-member-stats" data-column="dex">${formatStatCell(stats.dexterity, true, stats.daysAgo)}</div>`;
                    } else {
                        return `<div class="portal-member-stats" data-column="dex"><span style="color: #999;">-</span></div>`;
                    }
                case 'life':
                    return `<div class="portal-member-life ${memberData.lifeClass}" data-column="life">${memberData.life}</div>`;
                case 'status':
                    return `<div class="portal-member-status ${memberData.statusInfo.statusClass}" data-column="status">${memberData.statusInfo.statusText}</div>`;
                case 'timer':
                    return `<div class="portal-member-timer ${memberData.timerClass}" data-column="timer">${memberData.timerDisplay}</div>`;
                default:
                    return `<div data-column="${column}">-</div>`;
            }
        }

        function renderMemberRow(member, isEnemy = false) {
            const statusClass = member.last_action?.status === 'Online' ? 'online' :
                              member.last_action?.status === 'Idle' ? 'idle' : 'offline';

            const profile = member.details || member;
            const life = profile.life ? `${profile.life.current}/${profile.life.maximum}` : 'N/A';
            const lifeClass = profile.life && profile.life.current === profile.life.maximum ? 'full' : 'injured';
            const estStats = getBattleStats(member);

            // Get status info (hospital/traveling/ok)
            const statusInfo = getMemberStatusInfo(member);

            // Timer column - show countdown if in hospital, otherwise empty
            let timerDisplay = '-';
            let timerClass = '';
            if (statusInfo.hospitalEndTime) {
                const timerValue = formatHospitalTimer(statusInfo.hospitalEndTime);
                timerDisplay = `<span class="hospital-timer" data-end-time="${statusInfo.hospitalEndTime}">${timerValue}</span>`;
                timerClass = 'has-timer';
            }

            // Build tooltip with total battle stats
            let tooltip = '';
            if (estStats.total) {
                const totalFormatted = formatStatNumber(estStats.total);
                const statsType = estStats.isReal ? 'Spied' : 'Estimated';
                tooltip = `Total Battle Stats: ${totalFormatted} (${statsType})`;
                if (estStats.isReal && estStats.daysAgo !== null) {
                    tooltip += ` - Spied ${estStats.daysAgo} day${estStats.daysAgo !== 1 ? 's' : ''} ago`;
                }
            }

            // Prepare member data for cell rendering
            const memberData = {
                statusClass,
                life,
                lifeClass,
                estStats,
                statusInfo,
                timerDisplay,
                timerClass
            };

            // Get the appropriate column order
            const columnOrder = isEnemy ? enemyPortalColumnOrder : ownPortalColumnOrder;

            // Generate cells in column order
            const cells = columnOrder.map(col => getPortalCellContent(col, member, memberData, isEnemy)).join('');

            return `<div class="portal-member-row" title="${tooltip}">${cells}</div>`;
        }

        function renderWarPortal() {
            const container = document.getElementById('warPortalContainer');
            if (!container) return;

            // Get saved enemy faction ID
            const savedEnemyId = localStorage.getItem('tornEnemyFactionId') || '';

            // Get own faction info - use userFactionData if available, otherwise fall back to factionData
            const ownFaction = userFactionData || factionData;
            const ownMembers = userMembersData.length > 0 ? userMembersData : membersData;
            const ownFactionName = ownFaction ? (ownFaction.name || 'Your Faction') : 'Your Faction';
            const ownFactionTag = ownFaction ? (ownFaction.tag || '') : '';
            const ownFactionId = ownFaction ? (ownFaction.ID || '') : '';
            const ownMemberCount = ownMembers.length;
            const ownLeaderId = ownFaction?.leader || '';
            const ownLeaderName = ownLeaderId ? getOwnLeaderName(ownFaction, ownMembers) : 'N/A';

            // Get enemy faction info
            const enemyFactionName = enemyFactionData ? (enemyFactionData.name || 'Enemy Faction') : 'Enemy Faction';
            const enemyFactionTag = enemyFactionData ? (enemyFactionData.tag || '') : '';
            const enemyFactionId = enemyFactionData ? (enemyFactionData.ID || '') : '';
            const enemyMemberCount = enemyMembersData.length;
            const enemyLeaderId = enemyFactionData?.leader || '';
            const enemyLeaderName = enemyLeaderId ? getEnemyLeaderName() : 'N/A';

            // Warning note for Force Update buttons
            const forceUpdateWarning = '<span style="font-size: 10px; color: #856404; margin-left: 8px;">Warning: Refreshes all data including TornStats. Heavy API usage - only use if necessary.</span>';

            // Sort members
            const sortedOwnMembers = getSortedPortalMembers(ownMembers, ownPortalSortColumn, ownPortalSortDirection);
            const sortedEnemyMembers = getSortedPortalMembers(enemyMembersData, enemyPortalSortColumn, enemyPortalSortDirection);

            // Helper to get sort class
            const getOwnSortClass = (col) => ownPortalSortColumn === col ? (ownPortalSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc') : '';
            const getEnemySortClass = (col) => enemyPortalSortColumn === col ? (enemyPortalSortDirection === 'asc' ? 'sorted-asc' : 'sorted-desc') : '';

            // Helper to generate column with resize handle and drag support
            const colWithResize = (colName, sortClass, label, isEnemy) => {
                const widths = isEnemy ? enemyColumnWidths : ownColumnWidths;
                const width = widths[colName] || defaultColumnWidths[colName] || 65;
                const resizeHandle = `<span class="col-resize-handle" onmousedown="startColumnResize(event, '${colName}', ${isEnemy})"></span>`;
                // Map stat columns to use portal-member-stats class
                const statCols = ['str', 'def', 'spd', 'dex'];
                const className = statCols.includes(colName) ? 'stats' : colName;
                return `<div class="portal-member-${className} ${sortClass}"
                    onclick="sortPortalMembers('${colName}', ${isEnemy})"
                    draggable="true"
                    data-column="${colName}"
                    style="width: ${width}px; min-width: ${width}px; flex-shrink: 0;">${label}${resizeHandle}</div>`;
            };

            // Generate headers based on column order
            const generateHeaders = (columnOrder, getSortClass, isEnemy) => {
                return columnOrder.map((col) => {
                    const def = portalColumnDefs[col];
                    return colWithResize(col, getSortClass(col), def.label, isEnemy);
                }).join('');
            };

            // Column headers HTML with resize handles and drag support
            const ownHeadersHtml = `
                <div class="portal-header-row" id="ownPortalHeaderRow">
                    ${generateHeaders(ownPortalColumnOrder, getOwnSortClass, false)}
                </div>
            `;

            const enemyHeadersHtml = `
                <div class="portal-header-row" id="enemyPortalHeaderRow">
                    ${generateHeaders(enemyPortalColumnOrder, getEnemySortClass, true)}
                </div>
            `;

            // Stats color legend
            const statsLegend = `<div class="stats-legend">
                <span class="legend-item"><span class="legend-color" style="background:#28a745;"></span> Spied (TornStats)</span>
                <span class="legend-item"><span class="legend-color" style="background:#667eea;"></span> Estimated</span>
            </div>`;

            // Note for Check Status button
            const checkStatusNote = '<span style="font-size: 10px; color: #1565c0; margin-left: 8px;">Quick Update: Can be used several times in succession with low API usage when required. Performs the same function as auto-refresh instantly.</span>';

            // Build faction comparison panel with all stats
            const ownRespect = ownFaction ? (ownFaction.respect || 0) : 0;
            const ownAge = ownFaction ? (ownFaction.age || 'N/A') : 'N/A';
            const enemyRespect = enemyFactionData ? (enemyFactionData.respect || 0) : 0;
            const enemyAge = enemyFactionData ? (enemyFactionData.age || 'N/A') : 'N/A';

            // Calculate online/idle/offline stats for both factions
            const ownOnline = ownMembers.filter(m => m.last_action?.status === 'Online').length;
            const ownIdle = ownMembers.filter(m => m.last_action?.status === 'Idle').length;
            const ownOffline = ownMembers.filter(m => m.last_action?.status === 'Offline').length;
            const ownTotalLevel = ownMembers.reduce((sum, m) => sum + (m.level || 0), 0);
            const ownAvgLevel = ownMembers.length > 0 ? Math.round(ownTotalLevel / ownMembers.length) : 0;

            const enemyOnline = enemyMembersData.filter(m => m.last_action?.status === 'Online').length;
            const enemyIdle = enemyMembersData.filter(m => m.last_action?.status === 'Idle').length;
            const enemyOffline = enemyMembersData.filter(m => m.last_action?.status === 'Offline').length;
            const enemyTotalLevel = enemyMembersData.reduce((sum, m) => sum + (m.level || 0), 0);
            const enemyAvgLevel = enemyMembersData.length > 0 ? Math.round(enemyTotalLevel / enemyMembersData.length) : 0;

            // Calculate OK counts (members not in hospital, jail, or traveling)
            const getOkCount = (members) => {
                return members.filter(m => {
                    const statusInfo = getMemberStatusInfo(m);
                    return statusInfo.statusClass === 'status-ok';
                }).length;
            };
            const ownOkCount = getOkCount(ownMembers);
            const enemyOkCount = getOkCount(enemyMembersData);

            // Build war status banner HTML
            const warStatusBannerHtml = currentWarScores.isActiveWar ? (() => {
                const ownWinning = currentWarScores.ownScore >= currentWarScores.enemyScore;
                const enemyWinning = currentWarScores.enemyScore > currentWarScores.ownScore;
                const target = currentWarScores.target || 0;
                const lead = Math.abs(currentWarScores.ownScore - currentWarScores.enemyScore);

                // Calculate progress percentages for the progress bar based on lead vs target
                let leadProgressPct = 0;
                if (target > 0) {
                    leadProgressPct = Math.min((lead / target) * 100, 100);
                }

                // Calculate war end time based on target decay
                const calculatedWarEnd = calculateWarEndTime();

                // Format war end timer countdown
                const formatWarTimer = (endTimestamp) => {
                    if (!endTimestamp || endTimestamp === 0) return '--:--:--';
                    const now = Math.floor(Date.now() / 1000);
                    const remaining = endTimestamp - now;
                    if (remaining <= 0) return '00:00:00';
                    const hours = Math.floor(remaining / 3600);
                    const minutes = Math.floor((remaining % 3600) / 60);
                    const seconds = remaining % 60;
                    return hours.toString().padStart(2, '0') + ':' + minutes.toString().padStart(2, '0') + ':' + seconds.toString().padStart(2, '0');
                };

                // Format war end time in local timezone
                const formatWarEndTime = (endTimestamp) => {
                    if (!endTimestamp || endTimestamp === 0) return '';
                    const endDate = new Date(endTimestamp * 1000);
                    return endDate.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true }) + ' on ' + endDate.toLocaleDateString([], { month: 'short', day: 'numeric' });
                };

                const warEndTimeStr = formatWarEndTime(calculatedWarEnd);
                const warTimerStr = formatWarTimer(calculatedWarEnd);

                // Calculate current target with decay
                const getCurrentTarget = () => {
                    if (!currentWarScores.warStart || !target) return target;
                    const now = Math.floor(Date.now() / 1000);
                    const hoursElapsed = (now - currentWarScores.warStart) / 3600;
                    if (hoursElapsed <= 24) return target;
                    const decayPercent = Math.min(hoursElapsed - 24, 99);
                    return Math.floor(target * (1 - decayPercent / 100));
                };
                const currentTarget = getCurrentTarget();

                return `
                    <div class="war-status-banner">
                        <div class="war-status-header">
                            <span class="faction-name own">${currentWarScores.ownName || ownFactionName}</span>
                            <span class="vs-text">vs</span>
                            <span class="faction-name enemy">${currentWarScores.enemyName || enemyFactionName}</span>
                        </div>
                        <div class="war-status-scores">
                            <div class="war-score-box ${ownWinning ? 'winning' : 'losing'}">
                                <div class="score">${currentWarScores.ownScore.toLocaleString()}</div>
                                <div class="ok-count">‚äô ${ownOkCount} / ${ownMembers.length}</div>
                            </div>
                            <div class="war-lead-target">
                                <div class="label">Lead Target${target > 0 && currentTarget !== target ? ' (decayed)' : ''}</div>
                                <div class="target-info">${lead.toLocaleString()} / ${target > 0 ? currentTarget.toLocaleString() : '---'}</div>
                                <div class="progress-bar"><div class="own-progress" style="width: ${leadProgressPct}%; background: linear-gradient(90deg, ${ownWinning ? '#667eea, #764ba2' : '#dc3545, #a71d2a'});"></div></div>
                                <div class="war-timer" id="warEndTimer" data-end-time="${calculatedWarEnd || 0}">${warTimerStr}</div>
                                ${warEndTimeStr ? '<div class="war-end-time" style="font-size: 11px; color: #aaa; margin-top: 2px;">Ends at ' + warEndTimeStr + '</div>' : ''}
                            </div>
                            <div class="war-score-box ${enemyWinning ? 'winning' : 'losing'}">
                                <div class="score">${currentWarScores.enemyScore.toLocaleString()}</div>
                                <div class="ok-count">‚äô ${enemyOkCount} / ${enemyMembersData.length}</div>
                            </div>
                        </div>
                    </div>
                `;
            })() : '';

            container.innerHTML = `
                ${warStatusBannerHtml}
                <div class="war-portal-container">
                    <!-- Your Faction Column -->
                    <div class="faction-column">
                        <div class="faction-input-panel" style="border-radius: 8px 8px 0 0; border: 1px solid #ddd; flex-wrap: wrap;">
                            <div style="display: flex; align-items: center; width: 100%; margin-bottom: 4px;">
                                <button class="btn btn-blue" id="ownCheckStatusBtn" onclick="checkStatus()">Check Status</button>
                                ${checkStatusNote}
                            </div>
                            <div style="display: flex; align-items: center; width: 100%;">
                                <button class="btn" id="ownForceUpdateBtn" onclick="forceUpdateOwnTornStats()" title="Scan all members and refresh TornStats spy data">Force Update</button>
                                ${forceUpdateWarning}
                            </div>
                        </div>
                        <div class="faction-header">
                            <h3>${ownFactionTag ? '[' + ownFactionTag + '] ' : ''}${ownFactionName}${ownFactionId ? ' (' + ownFactionId + ')' : ''} ${ownLeaderId ? '- <a href="https://www.torn.com/profiles.php?XID=' + ownLeaderId + '" target="_blank" style="color: white; text-decoration: underline;">' + ownLeaderName + '</a>' : ''}</h3>
                            <div class="faction-header-stats" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px 12px; font-size: 11px; margin: 8px 0;">
                                <div><span style="opacity: 0.8;">Members:</span> <strong>${ownMemberCount}</strong></div>
                                <div><span style="opacity: 0.8;">Respect:</span> <strong>${ownRespect.toLocaleString()}</strong></div>
                                <div><span style="opacity: 0.8;">Age:</span> <strong>${ownAge} days</strong></div>
                                <div><span style="opacity: 0.8;">Avg Level:</span> <strong>${ownAvgLevel}</strong></div>
                                <div><span style="opacity: 0.8;">Online:</span> <strong>${ownOnline}</strong></div>
                                <div><span style="opacity: 0.8;">Idle:</span> <strong>${ownIdle}</strong></div>
                                <div><span style="opacity: 0.8;">Offline:</span> <strong>${ownOffline}</strong></div>
                            </div>
                            ${statsLegend}
                        </div>
                        <div class="faction-members-list" id="ownMembersList">
                            ${ownHeadersHtml}
                            ${sortedOwnMembers.length > 0
                                ? sortedOwnMembers.map(member => renderMemberRow(member, false)).join('')
                                : '<div class="portal-no-data">Loading your faction data...</div>'
                            }
                        </div>
                    </div>

                    <!-- Enemy Faction Column -->
                    <div class="faction-column">
                        <div class="faction-input-panel" style="border-radius: 8px 8px 0 0; border: 1px solid #ddd; flex-wrap: wrap;">
                            <div style="display: flex; align-items: center; width: 100%; margin-bottom: 4px;">
                                <button class="btn btn-blue" id="enemyCheckStatusBtn" onclick="checkStatus()">Check Status</button>
                                ${checkStatusNote}
                            </div>
                            <div style="display: flex; align-items: center; width: 100%;">
                                <button class="btn" id="enemyForceUpdateBtn" onclick="forceUpdateEnemyTornStats()" title="Scan all enemy members and refresh TornStats spy data">Force Update</button>
                                ${forceUpdateWarning}
                            </div>
                        </div>
                        <div class="faction-header enemy" style="border-radius: 0;">
                            <h3>${enemyFactionTag ? '[' + enemyFactionTag + '] ' : ''}${enemyFactionName}${enemyFactionId ? ' (' + enemyFactionId + ')' : ''} ${enemyLeaderId ? '- <a href="https://www.torn.com/profiles.php?XID=' + enemyLeaderId + '" target="_blank" style="color: white; text-decoration: underline;">' + enemyLeaderName + '</a>' : ''}</h3>
                            <div class="faction-header-stats" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 4px 12px; font-size: 11px; margin: 8px 0;">
                                <div><span style="opacity: 0.8;">Members:</span> <strong>${enemyMemberCount > 0 ? enemyMemberCount : 'N/A'}</strong></div>
                                <div><span style="opacity: 0.8;">Respect:</span> <strong>${enemyFactionData ? enemyRespect.toLocaleString() : 'N/A'}</strong></div>
                                <div><span style="opacity: 0.8;">Age:</span> <strong>${enemyFactionData ? enemyAge + ' days' : 'N/A'}</strong></div>
                                <div><span style="opacity: 0.8;">Avg Level:</span> <strong>${enemyMembersData.length > 0 ? enemyAvgLevel : 'N/A'}</strong></div>
                                <div><span style="opacity: 0.8;">Online:</span> <strong>${enemyMembersData.length > 0 ? enemyOnline : 'N/A'}</strong></div>
                                <div><span style="opacity: 0.8;">Idle:</span> <strong>${enemyMembersData.length > 0 ? enemyIdle : 'N/A'}</strong></div>
                                <div><span style="opacity: 0.8;">Offline:</span> <strong>${enemyMembersData.length > 0 ? enemyOffline : 'N/A'}</strong></div>
                            </div>
                            ${statsLegend}
                        </div>
                        <div class="faction-members-list" id="enemyMembersList">
                            ${enemyHeadersHtml}
                            ${sortedEnemyMembers.length > 0
                                ? sortedEnemyMembers.map(member => renderMemberRow(member, true)).join('')
                                : '<div class="portal-no-data">Searching for ranked war enemy...</div>'
                            }
                        </div>
                    </div>
                </div>
            `;

            // Start the hospital timer interval
            startHospitalTimerInterval();

            // Apply stored column widths to member rows
            applyColumnWidths(false); // Own faction
            applyColumnWidths(true);  // Enemy faction

            // Add drag event listeners for own faction header
            const ownHeaderRow = document.getElementById('ownPortalHeaderRow');
            if (ownHeaderRow) {
                ownHeaderRow.addEventListener('dragstart', (e) => handlePortalDragStart(e, false));
                ownHeaderRow.addEventListener('dragover', (e) => handlePortalDragOver(e, false));
                ownHeaderRow.addEventListener('dragleave', handlePortalDragLeave);
                ownHeaderRow.addEventListener('drop', (e) => handlePortalDrop(e, false));
                ownHeaderRow.addEventListener('dragend', handlePortalDragEnd);
            }

            // Add drag event listeners for enemy faction header
            const enemyHeaderRow = document.getElementById('enemyPortalHeaderRow');
            if (enemyHeaderRow) {
                enemyHeaderRow.addEventListener('dragstart', (e) => handlePortalDragStart(e, true));
                enemyHeaderRow.addEventListener('dragover', (e) => handlePortalDragOver(e, true));
                enemyHeaderRow.addEventListener('dragleave', handlePortalDragLeave);
                enemyHeaderRow.addEventListener('drop', (e) => handlePortalDrop(e, true));
                enemyHeaderRow.addEventListener('dragend', handlePortalDragEnd);
            }

            // Update faction info and stats summary for War Portal
            const currentTab = localStorage.getItem('tornActiveTab');
            if (currentTab === 'war-portal') {
                updateMainFactionInfoForWarPortal();
                updateStatsSummaryForWarPortal();
            }
        }

        function filterPortalMembers() {
            // Filtering removed as the new layout doesn't use search/filter
            renderWarPortal();
        }
    </script>
</body>
</html>
